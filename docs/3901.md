# UNIX 哲学的崩溃

> 原文:[https://kukuruku . co/post/the-collapse-of-the-UNIX-philosophy/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://kukuruku.co/post/the-collapse-of-the-unix-philosophy/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

在文章的第一部分，我将列举大量 UNIX 的廉价和肮脏的黑客行为，以及其他各种各样的缺点。在第二部分，我们将讨论 UNIX 哲学。这篇文章写得比较仓促，不想进一步完善。你很幸运是我写的。因此，我可能会提供一些没有来源链接的事实。

UNIX 中的脏 hacks 在 UNIX 发布的时候就开始出现了，在 Windows 出现之前很久，我猜当时甚至还没有微软的 DOS(我猜也懒得去查，自己去查吧)。如果你不想读，至少把所有的要点都看一遍。你会发现一些有趣的东西。这不是一个完整的列表。这些简直就是我想提的瑕疵。

*   最初，`make`是一个人为自己和一些朋友编写的程序。他不假思索地让命令理解以制表符开头的字符串。也就是说，制表符和空格被区别对待，这对于 UNIX 及其以外的任何地方来说都是极其糟糕和不寻常的。他之所以这样做，是因为他认为除了这一小部分人之外，`make`不会被任何人使用。后来有人认为`make`是个好东西，把它包含到标准的 UNIX 包中会很好。*为了不破坏已经写好的 makefiles，(意思是这十个人写的)，他决定什么都不改*。嗯，事情就是这样…我们都因为那十个人而受苦。

*   几乎在最开始的时候，UNIX 中没有 */usr* 文件夹。所有二进制文件都位于 */bin* 和 */sbin* 。后来，UNIX 作者(Dennis Ritchie 和 Ken Thompson)的光盘上再也装不下所有的信息了。因此，他们拿了另一张光盘，并在其中创建了 */usr* 文件夹、另一个 *bin* 和另一个 *sbin* 。他们将新光盘安装到 */usr* 。它就是从那里来的。 */usr* 的“第二层次”就是这样出现的。在某个时刻，还出现了 */usr/local* 的“第三层次”，然后是 */opt* 。故事的讲述者说“我仍然在等待 */opt/local* 的出现……”[这里是我了解这个故事的地方。这是所发生事情的更准确的版本。](http://lists.busybox.net/pipermail/busybox/2010-December/074114.html)

*   sbin 最初的意思是“静态 bin”，而不是人们可能认为的“超级用户 bin”。 *sbin* 曾经包含静态二进制文件。但是后来 *sbin* 开始包含动态二进制，它的名字就失去了意义。

*   Windows 经常因为有注册表而受到批评。同时，人们说类 UNIX 系统(大量配置)的方法更好。顺便说一句，ext4 曾经出现过一个“特性”(是不是 bug 还是个大问题)，让 Gnome 在掉电后失去了用户工作目录中的所有配置。在讨论 bug 报告时，ext4 的维护者说 Gnome 应该使用类似注册表的东西来存储信息。来源:[一](https://lwn.net/Articles/322823/)和[两](https://bugs.launchpad.net/ubuntu/+source/linux/+bug/317781)。ext4 的维护者名叫 Theodore Ts'o。他是这样说的:

> 如果你真的关心确保磁盘上的东西，你必须使用 fsync 或 fdatasync。如果你担心的是`fsync()`的性能开销，`fdatasync()`的重量级要小得多，如果你能安排确保文件的大小不经常改变的话。你可以通过一个二进制数据库来实现，这个数据库是成块增长的，很少被截断。我会注意到我使用 gnome 桌面(这意味着 GNOME 面板，但我不是一个非常主要的桌面用户)，并且`find .[a-zA-Z]\* -mtime 0`不会显示大量的文件。我猜是某些写得很差的应用程序创建了数百个点文件，人们报告这些文件变得零长度，如果他们经常看到这种情况，那一定是因为点文件更新得非常频繁。我不知道坏的应用程序是什么，但抱怨大量状态文件消失的人应该检查哪个应用程序被涉及，并试图找出它们被修改的频率。正如我所说的，如果大量文件被频繁修改，这对 SSD 也是不利的，有多种理由修复写得不好的应用程序，即使 2.6.30 将修复最常见的情况。(尽管有些服务器可能会安装一个标记来禁用它，因为这会影响性能。)

更不用说每隔(！idspnonenote)读取的关键 UNIX 文件(如 */etc/passwd* )了。)调用，说，`ls -l`，都是纯文本文件。在每次调用之后，系统会一次又一次地读取和解析这些文件！使用二进制格式会好得多。或者数据库。或者注册表。至少对于对性能至关重要的系统文件是如此。

> 两个著名的人，一个来自麻省理工学院，另一个来自伯克利(但是在 Unix 上工作)，曾经会面讨论操作系统问题。这个来自麻省理工学院的人对 ITS(麻省理工学院人工智能实验室操作系统)很了解，并且一直在阅读 Unix 源代码。他对 Unix 如何解决个人电脑失败的问题很感兴趣。当一个用户程序调用一个系统例程来执行一个可能有重要状态的冗长操作时，例如 IO 缓冲区，就会出现 PC 丢失问题。如果操作过程中发生中断，必须保存用户程序的状态。因为系统例程的调用通常是一条指令，所以用户程序的 PC 不能充分地捕捉进程的状态。系统例程必须要么退出，要么向前按。正确的做法是退出并将用户程序 PC 恢复到调用系统例程的指令，以便例如中断后用户程序的恢复重新进入系统例程。它被称为“个人电脑失败者”,因为个人电脑被强制进入“失败者模式”,而“失败者”是麻省理工学院对“用户”的亲切称呼。麻省理工学院的家伙没有看到任何处理这种情况的代码，并询问新泽西的家伙问题是如何处理的。新泽西的家伙说 Unix 的人意识到了这个问题，但解决方案是让系统例程总是完成，但有时会返回一个错误代码，表明系统例程未能完成它的动作。然后，一个正确的用户程序必须检查错误代码，以确定是否只是再次尝试系统例程。麻省理工学院的家伙不喜欢这个解决方案，因为它不是正确的事情。— [理查德·加布里埃尔的《更坏更好的崛起》](http://doc.cat-v.org/programming/worse_is_better)

换句话说，如果您已经从用户输入中捕获了 Ctrl+C，那么操作系统将会中断之前运行的 syscall 并从内核返回`EINTR`错误代码，而不仅仅是调用您的处理程序。结果，程序员将不得不预见这个`EINTR`，这将使用户空间代码变得复杂。代价是简化了内核代码。是的，它应该以不同的方式完成——使内核代码复杂化，并简化用户空间代码。但是上面引用的那个家伙一点也不在乎。他实际上说“我不在乎每个人都会受苦。主要是内核代码更简单”。

它从那里起飞。提到的行为后来在 UNIX 系统中通过添加所谓的`SA_RESTART`得到了修复。因此，他们添加了一个特殊的标志，而不是修复一切。他们不仅增加了`SA_RESTART`，它并不总是工作！特别是在 GNU/Linux 中`select`、`poll`、`nanosleep`等即使在`SA_RESTART`的情况下，在捕获中断后也不会继续运行！

*   一般来说，最初的 UNIX 开发过程中出现的特定环境对它有很大的影响。我在某处读到过，`cp`命令被称为`cp`不是因为 copy，而是因为 UNIX 是使用输出字符非常慢的终端开发的。因此，输入`cp`比输入`copy`要快。用`cp`和`copy`的例子找不到很久以前看到的链接，但是这里有[这个链接](http://catalogue.pearsoned.co.uk/samplechapter/0130213446.pdf)。命令——这些是真实的单词吗？>基本的 AIX 命令(以及所有的 UNIX 系统命令)在很大程度上是非常简短、晦涩的两个字母的命令名。想象一下几年前，计算机只有非常慢的电传键盘和纸质“显示器”(有些人不是在想象，而是在回忆！)想象一下，那些不喜欢输入长命令的人，因为在命令和计算机响应之间有很长的延迟。如果有任何错误，用户必须>重新键入全部内容(对于那些只用>两个手指打字的人来说尤其令人恼火！).另外，一些 UNIX 命令来自大学生和研究人员，他们不受可用性标准的约束(没有规则，仅仅是来自同行的压力)。他们>可以写一个非常有用、聪明的命令，并给它起任何名字——比如他们自己的首字母，>(Aho、Weinberger 和 Kernighan 的 awk)，或者一个首字母缩写> (yacc，另一个编译器-编译器)。

*   UNIX 实用程序的名称是另一个故事。例如，`grep`来自于`ed`文本编辑器中的命令`g/re/p`。嗯，`cat`来源于串联。我希望你已经知道了。更重要的是，`vmlinuz`——gzip LINUx 支持虚拟内存。

*   **出乎意料**，`printf`远不是在屏幕上或文件中显示信息的最快方式。你不知道这件事，是吗？事情是这样的`printf`，以及 UNIX 本身，不是为了时间的优化，而是为了内存的优化。`printf`每次在运行时解析一个格式字符串。这就是为什么在 H2O 网络服务器上发明了一种特殊的预处理器，将格式字符串的解析转移到编译阶段。来源可以在[这里](http://blog.kazuhooku.com/2014/10/announcing-qrintf-and-qrintf-gcc.html)找到。

*   当《UNIX》的作者肯·汤普森(与丹尼斯·里奇一起)被问及他会在 UNIX 中做出什么改变时，他回答说他会给`creat`(原文如此！)起`create`的作用。来源很多，比如[这个](https://en.wikiquote.org/wiki/Ken_Thompson)。无可奉告。我应该指出的是，Ken Thompson 和最初 UNIX 的其他开发人员一起创建了 Plan 9 系统，修复了许多 UNIX 缺陷。这个函数在里面叫`create`:他做的:)

*   这是另一句名言:

> 死去但从未被等待的孩子并没有真正死去，因为它仍然消耗磁盘交换和系统表空间。这可能导致无法创建新流程。当 shell 中有几个&分隔符，后面没有带&符号的命令时，就可以注意到这个错误。通常情况下，当输入一个普通的命令时，事情会自行清理，但也可能出现不接受任何命令的情况，因此不进行等待；然后系统被挂起。解决方法可能是使用一种新的 fork，它创建了一个不需要等待的流程；还可以限制进程允许的活动或不活动后代的数量。— [来源](https://www.bell-labs.com/usr/dmr/www/pdfs/man22.pdf)

这段引文来自早期的 UNIX 手册。即使在那时，僵尸进程的存在也被认为是一个缺陷。但是这个 bug 后来干脆就被遗忘了。这个问题不用多说，反正后来解决了。所以，现代 GNU/Linux 中有杀死僵尸进程的工具，但是很少有人知道它们。你不能用常规的杀戮来消灭僵尸。每个人都说僵尸进程的存在“是为了设计”。

*   让我们多谈一点关于提到的 C 语言。其实 C 是和 UNIX 同时开发的。这就是为什么在批评 UNIX 时，我们也应该评论 C。关于 C 有多差，已经有很多文章写了，我就不一一赘述了。类型的语法不好，处理器很可怕，所有这些`4["string"]`，还有`sizeof ('a') != sizeof (char)`(C 里的，不是 C++里的！)，以及所有这些`i++ + ++i`，和`while (*p++ = *q++) ;`(这个例子来自 Stroustrup 的书，第二修订版)，等等等等。我只想说一件事。我们仍然不知道如何在 c 中方便地使用字符串。使用字符串的不便总是会导致各种安全问题。这个问题还是没有解决！这里有一份来自 c 委员会的[相对较新的文档](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1969.htm),它讨论了一种颇有争议的解决字符串问题的方法。结论是这种方法不好。出版年份:2015 年。这意味着即使到 2015 年也没有最终解决方案！

    更不用说缺乏一个简单、用户友好和多平台的构建系统(不是这个不支持 Windows 的`autotools`怪物，也不是另一个支持 Windows 的`cmake`怪物，但它仍然是一个怪物)，标准的包管理器，和一个用户友好的，像`npm` (js)或`carge` (rust)，可移植性库，在它的帮助下，人们至少可以跨所有平台读取文件夹的内容。 至少*C 的主网站*将成为所有初学者的主要入口，不仅包含文档，还包含在任何平台上安装 C 工具的简要手册，以及用 C 创建简单项目的手册，还将包含用户友好的 C 包列表(应该在标准库中)，最重要的是，它将成为*用户社区*的聚集地。 我甚至已经注册了 c-language.org 域名，希望在那里创建这样一个网站。是啊，做梦吧！(我甚至还有 cpp-language.org*，bwahaha！).但是他们不具备这一切，即使所有流行语言都具备，除了 C 和 C++。就连哈斯克尔都有这个！还有铁锈！

    在 Rust 中，这个 jackanapes，它的目标是与 C 相同的利基，有一个单独的配置，它也是项目配置、构建器配置和包管理器配置(实际上，`cargo`同时是包管理器和构建系统)。作为给定包的依赖，可以指定位于 **GIT** 中某处的另一个包，包括指定一个 **GITHUB** 库作为直接依赖。对从源代码中的标记注释生成文档的现成支持。一个使用 **SEMVER** 进行版本管理的包管理器。于是， **GIT** ， **GITHUB** ， **MARKDOWN** ， **SEMVER** 。换句话说，**流行语**，**流行语**，**潮人流行语**。所有这些都是现成的。你只要去他们的主网站，它就在这里。所有这些在所有平台上都以相同的方式工作。尽管 Rust 是一种系统编程语言，而不仅仅是一些 JavaScript。尽管我们可以在 Rust 中播放字节。里面还有一个指针算法。那么，为什么 Rusters 有这些时髦的流行语，而我们 C-guys 没有呢？真可惜。

    我记得我的一个朋友是怎么问我去哪里找 C/C++的包列表的。我不得不告诉他没有这样的地方。他问我 C/C++程序员是不是一定要吃亏。我没什么可告诉他的。哦，对了。我还忘了一件事。看看 C 标准中信号函数的原型:*

    ```
    void (*signal(int sig, void (*func)(int)))(int); 
    ```

    试着理解一下。

*   UNIX 中的终端——奇怪的遗产。详情[此处](http://catern.com/posts/terminal_quirks.html)。

*   Unix 文件系统(ext2 和其他)中的文件名只是一个没有编码的字节流。这取决于它们将被解释为何种编码的语言环境。因此，如果我们在一个地区的操作系统中创建一个文件，然后尝试在另一个地区查看它的名称，不会有什么好结果。在 Windows NTFS 中没有这样的问题。

*   UNIX shell 比 PHP 还烂！是的，你不知道吗？现在批评 PHP 是一件很流行的事情。但是 UNIX shell 更糟糕…当我们试图用它开发时，它变得尤其糟糕，因为它不是一种成熟的编程语言。但是即使对于它的利基市场来说，编写普通的管理任务也没有什么好处。其原因是 shell 的原始性、一般的低效安排、遗留问题、大量的特殊情况、肮脏的黑客行为、引号、反斜杠、特殊字符的混乱以及 shell 对纯文本的痴迷(就像整个 UNIX 一样)。

    *   让我们从一个难题开始。如何递归找到文件夹 *foo* 中所有名称为`\`的文件？正确答案是:`find foo -name '\\'`。我们也可以这样做:`find foo -name \\\\`。后一种方式会引起很多问题。尝试向一个不擅长 UNIX shell 的人解释为什么这里正好需要四个反斜杠，而不是两个或八个。我们需要在这里写四个反斜杠，因为 UNIX shell 执行反斜杠扩展，`find`也是这样做的。
    *   如何将 *foo* (及其子文件夹)中的所有文件`touch`？乍一看，我们可以这样做:`find foo | while read A; do touch $A; done`。乍一看。实际上，我们可以想出 5 件可能会毁掉这一切(并导致安全问题)的事情:
        *   文件名可以包含反斜杠。因此，我们应该写`read -r A`而不是`read A`
        *   文件名可以包含斜线。这就是为什么我们应该写`touch "$A"`而不是`touch $A`
        *   文件名不仅可以包含空格，还可以以空格开头。所以我们需要写`IFS="" read -r A`而不是`read -r A_`
        *   文件名可以包含一个换行符，所以我们应该使用`find foo -print0`而不是`IFS="" read -r A`使用`IFS="" read -rd ""`(我在这里不是很确定)
        *   文件名可以以连字符开头，所以我们需要写`touch -- "$A"`而不是`touch "$A"`。最终版本看起来像这样:`bash find foo -print0 | while IFS="" read -rd "" A; do touch -- "$A"; done`很酷，不是吗？顺便说一下，我们没有考虑到 POSIX 不保证`touch`支持选项`--`。考虑到这个事实，我们必须检查每个文件是否以连字符开头(或者不是以斜杠开头)，并在开头添加`./`。你现在明白为什么`autoconf`生成的*配置*脚本如此之大，难以阅读了吧？因为*配置*需要考虑所有这些废话，包括与各种 shells 的兼容性。在这个例子中，我使用了管道和回路的解决方案。我也可以使用带有`exec`或`xargs`的解决方案，但不会那么醒目。(嗯，好吧。我们知道文件名以 *foo* 开头，所以不能以连字符空格开头)。
    *   假设我们需要删除主机 *[【电子邮件保护】](/cdn-cgi/l/email-protection)* 上的一个文件。文件名在变量`A`中。怎么才能做到呢？或许，像这样:`ssh [[email protected]](/cdn-cgi/l/email-protection) rm -- "$A"`？(您可能已经注意到，我们已经考虑到文件名可以包含空格并以连字符开头)永远不要这样做！`ssh`不是`chroot`、或`setsid`、或`nohup`、或`sudo`或任何其他接收 exec-command(指通过系统调用直接传输`execve`系列的命令)的命令。`ssh`(和`su`一样)接收一个 shell 命令，即 shell 处理的命令(exec-command 和 shell-command 是我自己的)。`ssh`将所有的参数组合成一个字符串，并将该字符串传递到远程端，在那里由 shell 执行。好吧，也许是这样:`ssh [[email protected]](/cdn-cgi/l/email-protection) 'rm — "$A"'`？不，该命令试图在远程端查找变量`A`。但是它不在那里，因为变量不能通过`ssh`传递。嗯，可能是这样:`ssh [[email protected]](/cdn-cgi/l/email-protection) "rm -- '$A'"`？不，如果文件名包含单引号，这将不起作用。反正正确答案是:`ssh [[email protected]](/cdn-cgi/l/email-protection) "rm -- $(printf '%q\n' "$A")"`方便，你说呢？
    *   如何到达主机*【邮件保护】* ，然后从中到 *[【邮件保护】](/cdn-cgi/l/email-protection)* ，再到 *[【邮件保护】](/cdn-cgi/l/email-protection)* ，再到 *[【邮件保护】](/cdn-cgi/l/email-protection)* 并从中删除 */foo* 文件？嗯，这个很简单:`bash ssh [[email protected]](/cdn-cgi/l/email-protection) "ssh [[email protected]](/cdn-cgi/l/email-protection) \"ssh [[email protected]](/cdn-cgi/l/email-protection) \\\"ssh [[email protected]](/cdn-cgi/l/email-protection) \\\\\\\"rm /foo\\\\\\\"\\\"\""`反斜杠太多了，是吧？好吧，如果你不喜欢，让我们交替使用单引号和双引号:`bash ssh [[email protected]](/cdn-cgi/l/email-protection) 'ssh [[email protected]](/cdn-cgi/l/email-protection) "ssh [[email protected]](/cdn-cgi/l/email-protection) '\''ssh [[email protected]](/cdn-cgi/l/email-protection) \"rm /foo\"'\''"'`顺便说一下，如果我们使用 Lisp 而不是 shell，`ssh`函数将不是一个字符串而是一个经过解析的 AST(抽象语法树)传递到远程端，就不会有这么多反斜杠:`lisp (ssh "[[email protected]](/cdn-cgi/l/email-protection)" '(ssh "[[email protected]](/cdn-cgi/l/email-protection)" '(ssh "[[email protected]](/cdn-cgi/l/email-protection)" '(ssh "[[email protected]](/cdn-cgi/l/email-protection)" '(rm "foo")))))`“嗯？什么？Lisp？什么口齿不清？”很好奇，不是吗？点击阅读[。你也可以参考保罗·格拉厄姆的其他文章。](http://paulgraham.com/avg.html)
    *   我们把前面两段结合起来。文件的名称在变量`A`中。我们需要到 *[【邮件保护】](/cdn-cgi/l/email-protection)* ，然后到 *[【邮件保护】](/cdn-cgi/l/email-protection)* ，再到 *[【邮件保护】](/cdn-cgi/l/email-protection)**[【邮件保护】](/cdn-cgi/l/email-protection)* ，删除变量`A`中的文件。我会把它留给你作为练习。(不知道怎么做。:)嗯，如果我考虑的话可能会的)
    *   是为在屏幕上显示字符串而设计的。但问题是，如果字符串比“Hello，world！”稍微复杂一点，我们就不能将它用于这个目的打印一个随机字符串(例如来自变量 A)的唯一正确方法是这样的:`printf '%s\\n' "$A"`。
    *   假设您想将 stdout 和 stderr cmd 命令指向 */dev/null* 。谜题:这六个命令中的哪一个执行任务？`bash cmd > /dev/null 2>&1 cmd 2>&1 > /dev/null { cmd > /dev/null; } 2>&1 { cmd 2>&1; } > /dev/null ( cmd > /dev/null ) 2>&1 ( cmd 2>&1 ) > /dev/null`原来，正确答案是:1 号，4 号，6 号。而第二、第三、第五不要。再说一次，我把找出原因留给你作为练习。:)
*   实际上，这个帖子是对[这个](https://blogs.msdn.microsoft.com/oldnewthing/20170208-00/?p=95395)的回应。它说一个特殊的日期在 Windows 中被用作驱动程序时间戳。而不是引入一个特殊属性或者检查制造商。在 UNIX 中有很多类似的东西。文件的隐藏仅基于文件开头的点，而不是特殊属性。当我第一次知道它的时候，我很震惊(是的，在那个年代，我第一次安装了 Ubuntu)。“真是个白痴！”，我想。但我现在已经习惯了。但仔细想想，这是一个可怕的变通办法。然后，shell 根据第一个字符传递给 argv0 的连字符来决定它是否是登录 shell。这是对`argv[0]`的误用。`argv[0]`不是为了这个目的。任何其他方法都会更好，例如使用另一个参数或某个环境变量。

*   在 BSD 套接字中，用户必须自己改变端口号的字节顺序。这一切都是因为有人在 UNIX 内核代码中犯了一个错误，没有预见到字节顺序的变化。作为一个临时的黑客，有人修复了用户空间而不是内核代码。事情就是这样。这就是它来自 Windows 的地方(连同文件`/etc/hosts`，又名`C:\windows\system32\drivers\etc\hosts`)。[来源](http://blog.erratasec.com/2013/02/unlearning-college.html)。

## UNIX 哲学

有人认为 UNIX 很伟大，很完美，它所有的基本思想(一切都是文件，一切都是文本等等)都很神奇，形成了所谓的“UNIX 哲学”。我猜你开始明白事实并非如此。我们来回顾一下这个“Unix 哲学”。看看下面的几点。我并不是说所有这些东西都应该取消，我只是指出了一些缺点。*“一切都是文字”。正如我们在使用`/etc/passwd`的例子中已经看到的，普通文本的广泛使用会导致性能问题。UNIX 作者实际上已经为每个系统配置发明了一种格式(`passwd`、`fstab`等)。).使用它们的转义特殊字符的规则。惊讶吗？`/etc/fstab`使用空格和换行符作为分隔符。但是如果文件夹名包含空格呢？在这种情况下，`fstab`的格式为文件夹名提供了特殊的转义字符。事实证明，任何阅读`fstab`的脚本都应该能够解释转义字符。例如，用于此目的的`fstab-decode`实用程序(以 root 用户身份运行)。你不知道这件事，是吗？去修改你的剧本。:)因此，我们需要一个用于每个系统配置的解析器。如果我们使用 JSON 或 XML 进行系统配置，事情会简单得多。或者某种二进制格式。尤其是那些经常被不同程序读取的配置。因此，他们需要良好的读取速率(二进制格式的读取速率更高)。

关于“一切都是文本”，我想说的还不止这些。标准实用程序以纯文本的形式提供输出。对于每个实用程序，我们实际上需要一个自己的解析器。我们经常需要使用`sed`、`grep`、`awk`等来解析一个输出。每个实用程序都有自己的选项来确定显示哪些列、按哪些列排序等等。如果实用程序以 XML、JSON、某种二进制格式或其他格式提供输出，那就更好了。为了以用户友好的方式显示这些信息并对其进行进一步处理，我们可以通过管道将结果传递给其他实用程序，这些实用程序可以删除某些列、按某些列排序、选择所需的字符串等。它们要么以一个漂亮的表格的形式显示结果，要么将结果传递到其他地方。所有这些都是以多用途的方式执行的，不依赖于生成输出的初始实用程序。不需要通过正则表达式解析任何东西。UNIX shell 不擅长处理 JSON 和 XML。但是 UNIX shell 有很多其他的缺点。我们最好扔掉它，使用一些其他语言，这些语言可以很好地处理 JSON 之类的东西，并做许多其他事情。

试想一下！假设我们需要删除当前文件夹中所有大于 1kb 的文件。是的，我知道我们可以用`find`做到这一点。但是让我们假设我们肯定需要通过`ls`(并且没有`xargs`)来做这件事。怎么做？像这样:

```
LC_ALL=C ls -l | while read -r MODE LINKS USER GROUP SIZE M D Y FILE; do if [ "$SIZE" -gt 1024 ]; then rm -- "$FILE"; fi; done 
```

我们在这里需要 LC_ALL 来确保日期在`ls`的输出中正好取三个字。这种解决方案不仅看起来难看，而且有许多缺点。首先，如果文件名包含换行符或以空格开头，它将不起作用。接下来，我们需要明确列出所有`ls`列的名称，或者至少记住我们需要的列(即大小和文件)的位置。如果我们在列的顺序上犯了一个错误，这个错误只会在运行时变得明显。当我们删除了错误的文件。:)

在我建议的完美世界中，这个解决方案会是什么样子？类似这样的:`ls | grep 'size > 1kb' | rm`。它很短，最重要的是，你可以在代码中看到它的含义，并且不可能出错。让我们看看。在我的世界里，`ls`总是给出所有的信息。我们不需要一个特殊的`-l`选项。当需要删除所有列而只留下文件名时，我们可以使用一个特殊的实用程序来完成，我们应该将`ls`输出指向这个实用程序。因此，`ls`提供了某种结构化形式的文件，比如 JSON。这种表示“知道”列的名称及其类型。即字符串、数字或其他东西。然后，这个输出通过管道传输到`grep`，在我的世界中，它从 JSON 中选择必要的字符串。JSON“知道”字段名，所以`grep`“理解”这里的“大小”是什么意思。此外，JSON 包含关于 size 字段类型的信息。它包含它是一个数字的信息，甚至它不仅仅是一个数字，而是一个文件大小。因此，我们可以把它比作 1kb。接下来，`grep`将输出传送到`rm`。`rm`“看到”它要接收文件。是的，JSON 也存储这些字符串的类型信息，它们是文件。`rm`删除它们。JSON 还负责纠正特殊字符转义。这就是为什么带有特殊字符的文件“简单地工作”。很酷，对吧？我把这个想法从[带到这里](https://blogs.gnome.org/alexl/2012/08/10/rethinking-the-shell-pipeline/)。还应该提到的是，Windows Powershell 中也实现了类似的功能。

*   UNIX shell。UNIX 的另一个基本概念。我已经在文章的第一部分提到了 UNIX shell 的一些小缺点。UNIX shell 有什么「酷」？*在它发布的那一瞬间*(那是很久以前的事了)，比其他操作系统内嵌的命令解释器强多了。它允许编写更强大的脚本。似乎 UNIX shell 在发布时是最强大的脚本语言。因为过去没有健全的脚本语言(也就是说那些允许全面编程而不仅仅是脚本的语言)。后来，一位名叫拉里·沃尔的程序员注意到，UNIX shell 缺少很多被认为是好的编程语言的东西。他决定将 UNIX shell 的简单性与 c 语言成熟的编程能力结合起来，他创建了 Perl。是的，Perl 和其他随后的脚本编程语言实际上取代了 UNIX shell。甚至“UNIX 哲学”的作者之一 Rob Pike 也证实了这个事实。在回答关于“一个工作一个工具”的问题时，他说:“那些日子已经一去不复返了，悼词是由 Perl 发表的”。实际上，我相信这个短语指的是 UNIX shell 的一种典型用法，即在一个 shell 脚本中组合大量小工具的情况。不，Pike 说，简单地使用 Perl。

    UNIX shell 我还没说完。让我们回顾一下上面我已经提供的 shell 代码的例子:`shell find foo -print0 | while IFS="" read -rd "" A; do touch -- "$A"; done`我们在这里的循环中调用`touch`(我确实知道代码可以用`xargs`重写，这样`touch`只被调用一次；但是现在让我们忘记它，好吗？).我们称`touch`为圈内人！这意味着每个文件都有一个新的进程。这是极其低效的。任何其他编程语言的代码都会比这种语言运行得更快。但是当 UNIX shell 出现时，它是少数几种允许在一个字符串中编写这个动作的语言之一。

    长话短说，我们应该使用任何其他脚本编程语言来代替 UNIX shell。一种不仅适用于脚本编写，也适用于实际编程的语言。这种语言不会在我们每次需要`touch`一个文件时运行一个新的进程。也许，我们将不得不借用 shell 的一些特性来进一步简化事情。
*   简单。我不是在谈论 shell 和结合 shell 的许多简单实用程序(这是前一点)。我说的是简单。使用简单的工具。说着，用`sed`编辑了一张图片。是的，是的。借助命令行将 *jpg* 转换成 *ppm* 。然后，使用图形编辑器、`grep`和`sed`编辑图片。然后再转换回 *jpg* 。是的，我们能做到。然而，用 Photoshop 或 GIMP 来做通常更好，尽管它们是大型的集成程序。不是 UNIX 风格的。

我估计我现在就要加完分了。是的，够了。UNIX 中有一些我非常喜欢的想法。比如这个:“一个程序应该做一件事，而且要做好”。但不在 shell 的上下文中。我猜你现在已经意识到我不喜欢 shell 了。(再一次，我认为在上面提供的采访中，Rob Pike 在 shell 的上下文中采用了“程序应该做一件事，并且把它做好”的原则，因此拒绝了它)我在本质上谈论这个原则。例如，控制台邮件客户端不应该有内置的文本编辑器；它应该只是运行一些外部编辑器。或者是这样一个原则，即必须在图形用户界面之前编写程序的控制台内核。

现在，总的来说。曾经有 UNIX。这在当时是一个突破。它在许多方面都优于竞争对手。UNIX 有很多想法。和其他操作系统一样，UNIX 要求程序员在编写应用程序时遵循一定的原则。这些基本思想被命名为“UNIX 哲学”。前面已经提到的 Rob Pike 是 UNIX 哲学的制定者之一。他在题为[“UNIX 风格，或被认为有害的 cat-v”](http://harmful.cat-v.org/cat-v/)的演讲中做到了这一点。演示结束后，Rob Pike 和 Brian Kerninghan 根据的演示发表了一篇[文章。他们告诉我们，比方说，`cat`的目的是连接，没有别的。也许，Rob Pike 是发明“UNIX 哲学”的人。](http://harmful.cat-v.org/cat-v/unix_prog_design.pdf)[cat-v.org](http://cat-v.org/)网站就是以这次展示命名的。看看吧，这是一个非常有趣的网站。

但是，很多年后，派克又做了两次演讲，我认为他在演讲中放弃了他的哲学。明白了吗，粉丝们？你的偶像放弃了自己的哲学。你现在可以回家了。在第一个演示中[“系统软件研究无关紧要”](http://doc.cat-v.org/bell_labs/utah2000/) Pike 抱怨说没有人再编写新的操作系统了。即使他们这样做了，那也是另一个 Unix:“今天的新操作系统往往只是重新实现 UNIX 的方式。如果他们有一个新颖的架构——有些确实有——首先要构建的是 Unix 仿真层。当产生的操作系统都不可区分时，操作系统研究怎么可能有意义”

第二次演讲的题目是[“好、坏、丑:Unix 遗产”](http://doc.cat-v.org/bell_labs/good_bad_ugly/)。Pike 说平面文本不是多用途的；这很好，但并不总是有效:“让这个系统擅长它擅长的事情的同时，也让它不擅长它不擅长的事情。它的优点也是它的缺点。一个简单的例子:平面文本文件。惊人的表现力，巨大的便利，但在推动过去的性能或包装原型水平的严重问题。将著名的拼写管道与交互式拼写检查器进行比较”。然后:“自 20 世纪 70 年代以来，C 语言没有太大变化……而且——让我们面对现实吧——它很丑”。然后 Pike 承认了连接简单实用程序的管道的局限性，以及 regex 的局限性。

UNIX 在推出的时候是个天才。尤其是如果我们记得 UNIX 的作者有什么工具的话。他们没有现成的 UNIX 来开发 UNIX。他们没有 IDE。他们甚至一开始就用汇编语言开发。我猜他们仅有的东西是一个汇编程序和一个文本编辑器。

在某一点上，站在 UNIX 起源的人们开始编写一个新的操作系统:Plan 9。包括肯·汤普森、丹尼斯·里奇和罗布·派克。考虑到 UNIX 的众多错误。然而，没有人会把 9 号计划高高在上。派克在《系统软件研究无关紧要》中提到了计划 9，但仍然鼓励我们编写新的操作系统。

编程老手 James Hague(自 80 年代以来一直从事编程工作)写道:“我试图表达的意思是，如果你将 Unix 浪漫化，如果你将其视为完美之物，那么你就失去了想象更好替代方案的能力，并对思维中潜在的巨大转变视而不见”。[来源](http://prog21.dadgum.com/128.html)。阅读这篇文章和他提到的那篇:[解放你 20 世纪 70 年代的技术美学](http://prog21.dadgum.com/74.html)。事实上，如果你喜欢我的文章，你也会喜欢他的博客。

所以，我不想说 UNIX 是一个糟糕的系统。我只是提醒你注意这样一个事实，它有很多缺点，就像其他系统一样。我也不取消“UNIX 哲学”，只是想说它不是绝对的。我的帖子大多是指 UNIX 和 GNU/Linux 爱好者。挑衅的语气只是用来吸引你的注意力。