# 内联代码上的约翰·卡马克

> 原文：<http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

(这是约翰·卡马克在 2014 年写的一篇评论，关于他在 2007 年发给一个程序员邮件列表的一封邮件。)

在我写这篇文章的这些年里，我对纯函数式编程越来越乐观，甚至在 C/C++中也是如此:[(链接)](http://gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php)

内联解决的真正敌人是意外的依赖和状态突变，函数式编程更直接、更彻底地解决了这一问题。然而，如果您要进行大量的状态更改，让它们都以内联方式发生确实有好处；你应该时刻意识到你所做的事情有多么可怕。当它变得难以承受时，找出如何将块分解成纯函数(不要让它们退回到不纯状态！).

作为对这篇文章观点的进一步证实，几年后，当我在开发 Doom 3 BFG 版时，准确预测的延迟一帧的输入采样发生了，而且非常接近出货。那对我来说是一个冒冷汗的时刻:*在我喋喋不休地谈论延迟和响应之后，我几乎发布了一个完全没有必要的延迟帧*。

让事情变得更复杂的是，*总是做，然后抑制或忽略*策略，虽然对于高可靠性系统来说是一个非常好的想法，但在像移动这样的功耗和散热受限的环境中却不太合适。

2014 年 9 月 26 日约翰卡马克

* * *

来自:johnc@idsoftware.com 约翰·卡马克日期:2007 年 3 月 13 日星期二下午 4:17 主题:内联代码

这将是一封不同寻常的邮件——我想谈谈编码风格。我不会发布任何命令，但我希望每个人都认真考虑其中的一些问题。我不是在谈论像操作符周围的空格、支撑样式或类型或变量指针这样的小事(尽管我们可能应该解决这个问题)，而是谈论更大的代码组织。没有什么灵丹妙药，但是开发项目可以节省几个月的时间，而生产率只提高几个百分点。

这封邮件太长了，所以我打算以后再跟进一些其他的想法。我有很多一般的东西要讨论，但是有一个具体的战术方向我要提倡。

一年前，我参与了一场关于为航空航天应用程序编写极其可靠的软件的讨论，这几年我也参与了多次。通常，我会指责那些谈论使用线程和 RTOS 来做这些事情的人，而看起来像原始视频游戏的简单轮询循环要清晰有效得多。然而，这个特殊的讨论给我带来了一个新的难题:

> 的确，如果我没记错的话(自从我读到这个已经有一段时间了)…
> 
> 萨博鹰狮(一种轻型战斗机)的电传飞行软件更进了一步。它不允许子例程调用和向后分支，除了主循环底部的那个。控制流程仅向前进行。有时一段代码必须为后面的一段代码留下注释，告诉它要做什么，但这对于测试来说效果很好:所有数据都是静态分配的，监视这些变量可以清楚地了解软件正在做的几乎所有事情。该软件只做了最基本的工作，当然，他们对彻底的地面测试很认真。
> 
> 在该代码的“发布”版本中没有发现任何错误。
> 
> ```
>  Henry Spencer
>                                                   henry@spsystems.net 
> ```

现在，航空航天工业中的许多事情不应该被任何人效仿，而且经常是自我毁灭。你们中的大多数人可能都读过各种关于生产航天飞机软件的开发过程的流行文章，虽然有些人可能认为如果所有的软件开发人员都那么“小心”，世界会变得更好，但事实是，如果一切都以蜗牛的速度开发，我们将落后于我们现在的几十年，没有个人电脑，没有公共互联网。这个特别的轶事似乎有一些实用价值，所以我决定试一试。犰狳火箭的飞行控制代码只有几千行代码，所以我采用了主 tic 函数并开始内联所有的子例程。虽然我不能说我发现了一个可能导致崩溃的隐藏错误(字面上……)，但我确实发现了几个被多次设置的变量，几个看起来有点不可靠的控制流，最终的代码变得更小更干净。

在用那种风格的代码生活了一段时间后，我没有发现它的任何缺点，并且我已经开始在我的 Id 代码中应用通用的方法。在许多地方，可以选择用几种方式组织代码:

```
 ------- style A:

void MinorFunction1( void ) {
}

void MinorFunction2( void ) {
}

void MinorFunction3( void ) {
}

void MajorFunction( void ) {
        MinorFunction1();
        MinorFunction2();
        MinorFunction3();
}

--------- style B:

void MajorFunction( void ) {
        MinorFunction1();
        MinorFunction2();
        MinorFunction3();
}

void MinorFunction1( void ) {
}

void MinorFunction2( void ) {
}

void MinorFunction3( void ) {
}

---------- style C:

void MajorFunction( void ) {
        // MinorFunction1

        // MinorFunction2

        // MinorFunction3 
} 
```

历史上，我使用“风格 A”来考虑不在所有情况下进行原型设计，尽管有些人更喜欢“风格 B”。这两者之间的差别无关紧要。Michael Abrash 曾经用“C 风格”编写代码，我记得实际上为了提高可读性，他把代码转换成了“A 风格”。在这一点上，我认为“C 风格”有一些明确的优势，但是它们是面向开发过程的，而不是离散的、可量化的东西，并且它们违背了相当数量的被接受的传统智慧，所以我将尝试为它做一个清晰的案例。这里没有任何教条，但是考虑它在哪里是合适的和不合适的是值得的。

无论如何，无论如何，我都不会认为仅仅避免函数调用就能直接提高性能。

我偶尔尝试做的一个练习是在游戏中“步进一帧”，从一些主要点开始，如 common->Frame()，game->Frame()，或 renderer->EndFrame()，并步进每个函数，尝试遍历完整的代码覆盖。这通常在你到达画面末尾之前很久就会变得相当令人沮丧。了解所有实际执行的代码是非常重要的，在调试时很容易跳过非常大的代码块，即使它们对性能和稳定性有影响。

C++不是这个目标的朋友，有运算符重载、隐式构造函数等等。以灵活性的名义做的许多事情多少有些被误导了，并且是许多开发问题的根源。具有持续重现的实时 tic 结构的游戏也有一些目标和约束，这些目标和约束鼓励与内容创建应用程序或事务处理器有些不同的编程风格。

如果每帧要做一次什么事情，那么让它发生在帧循环的最外层是有价值的，而不是深埋在某些函数链中，因为某些原因可能会被跳过。例如，我们的 usercmd_t 生成代码隐藏在 asyncServer 之外，它确实应该在主公共循环中。与此相关的是硬件与软件设计的话题——进行操作，然后选择抑制或忽略部分或全部结果，通常比尝试有条件地执行操作更好。usercmd_t 生成与此相关(以及其他与绑定集上的游戏交互相关的混乱)，其中 usercmd_t 仅在“需要”时生成。

我们传统上测量性能和优化游戏的方式鼓励了许多条件操作——认识到某个特定操作不需要在操作状态的某个子集内完成，并跳过它。这给出了更好的演示计时数字，但是产生了大量的错误，因为跳过昂贵的操作通常也跳过了其他地方需要的一些其他状态更新。

我们肯定仍然有需要优化的性能密集型任务，但是在性能优势可以忽略不计的许多情况下，这种风格得到了理所当然的应用，但是我们仍然吃掉了 bug。既然我们已经下定决心要做一款 60hz 的游戏，那么最坏情况下的性能比一般情况下的性能更重要，所以高度多变的性能更应该被轻视。

当操作深入嵌套在各种子系统中时，很容易出现操作延迟的情况，并且事情会随着时间的推移而发展。这可以隐藏为几乎察觉不到的输入质量下降，也可以明显表现为模型在运动过程中跟踪某个附着点。如果在一个 2000 行的函数中所有的东西都用完了，那么很明显哪个部分先发生，并且你可以很确定后面的部分会在帧被渲染之前被执行。

除了知道正在执行的实际代码之外，内联函数还有一个好处，就是不能从其他地方调用函数。这听起来很荒谬，但确实有道理。随着代码库在多年的使用中不断增长，会有很多机会走捷径，只调用一个只做你认为需要做的工作的函数。可能有一个 FullUpdate()函数调用 PartialUpdateA()和 PartialUpdateB()，但在某些特定情况下，您可能会意识到(或认为)您只需要执行 PartialUpdateB()，并且您通过避免其他工作来提高效率。很多很多的 bug 都源于此。大多数错误都是由于执行状态与您所想的不完全一样。

严格的函数只读取它们的输入参数，只返回一个值，而不检查或修改任何永久状态，这样的函数不会出现这种类型的错误，正式谈论它们的良好能力使它们成为一个很好的象牙塔主题，但是我们真正的代码很少属于这一类。我不认为纯粹的函数式编程是一个实用的开发计划，因为它会导致非常晦涩的代码和惊人的低效率，但是如果一个函数只引用一两个全局状态，那么考虑将它作为变量传递可能是明智的。如果 C 有一个“functional”关键字来强制不使用全局引用，那就太好了。

常量参数和常量函数有助于避免与副作用相关的错误，但是函数仍然容易受到全局执行环境变化的影响。试图让更多的参数和函数保持不变是一个很好的练习，但往往会在某个时候因沮丧而放弃。这种挫败感通常是因为发现了各种各样的地方，这些地方可能会被修改，但并不明显——这些地方容易滋生 bug。

C++对象方法可以被认为几乎是功能性的，在返回时有一个隐式的覆盖赋值，但是对于包含大量变量的较大对象，你不太清楚方法修改了什么，同样，也不能保证函数不会运行并做一些可怕的全局操作，比如解析 decl。

最不可能引起问题的函数是一个不存在的函数，这就是内联它的好处。如果一个函数只在一个地方被调用，那么决定是相当简单的。

几乎在所有情况下，代码复制都比在不同环境下调用函数所产生的二阶问题更糟糕，所以我很少提倡复制代码来避免函数，但是在很多情况下，您仍然可以通过标记要在适当控制的时间执行的操作来避免函数。例如，让玩家检查一次健康代码< = 0 &&！与在 20 个不同的地方调用 KillPlayer()相比，killed 几乎肯定会产生更少的错误。

关于代码复制，我跟踪了一段时间我修复的所有 bug(在我认为一切正常后出现的问题),我对复制-粘贴-修改操作经常导致不易察觉的 bug 感到非常惊讶。对于三个或四个对象的小向量运算，我通常会忽略并修改几个字符，如下所示:

```
v[0] = HF_MANTISSA(*(halfFloat_t *)((byte *)data + i*bytePitch+j*8+0));
v[1] = HF_MANTISSA(*(halfFloat_t *)((byte *)data + i*bytePitch+j*8+1));
v[2] = HF_MANTISSA(*(halfFloat_t *)((byte *)data + i*bytePitch+j*8+2));
v[3] = HF_MANTISSA(*(halfFloat_t *)((byte *)data + i*bytePitch+j*8+3)); 
```

我现在强烈鼓励对任何事情都使用显式循环，并希望编译器能正确地展开它。我的很多错误都与此有关，我现在正在重新考虑二维的情况，我通常使用离散的 X，_Y 或者 _WIDTH，_HEIGHT 变量。我发现这比两个元素的数组更容易阅读，但很难用我的数据来证明它让我出错的频率。一些实际问题—

在主函数中使用大的注释块来分隔次函数对于快速浏览来说是一个好主意，并且通常将它包含在一个空的有支撑的部分中，以限定局部变量的范围并允许编辑器折叠该部分是有用的。我知道有一些关于不要让函数超过一两页的经验法则，但是我现在特别不同意这一点——如果许多操作应该以一种顺序的方式发生，它们的代码应该按顺序执行。

将代码页包含在条件语句或循环语句中确实有可读性和感知方面的缺点，因此将代码留在单独的函数中可能仍然是合理的，但在某些情况下，仍然可以将代码移动到另一个其执行不是条件性的地方，或者只是一直执行它，并用一个非常小的条件块以某种方式抑制结果。执行-禁止风格通常需要更多的绝对时间，但它减少了帧时间的可变性，并消除了一类错误。

内联代码很快就会与模块化和 OOP 保护发生冲突，因此必须做出良好的判断。模块化的全部意义在于隐藏细节，而我提倡增加对细节的意识。需要权衡一些实际因素，如增加源文件的多次签出，以及在主预编译头文件中包含更多的本地数据，从而强制进行更多的完全重建。目前，我倾向于使用重量级对象作为合并代码的合理断点，并试图减少中等大小辅助对象的使用，同时使任何非常轻量级的对象尽可能地纯粹功能化，如果它们必须存在的话。

总而言之:

如果一个函数只在一个地方被调用，考虑内联它。

如果从多个地方调用一个函数，看看是否有可能把工作安排在一个地方完成，也许用标志，并内联它。

如果一个函数有多个版本，考虑用更多的参数(可能是默认参数)创建一个函数。

如果工作接近纯粹的功能性，很少涉及全局状态，那么尽量使它完全功能化。

当函数确实必须在多个地方使用时，尝试对参数和函数都使用 const。

最小化控制流的复杂性和“ifs 下的区域”，支持一致的执行路径和时间，而不是“最优地”避免不必要的工作。

讨论？

约翰·卡马克