# UI 工程的元素——反应过度

> 原文：<https://overreacted.io/the-elements-of-ui-engineering/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

在我的[上一篇文章](/things-i-dont-know-as-of-2018/)中，我谈到了承认我们的知识差距。你可能会得出结论，我建议满足于平庸。我没有！这是一个广阔的领域。

我坚信你可以“从任何地方开始”，不需要按照任何特定的顺序学习技术。但是我也非常重视获得专业知识。就我个人而言，我最感兴趣的是创建用户界面。

我一直在思考，我*知道什么，T2*认为什么是有价值的。当然，我熟悉一些技术(例如 JavaScript 和 React)。但更重要的经验教训却难以捉摸。我从未试图用语言来表达。这是我第一次尝试对它们进行分类和描述。**

* * *

有很多关于技术和图书馆的“学习路线图”。2019 年哪个图书馆要流行？2020 年呢？应该学 Vue 还是反应？棱角分明？Redux 或者 Rx 呢？需要学阿波罗吗？REST 还是 GraphQL？很容易迷路。作者错了怎么办？

我在学习上最大的突破不是关于某项特定的技术。更确切地说，当我努力解决一个特定的 UI 问题时，我学到了最多。有时候，我后来会发现对我有帮助的库或模式。在其他情况下，我会提出自己的解决方案(好的和坏的都有)。

正是这种理解*问题*，尝试*解决方案*，以及应用不同的*策略*的结合，带来了我人生中最有收获的学习经历。这篇文章只关注这些问题。

* * *

如果你从事用户界面的工作，你可能已经处理了至少一些这样的挑战——或者直接或者使用一个库。无论是哪种情况，我都鼓励你创建一个没有库的小应用程序，并尝试复制和解决这些问题。没有一个正确的解决方案。学习来自于探索问题空间和尝试不同的可能权衡。

* * *

*   **一致性。**你点击“喜欢”按钮，文本更新:“你和另外 3 个朋友喜欢这篇文章。”你再点一下，文字就会弹回来。听起来很容易。但也许像这样的标签存在于屏幕上的几个地方。也许有一些其他的视觉指示(如按钮背景)需要改变。之前从服务器获取的“喜欢者”列表现在应该包括你的名字了。如果你导航到另一个屏幕，然后返回，这篇文章不应该“忘记”它是喜欢的。即使是本地一致性*单独*创造了一系列的挑战。但是其他用户也可能修改我们显示的数据(例如，通过喜欢我们正在查看的帖子)。我们如何在屏幕的不同部分保持相同的数据同步？我们如何以及何时使本地数据与服务器一致，反之亦然？
*   **响应能力。**人们只能在有限的时间内忍受缺乏对他们行为的视觉反馈。对于像手势和滚动这样的*连续*动作，这个限制很低。(即使跳过一个 16ms 的帧也会觉得“滑稽”。)对于像点击这样的*离散*动作，有研究称用户认为任何<100 毫秒的延迟都一样快。如果一个动作需要更长的时间，我们需要显示一个视觉指示器。但是有一些反直觉的挑战。导致页面布局“跳转”或经历几个加载“阶段”的指示器会使动作*比原来感觉更长*。类似地，以丢失动画帧为代价在 20 毫秒内处理交互会*感觉比在 30 毫秒内处理并且没有丢失帧更慢*。大脑不是基准。我们如何让我们的应用程序响应不同类型的输入？
*   **潜伏期。**计算和网络接入都需要时间。*有时*如果不影响目标设备的响应能力，我们可以忽略计算成本(确保在低端设备上测试你的应用)。但是处理网络延迟是不可避免的——可能需要几秒钟！我们的应用程序不能停滞不前，等待数据或代码加载。这意味着任何依赖于新数据、代码或资产的动作都可能是异步的，并且需要处理“加载”的情况。但这几乎会发生在每一个屏幕上。我们如何优雅地处理延迟，而不显示“级联”的旋转器或空“洞”？我们如何避免“跳动”的布局？我们如何改变异步依赖关系而不用每次都“重新布线”我们的代码？
*   **航海。**我们希望用户界面在交互时保持“稳定”。东西不应该从我们眼皮底下消失。导航，无论是在应用程序内启动(如点击链接)还是由于外部事件(如点击“返回”按钮)，也应尊重这一原则。例如，在个人资料屏幕上的`/profile/likes`和`/profile/follows`选项卡之间切换不应该清除选项卡视图之外的搜索输入。甚至导航到*另一个*屏幕就像走进一个房间。人们希望以后回去时能找到他们离开时的东西(也许还有一些新东西)。如果你在一个提要中，点击一个概要文件，然后返回，失去你在提要中的位置是令人沮丧的——或者等待它再次加载。我们如何设计我们的应用程序来处理任意导航而不丢失重要的上下文？
*   **陈腐。**我们可以通过引入本地缓存来实现“后退”按钮导航。在缓存中，我们可以“记住”一些数据以便快速访问，即使我们理论上可以重新提取这些数据。但是缓存也带来了自己的问题。缓存可能会过时。如果我改变一个头像，它也应该在缓存中更新。如果我发布了一个新的帖子，它需要立即出现在缓存中，否则缓存需要失效。这可能变得困难且容易出错。发帖失败怎么办？缓存在内存中停留多长时间？当我们重新获取提要时，是将新获取的提要与缓存的提要“缝合”在一起，还是丢弃缓存？分页或排序在缓存中是如何表示的？
*   **熵。**热力学第二定律说的是“随着时间的推移，事情会变得一团糟”(嗯，不完全是)。这也适用于用户界面。我们无法预测确切的用户交互及其顺序。在任何时候，我们的应用程序都可能处于令人难以置信的多种状态中的一种。我们尽最大努力使结果可预测，并受我们的设计限制。我们不想看着一个 bug 截图，想知道“那个是怎么发生的*”。对于 *N 个*可能的状态，它们之间有*N×(N–1)*个可能的跃迁。例如，如果按钮可以处于 5 种不同状态(正常、活动、悬停、危险、禁用)中的一种，则更新按钮的代码必须对 5×4=20 种可能的转换保持正确，或者禁止其中一些转换。我们如何驯服可能状态的组合爆炸，并使视觉输出可预测？*
*   **优先级。**有些事情比其他事情更重要。一个对话框可能需要出现在产生它的按钮的物理“上方”,并“突破”其容器的剪辑边界。新调度的任务(例如，响应点击)可能比已经开始的长时间运行的任务(例如，在屏幕文件夹下呈现下一个帖子)更重要。随着我们的应用程序的增长，由不同的人和团队编写的部分代码会争夺有限的资源，如处理器、网络、屏幕空间和捆绑包大小预算。有时你可以根据共享的“重要性”等级对竞争者进行排序，比如 CSS `z-index`属性。[但很少有好下场。](https://devblogs.microsoft.com/oldnewthing/20050607-00/?p=35413)每个开发人员都偏向于认为*他们的*代码很重要。如果一切都很重要，那么什么都不重要！我们如何让独立的小部件*合作*而不是争夺资源？
*   **可达性。**无法访问网站是*而不是*一个小众问题。例如，在英国，五分之一的人患有残疾。[(这是一张不错的信息图。)](https://www.abrightclearweb.com/web-accessibility-in-the-uk/)我个人也感受到了这一点。虽然我只有 26 岁，但我很难阅读那些字体薄、对比度低的网站。我尽量少用触控板，我害怕有一天我不得不通过键盘浏览实现不佳的网站。我们需要让我们的应用程序对有困难的人来说不可怕——好消息是有很多唾手可得的果实。它从教育和工具开始。但是我们也需要让产品开发人员更容易做正确的事情。我们能做些什么来使可访问性成为默认的而不是事后的想法呢？
*   **国际化。**我们的应用程序需要在全球范围内运行。不仅人们说不同的语言，而且我们还需要用产品工程师最少的努力来支持从右到左的布局。我们如何在不牺牲延迟和响应的情况下支持不同的语言？
*   **交货。**我们需要将我们的应用程序代码下载到用户的计算机上。我们使用什么传输和格式？这听起来可能很简单，但是这里有很多权衡。例如，原生应用程序倾向于以巨大的应用程序大小为代价提前加载所有代码。Web 应用程序的初始有效负载往往较小，代价是使用过程中的延迟更长。我们如何选择在哪个点引入延迟？我们如何基于使用模式优化我们的交付？最佳解决方案需要什么样的数据？
*   **韧性。如果你是昆虫学家，你可能会喜欢虫子，但你可能不喜欢在你的程序中看到它们。然而，你的一些错误将不可避免地进入生产环境。接下来会发生什么？一些错误会导致错误但定义明确的行为。例如，在某些情况下，您的代码可能会显示不正确的视觉输出。但是如果渲染代码*崩溃*怎么办？那么我们就不能有意义地继续下去，因为视觉输出会不一致。呈现单个帖子的崩溃不应该“关闭”整个提要或使其进入半崩溃状态，从而导致进一步的崩溃。我们如何编写代码来隔离渲染和获取失败，并保持应用程序的其余部分运行？容错对于用户界面意味着什么？**
*   **抽象。**在一个微小的 app 中，我们可以硬编码很多特例来说明上述问题。但是应用程序有增长的趋势。我们希望能够[重用、派生和连接](/optimized-for-change/)我们代码的各个部分，并一起工作。我们希望在不同人熟悉的部分之间定义清晰的界限，并避免使经常变化的逻辑过于僵化。我们如何创建隐藏特定 UI 部分实现细节的抽象？随着应用程序的增长，我们如何避免重复出现我们刚刚解决的问题？

* * *

当然，还有很多问题我没有提到。这份清单绝非详尽无遗！例如，我还没有谈到设计师和工程协作，或者调试和测试。也许下次吧。

阅读这些问题时，很容易想到一个特定的视图库或数据获取库作为解决方案。但是我鼓励你假装这些库不存在，从那个角度再看一遍。你会如何解决这些问题？给他们一个小小的应用程序试试吧！(我很想看看你在 GitHub 上的实验——欢迎在推特上回复我。)

这些问题的有趣之处在于，它们中的大多数在任何规模下都会出现。你既可以在小工具中看到它们，比如提前输入或工具提示，也可以在大型应用程序中看到它们，比如 Twitter 和脸书。

从你喜欢使用的应用程序中想出一个不平凡的 UI 元素，并仔细检查这个问题列表。你能描述一下它的开发者选择的一些权衡吗？尝试从头开始重新创建一个类似的行为！

通过在不使用库的情况下在小应用中试验这些问题，我学到了很多关于 UI 工程的知识。我同样推荐给任何想对 UI 工程中的权衡有更深理解的人。