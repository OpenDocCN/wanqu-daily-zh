# 关于年轻血液的分布式系统的注释——类似的东西

> 原文：<https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

我一直在思考分布式系统工程师在工作中学到的经验。我们的很多指导都是通过生产流程中的错误所留下的伤疤。当然，这些伤疤是有用的提醒，但最好有更多的工程师能完整地清点他们的手指。

作为自学的一部分，新的系统工程师将会发现分布式计算的谬误和 T2 上限定理。但是这些都是抽象的东西，没有直接的、可操作的建议，没有经验的工程师需要开始行动<sup id="fnref:1">。令人惊讶的是，当新工程师开始工作时，他们得到的背景知识是如此之少。</sup>

下面是我作为一名分布式系统工程师学到的一些经验，值得告诉一名新工程师。有些微妙，有些令人惊讶，但都没有争议。这个列表是为新的分布式系统工程师准备的，用来指导他们对所从事领域的思考。不全面，但这是个好的开始。

这份清单最糟糕的特点是，它专注于技术问题，很少讨论工程师可能遇到的社会问题。由于分布式系统需要更多的机器和更多的资金，他们的工程师倾向于与更多的团队和更大的组织合作。社交活动通常是任何软件开发人员工作中最困难的部分，也许，对于分布式系统开发来说尤其如此。

我们的背景、教育和经验使我们偏向于技术解决方案，即使社会解决方案会更有效、更令人满意。让我们试着纠正这一点。人没有计算机那么挑剔，即使他们的界面没有那么标准化。

好了，我们开始吧。

[#](#fail) **分布式系统之所以不同，是因为它们经常失败。**当被问及分布式系统与软件工程其他领域的区别时，这位新工程师经常提到延迟，认为这是分布式计算难以实现的原因。

但是他们错了。使分布式系统工程与众不同的是失败的可能性，更糟糕的是，部分失败的可能性。如果一个格式良好的互斥锁解锁失败并出现错误，我们可以假设该进程不稳定并使其崩溃。但是分布式互斥锁的解锁失败必须被构建到锁协议中。

没有从事过分布式计算的系统工程师会想出这样的主意，“好吧，它只是将写操作发送到两台机器”或者“它只是不断地重试写操作，直到成功为止”。这些工程师还没有完全接受(尽管他们通常理智地认识到)网络化系统比只存在于单个机器上的系统故障更多，并且故障往往是部分的而不是全部的。一次写入可能会成功，而另一次会失败，那么现在我们如何获得一致的数据视图呢？这些局部失败更难解释。

交换机停机，垃圾收集暂停使领导者“消失”，套接字写入似乎成功但实际上在另一台机器上失败，一台机器上的慢速磁盘驱动器导致整个集群中的通信协议爬行，等等。从本地存储器读取比跨几个开关读取更稳定。

为失败设计。 [#](#fail)

编写健壮的分布式系统比编写健壮的单机系统花费更多。创建一个健壮的分布式解决方案比单机解决方案需要更多的资金，因为有些故障只会发生在多台机器上。虚拟机和云技术使得分布式系统工程更便宜，但不如在您已经拥有的计算机上设计、实现和测试便宜。并且存在难以在单台机器上复制的故障条件。无论是因为它们只出现在比共享机器所能容纳的大得多的数据集上，还是在数据中心的网络条件下，分布式系统往往需要实际的而不是模拟的分布来清除它们的错误。当然，模拟是非常有用的。 [#](#robustdist)

健壮的开源分布式系统远不如健壮的单机系统常见。长时间运行许多机器的成本是开源社区的一个负担。业余爱好者和爱好者是开源软件的引擎，他们没有财力去探索或修复分布式系统将会遇到的许多问题。业余爱好者在空闲时间和他们已经拥有的机器上写开源代码取乐。很难找到愿意加速、维护和购买一堆机器的开源开发者。

为公司实体工作的工程师已经承担了部分这种闲置工作。但是，他们组织的优先级可能与您组织的优先级不一致。

虽然开源社区中的一些人已经意识到了这个问题，但是这个问题还没有解决。这很难。 [#](#robustoss)

[#](#coord) **协调很辛苦。**尽可能避免协调机器。这通常被称为“水平可伸缩性”。水平可伸缩性的真正诀窍是独立性——能够将数据传输到机器上，从而将机器之间的通信和共识保持在最低限度。每当两台机器必须就某件事达成一致时，服务就变得更难实现。信息的传播速度是有上限的，网络交流比你想象的更加古怪，你对共识的理解可能是错误的。了解一下[两位将军](http://en.wikipedia.org/wiki/Two_Generals%27_Problem)和[拜占庭将军](http://en.wikipedia.org/wiki/Byzantine_Generals%27_Problem)的问题在这里很有用。(哦，Paxos 真的很难实现。那不是脾气暴躁的老工程师自以为比你懂的多。) [#](#coord)

[#](#memory) **如果你能把你的问题记住，它可能是微不足道的。**对于分布式系统工程师来说，一台机器本地的问题很容易解决。当数据离开几个开关而不是几个指针离开时，想知道如何快速处理数据就更难了。在分布式系统中，自计算机科学开始以来记录在案的陈旧的效率技巧不再适用。大量文献和实现可用于在单个机器上运行的算法，因为大部分计算是在单一的、不协调的机器上完成的。分布式系统的数量要少得多。 [#](#memory)

[#](#slow) **“太慢了”是你调试过的最难的问题。**“很慢”可能意味着执行用户请求所涉及的一个或多个系统很慢。这可能意味着跨许多机器的转换管道中的一个或多个部分很慢。“它很慢”很难，部分原因是问题陈述没有提供很多关于缺陷位置的线索。部分故障，那些在你通常查找的图表中没有显示出来的故障，潜伏在一个黑暗的角落里。并且，在退化变得非常明显之前，您不会收到同样多的资源(时间、金钱和工具)来解决它。 [Dapper](http://research.google.com/pubs/pub36356.html) 和 [Zipkin](http://engineering.twitter.com/2012/06/distributed-systems-tracing-with-zipkin.html) 的诞生是有原因的。 [#](#slow)

[#](#backpressure) **在整个系统中实施背压。**背压是从服务系统到请求系统的故障信号，以及请求系统如何处理这些故障以防止自身和服务系统过载。背压设计意味着在过载和系统故障时限制资源使用。这是创建健壮的分布式系统的基本构件之一。

背压的实现通常包括在资源变得有限或发生故障时，将新消息丢弃到地板上，或者将错误发送回用户(并在这两种情况下递增一个度量)。到其他系统的连接和请求的超时和指数级回退也是必不可少的。

如果没有适当的背压机制，很可能会出现级联故障或意外的消息丢失。当一个系统无法处理另一个系统的故障时，它往往会将故障发送给依赖它的另一个系统。 [#](#backpressure)

[#](#partial) **想办法局部可用。**部分可用性是指即使系统的某些部分出现故障，也能够返回一些结果。

在这里搜索是一个理想的探索案例。搜索系统在搜索结果的好坏和让用户等待的时间之间进行权衡。典型的搜索系统对搜索其文档的时间设置了一个时间限制，如果在搜索完所有文档之前该时间限制到期，它将返回它收集到的任何结果。这使得搜索在面临间歇性的速度变慢和错误时更容易扩展，因为这些失败被视为无法搜索所有文档。该系统允许向用户返回部分结果，并且增加了其弹性。

并考虑 web 应用程序中的私有消息传递功能。在某个时候，无论您做什么，足够的存储私人消息的机器都会在您的用户注意到的同时停机。那么在这个系统中我们想要什么样的部分失败呢？

这需要一些思考。与所有用户的部分信息丢失相比，人们通常更容易接受自己(或许还有其他一些用户)的私人信息被关闭。如果服务过载或其中一台机器停机，只让一小部分用户无法使用总比让大部分用户丢失数据要好。此外，除此之外，我们可能不希望一个不相关的功能，如公共图像上传，仅仅因为私人信息有问题而受到影响。我们愿意做多少工作来保持这些故障域的分离？

能够认识到部分可用性中的这种权衡是一件好事。 [#](#partial)

[#](#metrics) **度量是完成工作的唯一方法。**暴露指标(如延迟百分比、增加某些操作的计数器、变化率)是跨越您认为您的系统在生产中所做的和它实际正在做的之间差距的唯一方法。了解系统在第 20 天的行为与第 15 天的行为有何不同，是成功的工程和失败的萨满教的区别。当然，度量对于理解问题和行为是必要的，但是不足以知道下一步做什么。

转向伐木业。拥有日志文件是好事，但它们往往是虚假的。例如，很常见的情况是，记录几个错误类会占用日志文件中很大一部分空间，但实际上，这种情况只发生在很少的请求中。因为记录成功在大多数情况下都是多余的(并且在大多数情况下会把磁盘烧坏),并且因为工程师经常会错误地判断哪些类型的错误类是有用的，所以日志文件会被各种各样的奇怪的比特和鲍勃填满。更喜欢日志记录，就好像没有看过代码的人会阅读日志一样。

我见过很多由另一个工程师(或我自己)延长的停机时间，他们过分强调我们在日志中看到的一些奇怪的东西，而没有首先对照指标进行检查。我还见过另一个工程师(或者我自己)夏洛克-霍尔姆斯从几行日志中找出一整套失败的行为。但是请注意:a)我们记得那些成功，因为它们非常罕见，b)除非有度量或实验支持这个故事，否则你不是夏洛克。 [#](#metrics)

[#](#percentiles) **用百分位数，不用平均数。**百分位数(第 50、99、99.9、99.99)比大多数分布式系统中的平均值更准确，信息更丰富。使用平均值假设被评估的指标遵循钟形曲线，但实际上，这描述了工程师关心的很少指标。“平均延迟”是一个经常被报道的指标，但是我从来没有见过延迟遵循钟形曲线的分布式系统。如果指标不符合钟形曲线，平均值就没有意义，会导致不正确的决策和理解。通过百分位数来避免陷阱。默认为百分位数，你会更好地理解用户是如何看待你的系统的。 [#](#percentiles)

[#](#capacity) **学会估算自己的容量。因此，你会知道一天有多少秒。知道你需要多少台机器来执行一项任务，这是一个持久的系统和一个工作 3 个月就需要更换的系统之间的区别。或者，更糟的是，在你完成生产之前需要更换。**

考虑推特。一台普通机器的内存中可以容纳多少个 tweet ids？嗯，2012 年底，一台典型的机器有 24 GB 的内存，你需要 4-5 GB 的操作系统开销，至少需要另外两个来处理请求，一个 tweet id 是 8 个字节。这是你会发现自己在做的那种信封背面的计算。Jeff Dean 的[数字每个人都应该知道](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)幻灯片是一个很好的期望设定器。 [#](#capacity)

[#](#flags) **功能标志是基础设施的部署方式。**“功能标志”是产品工程师在系统中推出新功能的常用方式。功能标志通常与前端 A/B 测试相关联，用于仅向部分用户群展示新的设计或功能。但它们也是替换基础设施的有力方式。

太多的项目失败了，因为他们进行了“大切换”或一系列“大切换”,然后被发现得太晚的 bug 强迫回滚。通过使用特性标志，您将获得对项目的信心，并减少失败的代价。

假设您要从一个数据库转向一个隐藏新存储解决方案细节的服务。使用一个特性标志，您可以在写入旧数据库的同时慢慢增加对新服务的写入，以确保其写入路径正确且足够快。在写入路径达到 100%并且回填到服务的数据存储完成后，您可以使用单独的功能标志开始从服务中读取数据，而不使用用户响应中的数据来检查性能问题。另一个特征标志可用于在从旧系统和新系统读取数据时执行比较检查。最后一个标志可用于缓慢提升新系统的“真实”读数。

通过将部署分解为多个步骤，并通过特性标志为自己提供快速和部分的反应，您可以更容易地发现 bug 和性能问题，因为它们是在加速阶段而不是在“大爆炸”发布时出现的。如果出现问题，您可以立即将功能标志设置重新设置为较低的值(可能为零)。通过调整速率，您可以在不同的流量下进行调试和实验，因为您知道遇到的任何问题都不完全是灾难。有了特性标志，您还可以选择其他迁移策略，比如在每个用户的基础上转移请求，从而更好地了解新系统。当您的新服务仍处于原型化阶段时，您可以使用较低设置的标志来让您的新系统消耗更少的资源。

现在，对于受过传统培训的开发人员或受过良好培训的新工程师来说，特性标志听起来像是一堆糟糕的条件。使用特性标志意味着接受基础设施和数据的多个版本是一种规范，而不是一种罕见。这是一个深刻的教训。在分布式问题面前，适用于单机系统的方法有时会动摇。

特性标志最好理解为一种折衷，用局部复杂性(在代码中，在一个系统中)换取全局简单性和弹性。 [#](#flags)

[#](#idspace) **明智地选择 id 空格。**您为系统选择的 id 空间将塑造您的系统。

获取数据所需的 id 越多，对数据进行分区的选择就越多。获取一段数据所需的 id 越少，就越容易消耗系统的输出。

考虑 Twitter API 的版本 1。所有获取、创建和删除 tweet 的操作都是针对每个 tweet 的一个数字 id 完成的。tweet id 是一个简单的 64 位数字，不与任何其他数据相关联。随着推文数量的增加，很明显，如果同一用户的所有推文都存储在同一台机器上，则创建用户推文时间线和其他用户订阅的时间线可以有效地构建。

但是公共 API 要求每条 tweet 只能通过 tweet id 寻址。要按用户划分推文，必须构建一个查找服务。它知道哪个用户拥有哪个 tweet id。如果有必要的话，这是可行的，但代价也不小。

另一种 API 可能要求在任何 tweet 查询中使用用户 id，并且最初只是将 tweet id 用于存储，直到用户分区的存储联机。另一种方法是在 tweet id 中包含用户 id，代价是 tweet id 不再是 k-sortable 和数字。

注意你在 ids 中编码了什么样的信息，显式的还是隐式的。客户端可能会使用您的 id 结构来消除私人数据的匿名性，以意想不到的方式爬取您的系统(自动递增的 id 是一个典型的痛点)，或者执行其他攻击的[主机](https://www.owasp.org/index.php/Top_10_2010-A4-Insecure_Direct_Object_References)。 [#](#idspace)

[#](#dataloc) **利用数据局部性。**数据的处理和缓存越靠近持久存储，处理效率越高，就越容易保持缓存的一致性和快速性。网络比指针解引用和`fread(3)`有更多的故障和更多的延迟。

当然，数据局部性意味着在空间上接近，但也意味着在时间上接近。如果多个用户几乎同时发出相同的昂贵请求，也许他们的请求可以合并成一个。如果对同类数据的多个请求实例彼此靠近，它们可以合并成一个更大的请求。这样做通常可以减少窃听到的通信，并简化故障管理。 [#](#dataloc)

[#](#cached) **将缓存数据写回持久存储不好。**这种情况发生在比你想象的更多的系统中。尤其是那些最初由缺乏分布式系统经验的人设计的。您将继承的许多系统都有这个缺陷。如果实现者谈论“俄罗斯娃娃缓存”，您有很大的机会发现非常明显的错误。这个词条本来可以不在列表里，但是我心里对它有一种特别的恨。该漏洞的一个常见表现是用户信息(如昵称、电子邮件和散列密码)神秘地恢复到以前的值。 [#](#cached)

计算机能做的比你想象的要多。在当今的领域中，缺乏丰富经验的从业者对机器的能力有很多错误的认识。

在 2012 年底，一个轻量级 web 服务器有 6 个或更多的处理器、24 GB 的内存和超过您可以使用的磁盘空间。一个相对复杂的 [CRUD](http://en.wikipedia.org/wiki/Create,_read,_update_and_delete) 应用程序在一台机器上的现代语言运行时，每秒钟可以在几百毫秒内处理数千个请求。这是一个很深的下限。就操作能力而言，每台机器每秒数百个请求在大多数情况下并不是什么值得夸耀的事情。

更好的性能并不难获得，尤其是如果您愿意分析您的应用程序并根据您的测量引入效率。 [#](#domore)

[#](#cap) **用 CAP 定理来批判系统。**上限定理不是你可以用来构建系统的东西。这不是一个定理，你可以把它作为第一原理，并从中推导出一个工作系统。它的范围太过宽泛，可能的解决方案空间太过广阔。

然而，它非常适合于评论分布式系统设计，并理解需要做出什么样的权衡。采用一个系统设计，并通过 CAP 对其子系统施加的约束进行迭代，最终会给你留下一个更好的设计。作为家庭作业，将 CAP 定理的约束应用到俄罗斯娃娃缓存的真实世界实现中。

最后一个注意:在 C，A，P 中，你[不能选择 CA](http://codahale.com/you-cant-sacrifice-partition-tolerance/) 。 [#](#cap)

[#](#services) **提取服务。**“服务”在这里指的是“一个包含比存储系统更高级逻辑的分布式系统，通常具有请求-响应风格的 API”。如果代码存在于一个单独的服务中，而不是在您的系统中，那么留意代码的变化会更容易。

提取的服务提供了通常与创建库相关联的封装的好处。然而，提取服务比创建库有所改进，因为与在客户端系统中升级库相比，提取服务可以更快、更容易地部署更改。(当然，如果提取的服务很难部署，客户机系统会变得更容易部署。)这种容易是由于在较小的、提取的服务中较少的代码和操作依赖性，以及它创建的严格边界使得更难“走捷径”，而这是库所允许的。这些快捷方式几乎总是使内部或客户机系统迁移到新版本变得更加困难。

当有多个客户端系统时，使用服务的协调成本也比共享库低得多。升级一个库，即使不需要改变 API，也需要协调每个客户机系统的部署。如果部署没有按顺序执行，当数据可能损坏时，这变得更加困难(并且更难预测它会发生)。如果客户机系统有不同的维护者，升级一个库也比部署一个服务有更高的社会协调成本。让其他人意识到并愿意升级非常困难，因为他们的优先事项可能与你的不一致。

规范的服务用例是隐藏将要发生变化的存储层。提取的服务有一个更方便的 API，与它所面对的存储层相比，减少了外围应用。通过提取服务，客户端系统不必知道向新存储系统或格式的缓慢迁移的复杂性，只需评估新服务是否存在新存储布局肯定会发现的缺陷。

这样做时，有大量的操作和社会问题需要考虑。我不能在这里公正地对待他们。还得再写一篇文章。 [#](#services)

非常感谢我的评论家们[比尔·德拉](https://twitter.com/dehora)、[科达·黑尔](https://twitter.com/coda)、[JD·马托伦](https://twitter.com/jdmaturen)、[米凯拉·麦克唐纳](https://twitter.com/nora)和[泰德·尼曼](https://twitter.com/tnm)。你的洞察力和关心是无价的。

**更新** (2016-08-15):我已经为每个部分添加了永久链接，并清理了关于协调、数据局部性、特征标志和背压的部分中的一些文本。