# 首先修复错误处理| Ned 批处理程序

> 原文：<http://nedbatchelder.com/text/fix-err-hand.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

创建于 2003 年 2 月 6 日，最后更新于 2007 年 1 月 24 日

通常，当意外错误第一次出现时，我会发现错误处理方式存在问题。这并不奇怪:错误处理代码通常是系统中最少使用的部分，所以其中存在错误是很自然的。重要的是首先修复错误处理问题，然后修复原始错误。

有时，最初的错误条件会引发一系列问题，然后随着错误处理代码层对错误条件的错误处理而加剧。解决所有问题，向后。

# 错误处理代码

在任何程序中，都会有专门设计的代码来处理异常情况，无论是错误、异常、[失败断言](//nedbatchelder.com/text/assert.html)、边缘条件、异常输入等等。这个“异常代码”的重要之处在于，它不经常被执行，这使得它成为了 bug 的一个很好的藏身之处。通常很难测试:如何确保磁盘文件中有坏块来测试您的错误处理逻辑？

对于一个大程序中有多少部分用于错误处理，人们的估计各不相同，尤其是考虑到不同的错误处理技术(例如，状态代码与异常)时。我认为在一个开发良好的大型应用程序中，5%到 10%是一个合理的估计。这是一段没有定期测试的好代码。

# 首先修复错误处理

当您的应用程序出现问题时，总是首先检查错误是否得到了适当的处理。如果不是，总是先修复处理代码。

> 总是在修复错误之前修复错误处理。

这条规则就像航空公司的规定，先给自己戴上氧气面罩，再给孩子戴上。坚持这种工作顺序有几个原因:

1.  有了原始错误，您就有了一个针对错误处理代码中的错误的完美测试用例。一旦您修复了原来的问题，您将如何测试错误处理？记住，一开始就有 bug 的原因之一是很难测试它。
2.  一旦最初的问题被修复，修复错误处理代码的紧迫性就消失了。你可以说你会得到它，但急什么？你会像那个屋顶漏水的人一样。下雨的时候，他修不了，因为外面下雨了，不下雨的时候，就不漏水了！

# 级联错误

在复杂的系统中，我们可能在这里谈论的是一整个隐藏的缺陷链，所有的缺陷都是隐藏的，直到一个问题触发了它们，它们才一次显示给你。当这种情况发生时，分析链条，了解每一步哪里出错了，然后反向解决问题。

> 向后修复一连串的错误，从最后观察到的问题回到最初的原因。

这是我最初规则的一般陈述。在每一个因果对中，不要固定原因，直到结果正确。有了一个链，你能首先修复的唯一效果是最后一个，因为每隔一个都是另一个效果的原因。

# 真实的例子

这是前几天发生的一个真实的例子。为了简化(也为了保护无辜)，细节已经被改变了。以下是日志文件:

> ```
> 1 [trace] Getting user id...
> 2 [crit!] Assertion failed: strlen(pUser->GetUserId()) > 0
> 3 [error] No handler for failed assertion
> 4 [trace] Prefs lookup: cache for  is empty
> 5 [trace] Querying full user info...
> 6 [trace] User  using  skin
> 
> ```

第一个错误出现在第 2 行，这里发生了一个关键错误:一个[失败的断言](//nedbatchelder.com/text/assert.html)。程序员认为用户 id 不可能是空字符串。他错了。

> 如果发生了，一定是有可能的。

在这个错误所基于的真实错误中，原因是另一个服务器不可用，但这无关紧要:显然，不知何故，用户 id 是一个空字符串，所以断言是处理它的错误方式。Bug 1。

在第 3 行，我们看到断言基础设施没有正确初始化，并且没有失败断言的处理程序，所以它被忽略。Bug 2。

在第 4 行，preferences 缓存被要求提供关于用户的信息，使用空字符串作为 id，缓存试图找到用户(参见短语“cache for is empty”中的双空格)？这是该消息中的空用户 id)。缓存应该知道足够多的信息，不接受空字符串作为用户 id。Bug 3。

在第 5 行，用户的完整信息被查询，在第 6 行，用户查询的结果回来了，它们并不好。用户数据库不仅欣然接受一个空字符串作为用户 id，而且还返回空字符串作为结果。这里的日志消息有两种双空格的情况，显示了空字符串被用作单词的两个地方。Bug 4。

# 错误的解决方法

在本例中，要做的简单事情是找到关闭的服务器，将其重新启动并重试。服务器将是可用的，用户 id 将被正确地检索，它将在缓存和数据库中找到真实的结果，一切都会好的。对吗？

不对。你不会修复任何错误——我们的第一个错误不是服务器停机，而是我们错误地处理了服务器停机。下一次服务器不可用时，一切都会再次出错。

# 解决问题的正确方法

向后工作，从最后一个问题开始。修复数据库，使其检测假 id，并返回某种错误。再次运行应用程序，可以看到错误 1 到 3 仍然发生，但是错误 4 已经被修复。

解决 bug 3:修复缓存，使其检测假 id，并返回某种错误(可能抛出异常)。再次运行应用程序，可以看到错误 1 和 2 仍然发生，但是错误 3 已经被修复。注意，在这一点上，您无法判断 bug 4 是否被修复:伪造的用户 id 永远不会到达数据库，因此它永远没有机会表明它可以检测到它。这就是为什么我们必须修复(和测试！)先 bug 4。Bug 4 只发生在 bug 1 到 bug 3 还在系统中的时候。

修复 bug 2:确保断言处理程序正确初始化，或者确保如果没有初始化，会发生一些戏剧性的事情(比如对话框或抛出的异常)。

修复 bug 1:不要断言用户 id 不能是空字符串。显然可以。请抛出一个异常。

既然四个错误都被修复了，你可以对真正的问题做些什么了:应用程序不能很好地处理不可用的服务器。有很多方法可以解决这个问题(重试、故障转移、缓存、冗余资源)，但这与主题无关。

# 付诸实践

像这样严格地逆向工作会很困难。首先，这四个 bug 可能会出现在不同的开发人员身上，协调他们的工作以确保以相反的顺序修复(和测试)这些 bug 将会太受限制。(在我的例子所基于的真实错误中，这四个错误是由三个不同的开发人员处理的)。

您可能面临时间压力，没有时间依次修复所有四个 bug。老板尖叫着让系统重新开始工作，不想听到一些“理论上”的改进。在他看来，在系统重新运行之前，一切都被破坏了。

有些人甚至会争辩说，修复所有四个错误是没有必要的。考虑 bug 4。一旦数据库客户机被修复，不再请求关于空用户 id 的数据，那么数据库服务器如何处理空用户 id 又有什么关系呢？所以它不再是一个 bug 了，对吗？

在现实世界中，有各种各样的约束和压力(时间、所有权、专业知识等)可能会说服你不去修复 bug。我明白——我们都必须运送产品，我们都是人。但事实是 bug 4 是一个真正的 bug。它可能是潜在的，可能很难修复，不修复它可能是权宜之计，但我们不要自欺欺人:它是一个错误。你看不见的虫子还是虫子。

当您可以运行代码时，修复代码是最容易的，而错误处理代码只有在有错误发生时才运行。破碎的错误处理代码只是一个等待发生的未来神秘事故。在修复错误之前修复错误处理代码。

# 请参见