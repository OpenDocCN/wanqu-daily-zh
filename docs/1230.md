# 什么是布鲁姆滤镜？。一个关于代码、晚餐和恩惠的故事……|作者杰米·塔尔博特| 3 分钟阅读

> 原文:[https://medium . com/the-story/what-are-bloom-filters-1 EC 2 a 50 c 68 ff？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://medium.com/the-story/what-are-bloom-filters-1ec2a50c68ff?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

# 什么是布鲁姆滤镜？

## 一个关于代码、晚餐和意想不到的结果的故事。

# 起源

"那么，你怎么知道一个人是否已经阅读了一篇文章呢？"灵媒的法律顾问莎拉问道。我们在吃我的生日晚餐，但不知何故又开始了工作的话题。莎拉指的是 Medium 的个性化阅读列表——我帮助建立的一个推荐系统——当用户访问 Medium 的主页时，它会向他们推荐新的有趣的帖子。

我叹气。我饿了，主菜刚刚上来——蜜汁鹿肉，配红薯土豆泥。问题是，[我发现描述这样的技术解决方案真的很有趣](http://lindaraftree.com/2014/07/22/devsplaining/)，Sarah 也知道这一点。如果她不是素食者，我会怀疑这是一个转移我注意力的策略，这样她就可以得到我的晚餐。我妻子苦笑着摇了摇头，转身和另一个朋友聊天。

我放下叉子，开始向她解释布鲁姆过滤器，一种 50 年前发明的巧妙的数据结构，以及我们如何在 Medium 使用它来回答莎拉的问题。餐桌上的其他人大多忽略了我们，当我开始在餐巾纸上画画来说明这个概念时，没有人会眨一下眼睛。所有这些以前都发生过，而且还会再次发生。

我停顿了一下，抬头看了看。"猴子哈希到什么？"我问餐桌上坐在我对面的中间人物布拉德。

“猴子会数到 10、2 和 1，”他马上说道，我也点头表示赞同。莎拉没有压力。两年前，在 Sarah 加入之前，我给 Medium 当时的 25 名员工做了一个关于 Bloom filters 的简短介绍。我印象深刻的是，Brad 还记得这个虚构的事实，关于一个虚构的哈希函数，这是为了说明误报的可能性而虚构的。但稍后会详细介绍。

T2】

# 散列法

要理解 Bloom filters，首先要理解 hashing。要理解哈希，你不需要理解数学，这很好，因为我充其量只是一个中等水平的数学家。我可能坐在中间。

哈希就像数据的指纹。哈希函数将您的数据(可以是任意长度)作为输入，并返回一个更小(通常)的固定(通常)长度的标识符，您可以用它来索引、比较或识别数据。

这是我全名的散列:

```
b3f9b3a3504ccb29c4183730a42c8d56
```

大多数哈希函数都是单向的操作，也就是说你可以从数据中找出一个标识符，但是通常不能反过来。举例来说，你不可能看着上面的散列，就知道我的全名是*詹姆斯·格拉汉姆·迈克尔·斯旺森·塔尔博特*。可逆散列函数确实存在，但它们往往相当琐碎，也不是特别有用。

在有用的散列函数中，有几个属性是需要的。最重要的一点是，相同的输入必须总是散列到相同的输出。真的，那是决定性的特征。如果相同的输入每次都产生不同的输出，那么它作为标识符就没什么用了。

理想情况下，输出值应该均匀分布，也就是说，每个可能的输出应该具有相同的可能性。对于许多用例来说，输出随机分布也很重要；相似的输入不应产生相似的输出。对于一些用例来说——通常是在安全方面——尽量减少冲突也很重要，这意味着，尽可能地，每个输入都应该给出唯一的输出。

最后，在大多数情况下(虽然不总是)，你希望它快。如今，没有人愿意等待任何东西，包括程序员。

您所关心的散列函数属性的组合会根据您使用它们的任务而有很大的不同。并且散列函数被用在*批*个任务中。Shazam 使用哈希来确定您正在听的歌曲。如果你需要在一组事物中找到重复的，你可以使用散列。数据库？巨型哈希表。这篇在 Medium 上的文章已经安全地发送给你了——你可能会在浏览器地址栏上看到一个绿色的挂锁来确认这一点。哈希在这个过程中也很重要。

你甚至可能听说过其中的一些算法。SHA-1——安全散列算法——是由美国国家安全局设计的，并且在很长一段时间内被用于保护大量的互联网通信。MD5 是另一种流行的方法，通常用于证明你正在下载的文件是你认为的那个文件，而不是美国国家安全局编写的感染你的计算机并监视你的恶意软件。(事实上，MD5 是我用来在页面上对我的名字进行编码的散列函数。)

一些散列函数有着奇特而无意义的名字——毕竟这是计算——所以你也会得到诸如 CityHash、MurmurHash 和 SpookyHash 之类的东西。

有数以千计的命名散列函数。有些是安全的，但计算起来相对较慢。有的速度很快，但是碰撞比较多。有些接近完美的均匀分布，但是很难实现。你明白了。如果说编程有一条规则的话，那就是:总会有取舍。

虽然你不必是一个理解散列的天才，但你必须是一个非常出色的数学家或计算机科学家来*创建*一个散列——或者至少是一个有用的散列。

以 Paul Hsieh 编写的这段优雅、难以理解的代码为例，他称之为 [SuperFastHash](http://www.azillionmonkeys.com/qed/hash.html) (不包括一些助手代码):

```
uint32_t SuperFastHash (const char * data, int len) {
  uint32_t hash = len, tmp;
  int rem;

  if (len <= 0 || data == NULL) return 0;
  rem = len & 3;
  len >>= 2;

  /* Main loop */
  for (;len > 0; len--) {
    hash += get16bits (data);
    tmp = (get16bits (data + 2) << 11) ^ hash;
    hash = (hash << 16) ^ tmp;
    data += 2 * sizeof (uint16_t);
    hash += hash >> 11;
  }

  /* Handle end cases */
  switch (rem) {
    case 3: hash += get16bits (data);
      hash ^= hash << 16;
      hash ^= ((signed char)data[sizeof (uint16_t)]) << 18;
      hash += hash >> 11;
      break;
    case 2: hash += get16bits (data);
      hash ^= hash << 11;
      hash += hash >> 17;
      break;
    case 1: hash += (signed char)*data;
      hash ^= hash << 10;
      hash += hash >> 1;
  } /* Force "avalanching" of final 127 bits */
  hash ^= hash << 3;
  hash += hash >> 5;
  hash ^= hash << 4;
  hash += hash >> 17;
  hash ^= hash << 25;
  hash += hash >> 6;

  return hash;
}
```

这是一系列的快速运算，比如加法和乘法，1 和 0 的反转，部分数据的混合和融合，移位等等。最后，你会得到一个几乎完美的输入数据的唯一指纹。为什么要选择那些操作，用那些数字，按那个顺序？难倒我了。谢保罗可能不是巫师，但我没有看到这方面的证据。

重要的是，我们有办法获取任何数据，如 YouTube 视频的内容，或 MP3 文件，或“猴子”一词，并获得长度可预测且唯一的指纹——主要是——该项目的指纹。

T2】

# 一个小忙

这都是玛茜的错，真的。马钦，如果你还不知道的话，[是](https://medium.com/designing-medium/ive-been-asked-to-report-to-this-office-efc664bcbc5f) [痴迷](https://medium.com/designing-medium/crafting-link-underlines-on-medium-7c03a9274f9) [用](https://medium.com/designing-medium/first-in-first-out-the-pilcrows-strange-typographic-history-3ab4f645a36) [排印](https://medium.com/designing-medium/death-to-typewriters-9b7712847639)。这一令人钦佩的特点使他成为一个容易的标记，如果你需要做任何涉及到 Medium 的字体或图标的任务，图标也是一种字体。去年的某个时候，我正在开发一个需要新图标的功能。我渴望在周末截止日期前将它发布到全世界，所以我在下午 6 点给他发了一条短信:

“你有没有可能在明天的某个时候给我们的字体添加一个新图标？我想发布*功能 X.* ”

“嗯。你会为我做什么？”他看似漫不经心地问道。(现在，在向你叙述这次交流时，我想象他像伯恩斯先生一样，高兴地搓着双手。)“你会修复我选择的一个错误吗？我明天一整天都很忙。”

“当然，”我说，很高兴我们能够发布这个功能。“你喜欢的任何东西，”我天真地保证。

下午六点半。带有通知的松弛 pings。“公关开始了，”他写道，并向我宣布他已经完成了这项工作。“我想让你修理这个”

T2】

# 这

这个词对于 JavaScript 程序员来说很有趣，它是语言新手的困惑来源，甚至让那些经常忘记语言的特殊功能范围的新手感到沮丧。它的要点是，每当你在 JavaScript 代码中看到*这个*，你永远不知道它指的是什么。对于习惯于一切都在适当位置的程序员来说，这可能会令人不安。JavaScript 充满了这些令人讨厌的、可爱的细微差别，并且具有近乎病态的灵活性。想象一下，一个政客正在和游说者交谈，游说者的大笔捐赠使他们的选举成为可能。JavaScript 比这更灵活。

Medium 的服务器端代码库主要是用 JavaScript 编写的，个性化阅读列表推荐系统津津有味地滥用了 JavaScript 的上述灵活性。我们后来发现，它的正确性能无意中依赖于选择异步指令进行处理的特殊方式。它居然起作用了，这真是一个奇迹。回头看看那段代码…好吧，这么说吧，[没有人比你过去的自己](https://medium.com/@majelbstoat/past-present-future-d39088ebed83)更糟糕了。

就像哈希表一样，推荐系统就在我们身边。网飞是一个推荐系统。StumbleUpon 和 Pandora 也是。亚马逊的“因为你在 Kindle 上购买了 *Cryptonomicon* ”功能。脸书的“你可能认识的人”，他们的流，他们的搜索结果。所有推荐系统。推荐系统的悲剧在于，只有当它们被破坏时，人们才会注意到它们。很少有人会说“我喜欢网飞的建议”更多的人说“啊，潘多拉昨天给我玩了一模一样的游戏。”推荐系统是计算世界的体育裁判。

为了给出好的建议，你需要收集关于你的用户的数据，并找到使用这些数据的有趣方法。对于 Medium 来说，推荐一个故事的简单方法可能是“因为你追随作者”一个更复杂的例子可能是*协同过滤*，你可以把它描述为“推荐了许多你推荐的故事的人也推荐了*这个*故事”。

一个典型的推荐系统将采用一系列这些方法，这些方法对你喜欢的东西做出很好的猜测，将它们的结果组合在一起，这样你就可以得到各种选择，然后对它们进行排序，使得分最高的方法排在第一位。这应该会很快完成。同样的事情给某人看太多次的系统会倒霉，因为这样会给用户支持带来沮丧、愤怒和大量的电子邮件。

中等用户写了几十万条帖子。每一个都有一个 ID，并存储在一个数据库表中，但是这个表太大了，而且被频繁地访问，以至于不能放在一台机器上。当您向数据库请求一个特定的帖子时，它如何知道在哪里可以找到它呢？哈希函数。数据库获取 ID，将其散列为一个唯一的值，并使用该值直接跳转到记录位置，就像您使用一本书的索引直接跳转到特定的页码，回到亚马逊向您推荐的书籍在纸上并有索引的时候。

当向用户推荐故事时，系统可能会出现成千上万种可能性，但并不是每一种都适合用户。也许一个故事已经向他们暗示了太多次了。也许他们已经读过了。我们需要过滤掉这些故事，但我们不想从数据库中检索成千上万的记录来完成这项工作。我们需要一个特别擅长回答“这种情况以前出现过吗？”这个问题的机制。

为此，我们使用了布鲁姆过滤器。

T2】

# 回报恩惠

对我来说不幸的是，Marcin 谈论的这个问题是我无法帮他解决的。他想让我改变人们在特定列表中出现的顺序，让你的朋友先出现。这并不是一个复杂的变化，但我们存储数据的方式意味着列表将变得加载缓慢，无限滚动将被打破。令人遗憾的是，在我们重组数据存储之前，我们只能停留在现有的水平上，考虑到我们的其他优先事项，这不太可能很快实现。权衡也发生在产品开发中。我不好意思地向他报告，他将不得不选择其他东西。

圣诞节快到了，我把我的承诺忘得一干二净。然后在 2 月 18 日，这出现在 Slack 上:

```
[mwichary][9:08 AM] BTW I was supposed to send you possible issues to work on: https://github.com/Medium/medium/issues/xxxx
```

大象永远不会忘记，显然，波兰设计师也不会忘记。令人难以置信的是，他这次发给我的 bug 是*字面上的*不可能修复的。

部分出于内疚，但主要是因为他非常健谈，我邀请他参加我 6 月份的生日晚宴。然后，大概一周前，*这个*:

```
[mwichary][1:24 PM] this is a periodic reminder that you owe me this https://github.com/Medium/medium/issues/xxxxx or a Paul Ford-esque article.
```

于是*那个*迅速升级。

保罗·福特，如果你不知道的话，最近写了一篇关于编程及其相关内容的令人难以置信的论文。有趣、易懂、信息丰富、博学——见鬼，它甚至还有复活节彩蛋。借用格林斯潘的第十条规则，我很有信心，任何对代码和文化的足够完整的解释，现在都将包含一个表达不清、错误百出、抄袭复述的半个[什么是代码](http://www.bloomberg.com/graphics/2015-paul-ford-what-is-code)。(女士们，先生们，我来介绍 a 号证物。)

不再寻求一个不可能的编程任务，Marcin 现在满足于一个不可能的写作任务。

T2】

# 时间与空间

这个世界几乎不需要另一个关于*算法*的定义，但我还是要说:*算法是解决一个问题的一系列步骤*。简单。算法实际上与计算机没有任何关系，尽管计算机被证明是非常方便的算法处理机器。前面说的哈希函数都是算法的实现，但并不是所有算法都那么复杂。事实上，许多最重要的问题其实很简单。

以 Dijkstra 的算法为例——是的，保罗·福特确实提到了这个算法——它用于寻找图中两点之间的最短路径。用一段简单的英语来描述就够简单了:

从你的起点开始，算出到达每个邻居需要多长时间。然后找到每个邻居，算出到达每个邻居的累计时间。(不要回到你已经去过的地方。)如果累计总数比到该点的当前最短路径短，则用较低的数字替换该点的数字。重复一遍。当你到达终点时完成。

值得注意的是，这个简单的算法和它的修改，是让计算机有效地相互交流的基础。如果没有 T2 的开创性工作，你的 Kindle 书籍将需要更长的时间才能通过 Whispernet 到达你的手中。

然后是排序，这是世界各地 CS101 课程的老主题。有几十种被充分理解和深入分析的排序算法。我们有快速排序、合并排序、冒泡排序、堆排序和插入排序。因为这是计算，所以还有 Timsort，Stoogesort 和 smooth sort——Dijkstra 也负责最后一个。

对于个性化的阅读列表，当我们准备好所有的建议，并希望按分数排序时，我们如何选择使用哪种排序？如果所有的排序算法给你的结果都一样，我们怎么知道哪个更好呢？

算法性能有很多衡量标准，但其中最重要的两个是时间复杂度和空间复杂度。

假设您想在一个简单的数字列表中找到最小的数字。要做到这一点，你必须看每个数字一次，因为最后一个数字可能是最小的。随着列表的增长，您需要做更多的检查。我们会说这个算法有*线性*时间复杂度。当我们遍历列表时，我们只需要记住一个数字——当前最低的数字。因为我们只需要记住一个数字，不管列表有多长，我们都会说算法有*常数*空间复杂度。

还记得使用散列值让数据库直接跳到记录上吗，就像书中的索引一样？从计算上来说，我们说这是一个*常量*时间操作，因为平均来说，无论记录有多大，或者表中有多少记录，查找记录都需要相同的时间。常数时间操作很棒，因为它们很快。

计算中的大多数问题都有多个解决方案，通常情况下，您可以在需要较少空间的较慢算法和使用较多空间的较快算法之间进行选择。选择哪一种取决于系统的具体需求。权衡取舍。

这种特殊的权衡有时被称为时空权衡，这总是让我想起黑洞、爱因斯坦和道格拉斯·亚当斯的[双重性](http://hitchhikers.wikia.com/wiki/Bistromathics)。

T2】

# 请结账

我们坐的小酒馆开始空了。支票到了。我们抑制了激发无限可能性的冲动，平均分配，并帮了服务员一个忙，用一张卡付账。信用卡处理——哈希也在这里使用。

整个晚上我设法吃了几口蜜汁鹿肉，其余的被我妻子感激地一次要了一叉。我突然想到是她让莎拉这么做的。偏执？大概吧。不过，我成功击退了对我的英国奶酪的攻击。鹿肉是鹿肉，甜点是甜点。

莎拉一直非常亲切，没有让她的眼睛呆滞，但每个人都开始看起来昏昏欲睡。幸运的是，所有的背景都不碍事。我喝干了我的酒杯，终于回答了这个问题。

T2】

# 盛开

伯顿·霍华德·布鲁姆(Burton Howard Bloom)，我们故事中的同名主人公，不得不说，他有一个非常悦耳的名字——Bur-ton-Ho-ward-Bloom(T1)——从 1963 年到 1965 年在麻省理工学院学习计算机科学。1970 年，他在马萨诸塞州牛顿上瀑布的计算机使用公司工作时，发明了被称为布鲁姆过滤器的数据结构[。](http://astrometry.net/svn/trunk/documents/papers/dstn-review/papers/bloom1970.pdf)

Bloom filters 可以非常快速地回答“是/否”问题的变体“这个项目在集合中吗？”，比如“我以前见过这个物品吗？”。不过，有两个重要的警告。很少，当答案实际上是*否*时，它会说*是*(虽然它永远不会说*否*，当答案实际上是*是*)。您也不能从布隆过滤器中删除项目。就像大象和不屈不挠的波兰设计师一样，Bloom filters 永远不会忘记。

如果你能接受偶尔的一些误报，并且不需要删除项目，这是一个很好的选择。Bloom filter 对于添加条目*和*来询问它们是否存在具有恒定的时间复杂度，这使得它非常棒，并且相对于您需要存储和检查的条目的大小，它只需要很少的空间。它获得这些属性很大程度上是因为它基于哈希函数。

对于 Bloom filters 使用的散列函数，输出中的冲突并不太重要，只要它们相当罕见。更重要的是输出要均匀随机分布。当然，我们希望我们的散列函数很快。

您可以将 Bloom filter 想象成一大组编号的桶，每个桶都是空的。假设我们想要跟踪 Ev Williams 拥有的宠物。为此，我们将使用一个具有 10 个桶和三个哈希函数的 Bloom 过滤器。

我们首先将*猫*放入我们的布隆过滤器。在内部，过滤器获取 *Cat* 并将其传递给三个哈希函数，这三个哈希函数返回三个标识符。在这种情况下， *Cat* 散列到标识符 3、4 和 10。过滤器开始填充每个编号与标识符之一匹配的存储桶——3、4 和 10。它能够很快做到这一点，因为它可以直接跳到每个桶来填满它，就像你从索引直接跳到页码一样。



接下来，我们将*狗*放入我们的过滤器。使用相同的散列函数， *Dog* 散列到 5、2 和 1，所以那些桶也被填满。在我们完成这两个操作之后，桶 1、2、3、4、5 和 10 是满的。



伊芙养猫吗？我们可以问过滤器。因为相同的输入总是散列到相同的输出， *Cat* 仍然散列到 3、4 和 10，所以我们需要检查所有这些桶。因为他们都吃饱了，我们很确定伊芙有一只猫。

所以让我们看看有没有大象。*大象*哈希为 10，6，7。当我们检查那些桶时，10 是满的，但是 6 和 7 是空的。我们知道，如果*大象*被放入过滤器，桶 10、6 和 7 将是满的。所以我们可以斩钉截铁的说 Ev 没有大象。还没有。



但是我们如何得到假阳性呢？现在想象一下，我们想看看有没有猴子。正如布拉德回忆的那样， *Monkey* 散列为 10、2 和 1。我们检查了桶 10、2 和 1，瞧，它们都是满的。布鲁姆过滤器告诉我们 Ev 有一只*猴子*，尽管他没有。还没有。



作为一个推论，一个 Bloom filter 不能回答“Ev Williams 有什么宠物？”，因为是单向的。没有办法知道是什么动物的组合，外来的还是其他的，导致了现在的满桶。

我们可以通过控制布隆过滤器的大小来控制得到假阳性的概率。更多的空间意味着更少的误报。大家跟我一起说:取舍。









T2】

# Digestif

我们离开餐馆，沿路去喝睡前酒。

“好的，让我看看我是否理解对了，”萨拉说。“您希望能够快速排除用户已经阅读的帖子，这样您就不会再次建议这些帖子。布鲁姆过滤器很适合这个问题，因为它永远不会让用户阅读的帖子通过，即使它可能会排除他们没有阅读的帖子，这也没关系，因为他们永远不会知道他们没有看到什么？而且速度很快？”

“正是，”我回答。

“这将是一个很好的故事，”马钦说。

T2】

感谢莎拉·阿古多，她对技术的兴趣经常引发这样的讨论，她对长篇大论的解释有着极高的容忍度。感谢 Nick Santos 对技术部分的反馈。我想，也要感谢 Marcin Wichary 操纵我写下这篇文章，以及那些让阅读媒体上的文字成为一种乐趣的小细节。虽然我觉得他现在欠我一个人情。

正如任何一篇关于代码的文章一样，出于对故事和更清晰的交流的尊重，我们做了某些简化。所有的错误都是我自己的。如果你发现了什么特别过分的事情，在空白处写个便条！