# 如何改进遗留代码库

> 原文:[https://jacquesmattheij.com/improving-a-legacy-codebase?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://jacquesmattheij.com/improving-a-legacy-codebase?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

在每个程序员、项目经理或团队领导的一生中，这至少会发生一次。你得到的是一堆热气腾腾的肥料，如果你幸运的话只有几百万行，最初的程序员早就去了更好的地方，文档——如果有的话——与目前保持公司运转的东西完全不同步。

你的工作是:让我们摆脱困境。

当你的第一个本能反应(逃之夭夭)过去后，你就开始着手这个项目，同时清楚地知道公司高层领导的目光都在看着你。失败不是一个选项。然而，从你所得到的来看，失败是很有可能的。那怎么办呢？

我已经(不)幸运地遇到过几次这种情况，我和一小群朋友发现，能够处理这些冒着热气的痛苦，并将它们转化为健康的可维护项目，是一件有利可图的事情。以下是我们使用的一些技巧:

## 支持

在你开始做任何事情之前，备份所有可能相关的东西。这是为了确保不会丢失任何可能至关重要的信息。一旦做出改变，你只需要回答一个你无法回答的愚蠢问题，就能吃掉一天或更长时间。尤其是配置数据容易受到这种问题的影响，它通常没有版本控制，如果它被包含在定期备份方案中，那就很幸运了。所以安全总比后悔好，把所有东西复制到一个非常安全的地方，永远不要碰它，除非它处于只读模式。

## 重要的先决条件，确保您有一个构建过程，并且它实际上产生在生产中运行的内容

我完全错过了这一步，因为我认为这是显而易见的，而且很可能已经到位了，但许多 HN 的评论者指出了这一点，他们完全正确:第一步是确保你知道什么正在生产中运行，这意味着你需要能够构建一个版本的软件，如果你的平台以这种方式工作，它与当前的生产版本完全相同。如果你找不到实现这一点的方法，那么一旦你将某样东西投入生产，你很可能会遇到一些不愉快的惊喜。请确保您尽最大努力测试它，以确保您已经准备好了所有的部分，然后，在您对它的工作有了足够的信心之后，将它转移到生产中。准备好立即切换回之前运行的任何东西，并确保记录下在不可避免的事后分析中可能会派上用场的所有东西。

## 冻结数据库

如果可能的话，冻结数据库模式，直到您完成了第一级改进，当您对代码库有了坚实的理解并且遗留代码已经完全被抛在后面时，您就可以修改数据库模式了。如果在此之前更改它，您可能会遇到真正的问题，现在您已经失去了同时运行新旧代码库的能力，而数据库是构建的稳定基础。保持数据库完全不变允许您比较新的业务逻辑代码与旧的业务逻辑代码的效果，如果它们都像宣传的那样工作，应该没有区别。

## 编写您的测试

在做出任何改变之前，尽可能多地编写端到端和集成测试。确保这些测试产生正确的输出，并测试任何和所有你能想到的关于你如何*思考*旧东西如何工作的假设(准备好这里的惊喜)。这些测试将有两个重要的功能:它们将有助于在非常早期的阶段消除任何误解，并且一旦您开始编写新代码来替换旧代码，它们将起到护栏的作用。

自动化所有的测试，如果你已经体验过 CI，那么就使用它，并确保你的测试运行得足够快，以便在每次提交后运行完整的测试集。

## 仪器和测井

如果旧平台仍可用于开发，请添加仪器。在一个全新的数据库表中这样做，为您能想到的每个事件添加一个简单的计数器，并添加一个函数来根据事件的名称递增这些计数器。通过这种方式，您可以用几行额外的代码实现一个带时间戳的事件日志，并且您将很好地了解有多少一种类型的事件导致了另一种类型的事件。一个例子:用户打开应用程序，用户关闭应用程序。如果两个事件应该导致一些后端调用，那么这两个计数器应该长期保持恒定的差异，该差异是当前打开的应用程序的数量。如果你看到应用程序打开的次数比关闭的次数多，你就知道应用程序一定会以某种方式结束(比如崩溃)。你会发现每一个事件都与其他事件有某种关系，通常你会努力保持这种关系，除非系统的某个地方有明显的错误。您的目标是减少那些指示错误的计数器，并且您的目标是最大化链中更靠下的计数器，达到开始时计数器所指示的级别。(例如:尝试付款的客户应收到相同数量的实际付款)。

这个非常简单的技巧将每一个后端应用程序变成了一个簿记系统，就像一个真正的簿记系统一样，数字必须匹配，只要它们不存在问题。

随着时间的推移，该系统在建立系统健康方面将变得非常有价值，并且将是源代码控制系统修订日志旁边的一个很好的伙伴，在该日志中，您可以确定引入 bug 的时间点以及对各种计数器的影响。

我通常将这些计数器保持在 5 分钟的分辨率(所以一小时 12 个桶)，但是如果您有一个生成更少或更多事件的应用程序，那么您可能会决定更改创建新桶的间隔。所有计数器共享同一个数据库表，因此每个计数器只是该表中的一列。

## 当时只改变一件事

不要陷入在添加新特性或修复错误的同时提高代码或运行平台的可维护性的陷阱。这会让你非常头疼，因为你现在不得不每一步都问自己，一个行动的预期结果是什么，这将使你之前做的一些测试无效。

## 平台变化

如果您已经决定将应用程序迁移到另一个平台，那么首先要做这件事*，但保持其他一切完全相同*。如果您愿意，您可以添加更多的文档或测试，但不能超过这些，所有的业务逻辑和相互依赖关系都应该保持不变。

## 架构变化

接下来要处理的事情是改变应用程序的架构(如果需要的话)。此时，您可以自由地更改代码的高层结构，通常是通过减少模块之间的水平链接数量，从而减少在与最终用户的任何一次交互中代码的活动范围。如果旧代码在本质上是单一的，那么现在是使它更加模块化的好时机，将大函数分解成小函数，但保留变量和数据结构的名称。

*HN 用户 [mannykannot](https://news.ycombinator.com/item?id=14445661) 理所当然地指出，这并不总是一个选项，如果你特别不幸，那么你可能必须深入挖掘，以便能够进行任何架构更改。我同意这一点，我应该把它放在这里，所以有了这个小小的更新。我想进一步补充的是，如果你既做了高层次的更改，又做了低层次的更改，至少要尽量把它们限制在一个文件或最坏的情况下一个子系统中，这样你就尽可能地限制了更改的范围。否则，您可能很难调试刚刚做出的更改。*

## 低级重构

到目前为止，您应该对每个模块的功能有了很好的理解，并为真正的工作做好了准备:重构代码以提高可维护性，并为新功能做好准备。这可能是项目中消耗时间最多的部分，在进行过程中记录下来，不要对一个模块进行修改，直到你已经完全记录下来并且感觉你理解了它。随意重命名变量和函数以及数据结构，以提高清晰度和一致性，添加测试(如果情况允许，还有单元测试)。

## 修复 bug

现在，您已经准备好接受实际的最终用户可见的更改，首先要解决的是多年来在票证队列中积累的一长串错误。像往常一样，首先确认问题仍然存在，编写一个测试，然后修复 bug，您的 CI 和编写的端到端测试应该可以防止您由于缺乏理解或一些外围问题而犯任何错误。

## 数据库升级

如果需要的话，在所有这些都完成之后，你又有了一个可靠的、可维护的代码库，你可以选择改变数据库模式，或者用一个不同的品牌/型号替换数据库，如果这是你计划要做的。到目前为止，您所做的所有工作将有助于您以负责任的方式进行更改，不会出现任何意外，您可以使用新代码和所有测试来完全测试新数据库，以确保您的迁移顺利进行。

## 按照路线图执行

恭喜您，您已经脱离险境，现在可以实施新功能了。

## 永远不要尝试大爆炸式的重写

大爆炸式的重写是那种几乎肯定会失败的项目。首先，你处于未知领域，所以你怎么知道要构建什么，其次，你把所有的问题推到最后一天，就在你开始使用新系统的前一天。那就是你失败的时候，悲惨地。业务逻辑假设将被证明是错误的，突然你会洞察到为什么旧系统以这种方式做某些事情，一般来说，你最终会意识到把旧系统放在一起的人可能根本不是白痴。如果你真的想尽一切办法毁掉公司(以及你自己的声誉)，那就进行一次大爆炸式的重写，但如果你聪明的话，这甚至不是一个选项。

## 所以，另一种选择是，渐进地工作

要解开这些乱七八糟的东西，最快捷的安全途径是找出你理解的任何代码元素(可能是外围的，但也可能是核心模块)，并尝试在旧的上下文中逐步改进它。如果旧的构建工具不再可用，你将不得不使用一些技巧(见下文),但至少在你开始你的改变时，尽量保留尽可能多的已知有效的东西。这样，随着代码库的改进，您对其实际功能的理解也会随之改进。典型的提交应该至多是几行。

## 释放！

过程中的每一项变更都会发布到生产环境中，即使最终用户看不到这些变更，尽可能减少步骤也很重要，因为只要您对系统缺乏了解，就很有可能只有生产环境会告诉您存在问题。如果这个问题在你做了一个小小的改变后就出现了，你将获得几个好处:

*   找出哪里出了问题可能是微不足道的
*   你将处于一个很好的位置来改进这个过程
*   您应该立即更新文档，以展示获得的新见解

## 使用代理对你有利

如果你在做 web 开发，赞美上帝，在最终用户和旧系统之间插入一个代理。现在，您可以按 url 控制哪些请求将被发送到旧系统，哪些请求将被重新路由到新系统，从而可以更轻松、更精细地控制运行什么以及谁可以看到它。如果你的代理足够聪明，你可以用它为一个单独的 URL 向新系统发送一定比例的流量，直到你满意为止。如果您的集成测试也连接到这个接口，那就更好了。

## 是的，但是这一切将花费太多的时间！

那要看你怎么看了。的确，按照这些步骤进行会有一些返工。但是它*确实*起作用，并且这个过程的任何种类的优化都假设你比你可能做的更多地了解这个系统。我要维护自己的声誉，我*真的*不喜欢工作中出现这样的负面惊喜。运气好的话，该公司已经在走下坡路了，或者可能真的有把顾客的事情搞砸的危险。在这种情况下，我更喜欢完全控制和严格的过程，而不是节省几天或几周的时间，如果这危及一个好的结果的话。如果你更喜欢牛仔风格的东西——而且你的老板也同意——那么冒更大的风险也许是可以接受的，但大多数公司宁愿选择稍微慢一点但更有把握的成功之路。