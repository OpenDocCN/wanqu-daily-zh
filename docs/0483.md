# 高速缓存是新的 RAM

> 原文:[http://blog.memsql.com/cache-is-the-new-ram/?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://blog.memsql.com/cache-is-the-new-ram/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)



![Screen Shot 2014-11-11 at 3.37.03 PM](../Images/1c84c1bcef48570851b321f116b3d3e7.png)

长期从事技术行业的(少数)优势之一是，你可以看到多个技术周期的开始和结束。你可以看到突破是如何传播的。如果你看到的只是曲线的一部分，就很难正确外推。你要么超越短期进展，要么低于长期进展。令人惊讶的不是地面上的事实变化有多快，而是工程实践的反应变化有多慢。这是史端乔开关，一种连接电话线路的自动化方式。它发明于 1891 年。

![Screen Shot 2014-11-11 at 3.37.53 PM](../Images/4a2822563a105b313f2fae2b2247a783.png)

1951 年，就在数字交换的尖端，典型的中央交换局基本上是维多利亚时代技术的超大版本。每通电话的每个数字都有一个史端乔开关。

从当时的角度来看，这是

[highest of high technology](https://www.youtube.com/watch?v=xZePwin92cI)

。当然，从我们的角度来看，这是世界上最大的蒸汽朋克艺术装置。

![Screen Shot 2014-11-11 at 3.42.16 PM](../Images/c1f2d6854fee9f297ec9d68cc65055d7.png)

觉得自己高人一等可能是个错误。集成电路的发明已经过去了 65 年，但我们周围仍有数十亿个这样的家伙，它们在呼呼转动，咔嚓咔嚓，然后坏掉。直到现在，我们才处于向全固态计算转变的风口浪尖。

最激动人心的技术变革是当一种新的模式最终变得可行，或者旧的限制消失的时候。这两种情况现在都发生在我们的行业中。

![Screen Shot 2014-11-11 at 3.42.40 PM](../Images/57289e4296190211aa2322333ef40ab5.png)

分布式计算正在成为整个软件栈中的主导编程模型。所谓的“中央处理器”不再是中央的，甚至不再是一个单元。这只是在堆积如山的数据上爬行的众多 bug 之一。数据库是最后一个坚持者。

![Screen Shot 2014-11-11 at 3.43.37 PM](../Images/b66879ad40aea74308c18757dbcdd680.png)

与此同时，RAM 和硬盘存储之间的延迟差距变得无关紧要。30 年来，数据库性能的核心事实是访问 RAM 中的随机数据与访问硬盘上的随机数据所需时间的巨大差异。现在，通过将数据完全存储在 RAM 中，可以跳过所有这些令人头疼的问题。当然，事情没那么简单。你不能拿了一棵树，把它收拾好，然后就收工了。对于一个真正的内存本地设计来说，还有很多问题需要解决。

这两种趋势正在产生一种全新的思考、设计和构建应用程序的方式。所以，让我们来谈谈我们是如何走到这一步的，我们在做什么，以及未来将带我们去哪里的暗示。

![Screen Shot 2014-11-11 at 3.44.15 PM](../Images/bd1f3c12513f553f232b6fa4fae16475.png)

过去，架构图中的每个组件都有一个明确的附属条款。每样东西都是一个独立的功能:“数据库”和“web 服务器”，是一部单间戏剧中的角色。顺便提一下，这就是“云”这个术语的由来。蓬松的云是外部广域网的标准标志，其细节你不必担心。

![Screen Shot 2014-11-11 at 3.45.10 PM](../Images/218b27230e78855825a83a43a039d43d.png)

分布式计算以最低挂的果实击中了主流。多个相同的应用程序服务器隐藏在一个“负载平衡器”后面，它或多或少地平均分配工作。只对体系结构的无状态部分进行负载平衡回避了很多哲学问题。随着系统规模的扩大，这些组件包抄并最终包围了数据库。我们告诉自己，花更多的钱在有快速磁盘和更快 CPU 的特殊数据库硬件上是正常的，反正它只有一台机器。硬件供应商很乐意接受我们的钱。

![Screen Shot 2014-11-11 at 3.45.42 PM](../Images/3ff029c793d078dbcb2328990ee91dae.png)

最终，数据库复制变得合理了，我们通过添加一个热备用数据库来安慰自己。然后，我们告诉自己不再有任何单点故障。在几分钟内，这甚至是真的。

当然，这个热备盘太诱人了，不能闲置。一旦业务分析师意识到他们可以在不影响生产的情况下对实时生产数据运行巨大的查询，所谓的“热备盘”就变得几乎与生产拷贝一样繁忙和关键。我们告诉自己这没什么，因为如果需要备用的，我们可以在紧急情况下从他们那里拿走。但这就像说你真的不需要带备胎，因为你随时可以从另一辆车上偷一个。

![Screen Shot 2014-11-11 at 3.46.59 PM](../Images/8f6f736fdb16c987160eac0814ed859c.png)

然后 Brad Fitzpatrick 发布了 memcached，一个在内存中缓存数据的守护进程。(因此得名。)这是一款非常实用的软件，是当时学术界流行的分布式哈希表的简化版本。它有很多特性:一种复制形式、分片、负载平衡、简单的数学运算符。我们告诉自己，我们的大部分负载都是读取，那么为什么要让数据库反复运行相同的查询来折腾磁盘呢？你所需要的只是一堆小口径的服务器和大量的内存，当然硬件供应商很乐意接受我们的钱。

而且…也许你必须写一些缓存失效代码。那听起来不太难。对吗？

![Screen Shot 2014-11-11 at 3.47.06 PM](../Images/f488ad8dae3f5c70689ca25c146ffecc.png)

值得称赞的是，memcached 的设计走了很长的路。它用多组 RAM 的随机 IO 性能取代了硬盘的随机 IO 性能。尽管如此，数据库机器还是变得越来越大，越来越繁忙。我们意识到缓存至少要消耗与工作集一样多的 RAM(否则它是无效的)，再加上几乎难以忍受的缓存一致性问题。但我们告诉自己，这是“网络规模”的代价。

![Screen Shot 2014-11-11 at 3.47.12 PM](../Images/af7d2163ee10961232ee9777e11ca21b.png)

更令人担忧的是，应用程序变得越来越复杂，越来越繁琐。几乎每次命中都会执行多次数据库写入。成为瓶颈的是写，而不是读。这是我们最终认真对待数据库分片的时候。脸书最初按大学划分用户数据，并在相当长的一段时间里摆脱了“哈佛数据库”这样的概念。Flickr 是另一个很好的例子。他们用 PHP 手工构建了一个分片系统，通过用户 ID 的散列来分割数据库，就像 memcached 在键上分片一样。在他们的技术谈话中，有一些愉快的暗示，关于必须反规格化他们的表格和重复写对象，比如评论、消息和收藏夹。

但是，对于解决所有问题的无限扩展来说，这只是一个小小的代价。对吗？

![Screen Shot 2014-11-11 at 3.47.18 PM](../Images/8a09888abc61c822ab46859914cc1dd4.png)

手工分割关系数据库的问题是，您不再拥有关系数据库。编排分片的 API 实际上已经成为您的查询语言。您的操作难题也没有好转；跨舰队改变模式的痛苦实际上更糟糕。

这是很多人深吸一口气，列出他们选择的 SQL 实现的所有限制和缺点的时候…出于某种原因，他们决定责怪 SQL。潮人 NoSQL 和难民 XML 数据库如潮水般涌来，都是异想天开。他们提供了自动分片、灵活的模式、一些复制…起初并没有太多其他的。但这比你自己写的痛苦要少。

你知道当“比自己写更少痛苦”成为主要卖点时，事情真的很绝望。

![Screen Shot 2014-11-11 at 3.47.25 PM](../Images/47ede3d6f1917e2f4cf36bc013fe14d2.png)

搬到 NoSQL 并不比手工分割更糟糕，因为我们已经放弃了使用常用的客户端工具来操作和分析我们的数据的任何希望。但也好不到哪里去。过去由业务人员编写的 SQL 查询变成了由开发人员维护的手写报告代码。

还记得我们过去用于备份和分析的“热备盘”数据库吗？它以 Hadoop 文件存储和 Hive 查询的形式卷土重来。现在这种方法奏效了，并且在很大程度上让我们摆脱了商业人士。最大的问题是这些系统的操作复杂性。像航天飞机一样，它们被销售为可靠且几乎免维护，但事实证明需要大量的实际操作。第二大问题是数据的输入和输出；一天的滞后时间(！)被认为相当不错。第三个问题是，它设法同时在网络和磁盘上绑定 I/O。我们告诉自己，这是升级到大数据的代价。

反正谷歌就是这么做的。对吗？

![Screen Shot 2014-11-11 at 3.47.32 PM](../Images/e103ffb235b5f7204afd9af6b8b5c9f7.png)

随着各种 NoSQL 数据库的成熟，它们的 API 发生了一件奇怪的事情:它们开始看起来更像 SQL。这是因为 SQL 是关系集合论的一个非常直接的实现，而数学很难被愚弄。

![Screen Shot 2014-11-11 at 3.47.46 PM](../Images/f380c0a1ff3c0eb224f8eecf1cfdddb9.png)

套用保罗·格拉厄姆对 Lisp 令人无法忍受的沾沾自喜的评论:一旦你添加了 group by、filter 和 join，你就不能再声称发明了一种新的查询语言，只是一种新的 SQL 方言。语法更糟糕，没有优化器。

因为我们已经从 SQL 中走了这条奇怪的弯路，大多数系统缺少的关键部分是围绕关系集理论设计的存储引擎和查询优化器。后来，这导致了严重的性能下降。对于那些做对了的(或者通过驻留在 RAM 中来掩盖它)来说，还缺少其他的位，比如正确的复制。

我知道一个非常成功的网络创业公司，你肯定听说过它使用四个，数一数，四个独立的 NoSQL 系统来填补空白。

![Screen Shot 2014-11-11 at 3.47.54 PM](../Images/1af517f69bae7ce3b3bc09b5f87579df.png)

很明显，没有回到数据库和 1000 万纳秒的随机寻道时间。在寻找解决一切问题的真理的无休止的炒作周期下，有一个有趣的模式:一个痛点被一个聪明的方法缓解，这个方法带来了一个新的痛点。

![Screen Shot 2014-11-11 at 3.48.01 PM](../Images/46ddf50da88ff30de270fe342aace80a.png)

那么，下一个给这只狗的早餐添加什么复杂的小玩意呢？也许真正的诀窍是让事情变得更简单。

例如，RAM:在“数据库”机器中有很多 RAM，用于缓存和计算。Memcached 机器中也有很多 RAM。这些系统中 RAM 的总和应该至少等于您的工作数据集的大小。如果不是，那么你买得太低了。另外，我非常怀疑你的缓存层是否 100%有效。我敢打赌，你有大量的数据被缓存起来，在被驱逐之前不会再被读取。我赌更多的钱，你甚至不跟踪它。这并不意味着你是个坏人。这意味着缓存通常比它的价值更麻烦。

这些组件提供的许多特性看起来是可组合的，并且是互补的。要是他们能安排得更好就好了。

![Screen Shot 2014-11-11 at 3.48.07 PM](../Images/3a20e7a52f613230892dac6ed93344a4.png)

一旦你认为系统是分布式的，数据总是固态的，奇怪的事情就发生了:一切变得简单多了。通常只在查询调用期间使用的“临时”内存数据结构变成了唯一的结构。随机存取不再是大罪；这是正常的商业行为。您不必担心分页、重新平衡或数据局部性。

![Screen Shot 2014-11-11 at 3.48.13 PM](../Images/3c792f99a0d24a7c79241099b93915d4.png)

这是一个漂亮、简单的建筑。正如负载平衡器抽象出应用服务器一样，SQL“聚合器”抽象出编排数据读写的繁琐细节。这使得数据放置策略的核心保持在一个稳定的 API 后面，这允许双方在较少中断的情况下进行更改。

![Screen Shot 2014-11-11 at 3.48.24 PM](../Images/7afe4c76fa5f4d63ded606f3fa1db8b7.png)

所以现在一切都好了，对吗？我们终于来到了历史尽头的快乐之地。对吗？

![Screen Shot 2014-11-11 at 3.48.30 PM](../Images/48cf8d7feca28f001471cdb08bfb8f26.png)

无论你生活在什么时候，对计算机技术的现状感到自满都是错误的。总会有另一个瓶颈。

![Screen Shot 2014-11-11 at 3.48.35 PM](../Images/e6fd046194eb84a038bca228f570e80f.png)

这是 AMD 的“巴塞罗那”芯片，相对现代的设计。它有四个核心，但大部分表面被核心周围的缓存和 I/O 区域占据，就像沃尔玛周围的一个巨大停车场。在奔腾时代，高速缓存仅占芯片的 15%。第三个更安静的计算革命是 CPU 相对于内存的速度。所有这些昂贵的房地产现在都保留给缓存是有原因的。

数据库性能的核心事实曾经是 RAM 和磁盘之间的延迟差距。目前，我们自欺欺人地认为 CPU 缓存和 RAM 之间的延迟差距并不是完全相同的问题。但事实如此。

![Screen Shot 2014-11-11 at 3.48.44 PM](../Images/26fe471d8aa3a2bf7606b35c96016a30.png)

尽管我们喜欢假装共享内存确实存在，但它并不存在。有了大量的内核和大量的 RAM，不可避免地，一些内核会更靠近 RAM 的某些部分。

![Screen Shot 2014-11-11 at 3.48.53 PM](../Images/079f89e516e713f2b2c517c5cf32a3cc.png)

当你真正开始工作时，计算机实际上只做两件事:读符号和写符号。性能是计算机必须来回移动的数据量及其去向的函数。最令人高兴的可能情况是，一次读取并快速处理的无休止的连续数据流，永远不会被再次需要。GPU 就是一个很好的例子。但是大多数有趣的工作负载不是这样的。

![Screen Shot 2014-11-11 at 3.48.59 PM](../Images/34dffbb5e7f1c90a6602beb059bfeceb.png)

被追逐的每个随机指针几乎都会导致缓存缺失。对同一内存区域的每次争用(例如写锁)都会导致巨大的协调延迟。即使您的 CPU 缓存命中率为 99%，但事实并非如此，等待 RAM 的时间仍然占主导地位。

或者这样说:如果磁盘是新的磁带，RAM 是新的磁盘，那么 CPU 缓存就是新的 RAM。地点仍然很重要。

![Screen Shot 2014-11-11 at 3.49.05 PM](../Images/32bfa2d7d015e5e75465f56a20b214b4.png)

那么什么能解决这个问题呢？似乎有相同的基本冲突:我们是为随机访问优化，还是为串行访问优化？我们会损失写或读的性能吗？我们能不能坐以待毙让硬件赶上来？也许忆阻器或其他技术会让这一切变得无关紧要。嗯，我也想要一匹小马。

好消息是，分布式数据库的总体物理架构似乎正在稳定下来。数据客户机不再需要处理 4 或 5 个独立子系统的内部事务。还不完善；甚至还不是主流。突破需要一段时间来传播。

但是，如果下一个瓶颈真的是内存局部性，这意味着它的其余部分已经变得成熟。新的创新将倾向于数据结构和算法。承诺修复一切的大规模架构变革将会减少。如果我们幸运的话，接下来的 15 年将会是 SQL 数据库悄悄地变得更快更有效，同时公开相同的 API。

不过话说回来，我们这个行业从来没有安静过。

* * *

要下载 SingleStore，请访问:

[http://www.singlestore.com/free/](/free/)

单店是一种

[in memory database](/)

这使得企业能够使用 SQL 同时处理事务和运行分析。

