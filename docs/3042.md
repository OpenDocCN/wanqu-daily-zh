# 最终一致-重新访问|所有分发的内容

> 原文:[http://www . all things distributed . com/2008/12/finally _ consistent . html？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://www.allthingsdistributed.com/2008/12/eventually_consistent.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

 大约一年前，我写了一篇关于一致性模型的文章的第一个版本，但我对它一直不满意，因为它写得太匆忙，而且这个主题非常重要，需要更彻底的讨论。 [ACM 队列](http://queue.acm.org/issuedetail.cfm?issue=1466443)让我修改这篇文章，以便在他们的杂志上使用，我借此机会改进了这篇文章。这是新版本。

最终一致性——在全球范围内构建可靠的分布式系统需要在一致性和可用性之间进行权衡。

亚马逊云计算的基础是基础设施服务，如亚马逊的 S3(简单存储服务)、SimpleDB 和 EC2(弹性计算云)，它们为构建互联网规模的计算平台和各种各样的应用程序提供资源。对这些基础设施服务的要求非常严格；他们需要在安全性、可扩展性、可用性、性能和成本效益方面获得高分，并且需要在满足这些要求的同时，持续为全球数百万客户提供服务。

在这些服务的背后，是在全球范围内运作的大规模分布式系统。这种规模带来了额外的挑战，因为当系统处理数万亿个请求时，通常发生概率较低的事件现在肯定会发生，并且需要在系统的设计和架构中提前考虑。鉴于这些系统的全球范围，我们无处不在地使用复制技术来保证一致的性能和高可用性。虽然复制使我们更接近我们的目标，但它不能以完全透明的方式实现它们；在许多情况下，这些服务的客户将面临在服务中使用复制技术的后果。

其中一种表现方式是所提供的数据一致性类型，特别是当底层分布式系统为数据复制提供最终的一致性模型时。当在 Amazon 设计这些大规模系统时，我们使用一组与大规模数据复制相关的指导原则和抽象，并专注于高可用性和数据一致性之间的权衡。在本文中，我将介绍一些相关的背景知识，这些知识已经通知了我们交付需要在全球范围内运行的可靠的分布式系统的方法。这篇文章的早期版本出现在 2007 年 12 月的 All Things Distributed 博客上，并在读者的帮助下做了很大的改进。

**历史透视**

在理想情况下，只有一个一致性模型:当进行更新时，所有观察者都会看到该更新。第一次出现难以实现的情况是在 70 年代后期的数据库系统中。关于这个话题最好的“时代文章”是由布鲁斯·林赛等人写的“分布式数据库笔记”。 <sup>5</sup> 它阐述了数据库复制的基本原则，并讨论了许多实现一致性的技术。这些技术中的许多都试图实现分布透明性——也就是说，对于系统的用户来说，似乎只有一个系统，而不是许多协作系统。在此期间，许多系统采取的方法是，使整个系统失败比破坏这种透明性要好。 <sup>2</sup>

在 90 年代中期，随着大型互联网系统的兴起，这些实践被重新审视。那时，人们开始考虑可用性可能是这些系统最重要的属性，但是他们正在努力权衡什么。Eric Brewer 是加州大学伯克利分校的系统教授，也是当时 Inktomi 的负责人，他在 2000 年 PODC T3(分布式计算原理)会议的 T2 主题演讲中将不同的权衡放在一起。 <sup>1</sup> 他提出了上限定理，该定理指出，共享数据系统的三个属性——数据一致性、系统可用性和对网络分区的容忍度——在任何给定的时间只能达到两个。Seth Gilbert 和 Nancy Lynch 在 2002 年的一篇论文中找到了更正式的证明。 <sup>4</sup>

不容忍网络分区的系统可以实现数据一致性和可用性，并且通常通过使用事务协议来实现。要实现这一点，客户端和存储系统必须是同一个环境的一部分；在某些情况下，它们会作为一个整体失败，因此，客户端无法观察分区。一个重要的观察是，在较大的分布式系统中，网络分区是给定的；因此，一致性和可用性是无法同时实现的。这意味着有两种选择:放松一致性将允许系统在可分区的条件下保持高可用性，而使一致性成为优先级意味着在某些条件下系统将不可用。

这两个选项都要求客户端开发人员了解系统提供了什么。如果系统强调一致性，开发人员就必须处理这样一个事实，即系统可能不可用于例如写操作。如果由于系统不可用而导致写入失败，那么开发人员将不得不处理如何处理要写入的数据。如果系统强调可用性，它可能总是接受写入，但在某些情况下，读取不会反映最近完成的写入的结果。然后，开发人员必须决定客户端是否需要始终访问绝对最新的更新。有一系列应用程序可以处理稍微陈旧的数据，在这种模型下它们可以得到很好的服务。

原则上，在 [ACID](http://en.wikipedia.org/wiki/ACID) 属性(原子性、一致性、隔离性、持久性)中定义的事务系统的一致性属性是一种不同的一致性保证。在 ACID 中，一致性涉及保证当事务完成时，数据库处于一致状态；例如，当把钱从一个账户转到另一个账户时，两个账户中的总额不应改变。在基于 ACID 的系统中，这种一致性通常是编写事务的开发人员的责任，但是可以通过管理完整性约束的数据库来帮助实现。

**一致性—客户端和服务器**

看待一致性有两种方式。一个是从开发人员/客户的角度:他们如何观察数据更新。第二种方式来自服务器端:更新如何在系统中流动，以及系统可以对更新提供什么保证。

**客户端一致性**

客户端具有以下组件:

*   **一个存储系统。**目前我们将它视为一个黑匣子，但我们应该假设在它的背后是一个大规模、高度分布的东西，并且它是为了保证耐用性和可用性而构建的。
*   **进程 A.** 这是一个向存储系统写入数据和从中读取数据的进程。
*   **进程 B 和 c**这两个进程独立于进程 A，对存储系统进行读写操作。这些是真正的进程还是同一进程中的线程并不重要；重要的是，他们是独立的，需要交流分享信息。
    客户端一致性与观察者(在这种情况下是进程 A、B 或 C)如何以及何时看到存储系统中数据对象的更新有关。在说明不同类型的一致性的以下示例中，进程 A 对数据对象进行了更新:
*   **强烈的一致性。**更新完成后，任何后续访问(通过 A、B 或 C)都将返回更新后的值。
*   **弱一致性。**系统不保证后续访问将返回更新后的值。在返回值之前，需要满足许多条件。更新和保证任何观察者将总是看到更新值的时刻之间的时间段被称为*不一致窗口*。
*   最终的一致性。这是弱一致性的一种具体形式；存储系统保证，如果没有对对象进行新的更新，最终所有访问将返回最后更新的值。如果没有故障发生，不一致窗口的最大大小可以基于诸如通信延迟、系统上的负载以及复制方案中涉及的副本数量之类的因素来确定。实现最终一致性的最流行的系统是 DNS(域名系统)。根据配置的模式并结合时间控制的高速缓存来分发对名称的更新；最终，所有客户端都会看到更新。

最终的一致性模型有许多值得考虑的变化:

*   **因果一致性。**如果进程 A 已经通知进程 B 它已经更新了一个数据项，则进程 B 的后续访问将返回更新后的值，并且保证写操作会取代先前的写操作。与进程 A 没有因果关系的进程 C 的访问遵循正常的最终一致性规则。
*   **读你写的一致性。**这是一个重要的模型，在这个模型中，进程 A 在更新了一个数据项之后，总是访问更新后的值，并且永远不会看到旧的值。这是因果一致性模型的一个特例。
*   **会话一致性。**这是前面模型的实际版本，其中进程在会话的上下文中访问存储系统。只要会话存在，系统就会保证读写操作的一致性。如果会话由于某个失败场景而终止，则需要创建新的会话，并且保证不与会话重叠。
*   **单调读取一致性。**如果一个进程已经看到了该对象的一个特定值，任何后续的访问将永远不会返回任何先前的值。
*   **单调写入一致性。**在这种情况下，系统保证通过相同的过程序列化写入。众所周知，不能保证这种一致性的系统很难编程。

这些属性中的一些可以被组合。例如，可以将单调读取与会话级一致性结合起来。从实践的角度来看，这两个属性(单调读取和读取您的写入)在最终的一致性系统中是最理想的，但并不总是必需的。这两个属性使得开发人员构建应用程序更加简单，同时允许存储系统放松一致性并提供高可用性。

正如您可以从这些变化中看到的，相当多的不同场景都是可能的。人们能否处理这些后果取决于具体的应用。

最终的一致性并不是极端分布式系统的神秘属性。许多提供主备份可靠性的现代 RDBMSs(关系数据库管理系统)以同步和异步模式实现它们的复制技术。在同步模式下，副本更新是事务的一部分。在异步模式下，更新以延迟的方式到达备份，通常通过日志传送。在后一种模式下，如果主服务器在日志发送之前出现故障，从升级的备份中读取将产生旧的、不一致的值。此外，为了支持更好的可伸缩读取性能，RDBMSs 已经开始提供从备份中读取的能力，这是提供最终一致性保证的经典案例，其中不一致性窗口取决于日志传送的周期性。

**Server-side Consistency**

在服务器端，我们需要更深入地了解更新是如何在系统中流动的，以了解是什么驱动了使用该系统的开发人员所能体验到的不同模式。在开始之前，让我们先确定几个定义:

N =存储数据副本的节点数量

W =在更新完成之前需要确认收到更新的副本的数量

R =通过读操作访问数据对象时联系的副本的数量

如果 W+R > N，那么写集合和读集合总是重叠的，并且可以保证强一致性。在实现同步复制的主备份 RDBMS 场景中，N=2，W=2，R=1。无论客户端从哪个副本读取，总会得到一致的答案。在启用从备份读取的异步复制中，N=2，W=1，R=1。在这种情况下，R+W=N，并且不能保证一致性。

作为基本法定协议的这些配置的问题在于，当系统由于故障而无法写入 W 节点时，写入操作必须失败，这标志着系统不可用。在 N=3 和 W=3 并且只有两个节点可用的情况下，系统将不得不使写入失败。

在需要提供高性能和高可用性的分布式存储系统中，副本的数量通常高于两个。只关注容错的系统通常使用 N = 3(W = 2 和 R=2 的配置)。需要提供非常高的读取负载的系统通常会复制超出容错要求的数据；n 可以是数十甚至数百个节点，R 配置为 1，这样单次读取将返回一个结果。对于更新，关注一致性的系统设置为 W=N，这可能会降低写入成功的概率。对于这些关注容错而非一致性的系统，一种常见的配置是以 W=1 运行，以获得更新的最小持久性，然后依靠懒惰(流行)技术来更新其他副本。

如何配置 N、W 和 R 取决于常见情况是什么，以及需要优化哪条性能路径。在 R=1 和 N=W 时，我们针对读取情况进行优化，在 W=1 和 R=N 时，我们针对非常快速的写入进行优化。当然，在后一种情况下，在出现故障的情况下不能保证耐久性，并且如果 W < (N+1)/2，则当写集合不重叠时，存在写冲突的可能性。

当 W+R <= N 时，出现弱/最终一致性，这意味着读和写集合有可能不会重叠。如果这是有意的配置，而不是基于故障情况，那么将 R 设置为 1 以外的任何值都没有意义。这在两种非常常见的情况下会发生:第一种是前面提到的用于读取扩展的大规模复制；第二个是数据访问更复杂的地方。在简单的键-值模型中，比较版本以确定写入系统的最新值很容易，但是在返回对象集的系统中，确定正确的最新集应该是什么就比较困难了。在大多数写集小于副本集的系统中，有一种机制以惰性方式将更新应用于副本集中的剩余节点。直到所有副本都被更新的时间段是之前讨论的不一致窗口。如果 W+R <= N，则系统容易受到尚未收到更新的节点的读取攻击。

能否实现“自己写自己读”、会话和单调一致性通常取决于客户机对为它们执行分布式协议的服务器的“粘性”。如果每次都是同一个服务器，那么保证读您的写和单调读就相对容易了。这使得管理负载平衡和容错稍微有点困难，但这是一个简单的解决方案。使用会话，这是粘性的，使这一点显而易见，并提供了客户可以推理的暴露级别。

有时，客户端实现“读您的写”和单调读取。通过在写入时添加版本，客户端会丢弃对版本早于最后一次看到的版本的值的读取。

当系统中的一些节点无法到达其他节点，但是两组客户端都可以到达时，就会发生分区。如果使用传统的多数仲裁方法，那么当另一个分区变得不可用时，具有 W 个副本集节点的分区可以继续进行更新。读集也是如此。鉴于这两个集合重叠，根据定义，少数集合变得不可用。分区并不经常发生，但它们确实发生在数据中心之间，以及数据中心内部。

在某些应用程序中，任何分区的不可用性都是不可接受的，能够访问该分区的客户端取得进展非常重要。在这种情况下，两端都分配一组新的存储节点来接收数据，并且在分区修复时执行合并操作。例如，在亚马逊内部，购物车使用这样一个总是写的系统；在分区的情况下，即使原始购物车位于其他分区，客户也可以继续将商品放入购物车。一旦分区修复，cart 应用程序就协助存储系统合并 cart。

**Amazon's Dynamo**

一个将所有这些属性置于应用架构的显式控制之下的系统是亚马逊的 Dynamo T1，这是一个键值存储系统，在组成亚马逊电子商务平台的许多服务以及亚马逊的 Web 服务中内部使用。Dynamo 的设计目标之一是允许创建 Dynamo 存储系统实例(通常跨越多个数据中心)的应用程序服务所有者以特定的成本在一致性、耐用性、可用性和性能之间进行权衡。 <sup>3</sup>

**Summary**

大规模可靠分布式系统中的数据不一致性是必须容忍的，原因有二:提高高并发条件下的读写性能；以及处理分区情况，在这种情况下，即使节点已经启动并运行，多数模型也会使部分系统不可用。

不一致是否可接受取决于客户端应用程序。在所有情况下，开发人员都需要知道一致性保证是由存储系统提供的，并且在开发应用程序时需要考虑到这一点。最终一致性模型有许多实际的改进，比如会话级一致性和单调读取，这为开发人员提供了更好的工具。很多时候，应用程序能够毫无问题地处理存储系统的最终一致性保证。一个特别受欢迎的例子是一个网站，其中我们可以有用户感知一致性的概念。在这种情况下，不一致性窗口需要小于客户返回进行下一次页面加载的预期时间。这允许更新在预期的下一次读取之前通过系统传播。

本文的目标是提高对工程系统复杂性的认识，这些系统需要在全球范围内运行，并需要仔细调整，以确保它们能够提供应用所需的耐用性、可用性和性能。系统设计者拥有的工具之一是一致性窗口的长度，在此期间，系统的客户可能暴露于大规模系统工程的现实。

**References**

1.  布鲁尔，环境评估，2000 年。[走向健壮的分布式系统(摘要)](http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf)。在*第 19 届 ACM 分布式计算原理研讨会的会议录*(7 月 16-19 日，俄勒冈州波特兰市):7
2.  与布鲁斯·林赛的对话。2004 年。ACM 队列 2(8): 22-33。
3.  DeCandia，g .，Hastorun，d .，Jampani，m .，Kakulapati，g .，Lakshman，a .，Pilchin，a .，Sivasubramanian，s .，Vosshall，p .，沃格尔斯，W. 2007 年。[迪纳摩:亚马逊的高可用性键值存储](http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html)。《第 21 届 ACM *操作系统原理研讨会论文集*(华盛顿州斯蒂文森，10 月)。
4.  吉尔伯特，s .，林奇，N. 2002。布鲁尔猜想和一致的、可用的、分区容忍的 Web 服务的可行性。美国计算机学会 SIGACT 新闻 33(2)。
5.  林赛，B. G .，塞林格，P. G .，等 1980。关于分布式数据库的说明。在*分布式数据库中。我*。德拉凡和普尔，247-284 页。剑桥:剑桥大学出版社。也可作为 IBM 研究报告 RJ2517 获得，加利福尼亚州圣何塞(1979 年 7 月)。