# 杰普森:网络分区的危险

> 原文：<https://aphyr.com/posts/281-call-me-maybe?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

本文是关于网络分区的系列文章 [Jepsen](/tags/jepsen) 的一部分。我们将学习分布式共识，讨论 CAP 定理的含义，并演示不同数据库在分区下的行为。

现代软件系统由几十个组件组成，这些组件通过一个异步的、不可靠的网络进行通信。理解分布式系统动态的可靠性需要仔细分析网络本身。像计算机科学中的大多数难题一样，这个问题可以归结为共享状态。被网络隔开的一组节点必须交换信息:“我喜欢那个帖子吗？”“我的写作成功了吗？”"你能缩略图我的图像吗？"“我的账户里有多少钱？”

在其中一个请求结束时，您可以保证所请求的操作…

*   从现在开始每个人都可以看到
*   现在对您的连接可见，以后对其他人可见
*   可能还不可见，但与系统的未来状态有因果关系
*   现在可见，但以后可能看不到
*   可能看得见也可能看不见:YOLO 错误

这些是分布式系统中*一致性*和*持久性*之间复杂相互作用的一些例子。例如，如果您将 CRDTs 写入两个地理上复制的 Riak 集群之一，其中 W=2，DW=1，那么您可以保证写入…

*   与系统的未来状态有因果关系
*   将在一个节点完全失效后继续存在
*   在所有节点断电的情况下(假设 fsync 正常工作),仍能存活
*   将在整个数据中心被摧毁后继续存在，只需几分钟即可复制

如果你正在写 ZooKeeper，你可能有一个更强的保证:例如，写操作现在对所有参与者可见，并且写操作将在 n/2 - 1 个节点完全失败后继续存在。如果你写 Postgres，根据你的事务的一致性级别，你可以保证写的内容对每个人都是可见的，只是对你自己，或者“最终”。

当网络不可靠时，这些保证特别难以理解。

分布式系统的形式化证明通常假设网络是*异步*的，这意味着网络可以任意复制、丢弃、延迟或重新排序节点之间的消息。这是一个很弱的假设:一些物理网络可以比这做得更好*，但是实际上 IP 网络会遇到所有这些故障模式，所以异步网络的理论局限性也适用于现实世界的系统。*

 *在*练习*中，TCP 状态机允许节点重建节点间消息的“可靠”有序传递。TCP 套接字保证我们的消息到达时不会丢失、重复或重新排序。然而，仍然会有任意的*延迟*——这通常会导致分布式系统*无限期地锁定*。由于计算机的内存和延迟有限，我们引入了*超时*，当预期的消息在给定的时间内没有到达时，它会关闭连接。对套接字上的`read()`的调用将简单地阻塞，然后失败。

![-008.jpg](img/88782c5da51ff415ccb146f7e3bccd4a.png "-008.jpg")

检测网络故障很难。由于我们对其他节点的唯一了解是通过网络传递的，因此延迟与故障是无法区分的。这是*网络分区*的基本问题:延迟高到足以被认为是故障。当分区出现时，我们没有办法确定*在其他节点上发生了什么:它们还活着吗？死了？他们收到我们的信息了吗？他们试图回应了吗？实际上没人知道。当网络最终愈合时，我们将不得不重新建立连接，并试图找出发生了什么——也许是从不一致的状态中恢复。*

许多系统通过进入特殊的*降级*操作模式来处理分区。CAP 定理告诉我们，我们可以拥有一致性(技术上，读写寄存器的*线性化*)或可用性(所有节点都可以继续处理请求)，但不能两者兼得。此外，很少有数据库接近 CAP 的理论极限；许多人只是丢弃数据。

在这个系列中，我将演示一些真实的分布式系统在网络出现故障时的行为。我们将从建立一个集群和一个简单的应用程序开始。在随后的每篇文章中，我们将探索为特定数据库编写的应用程序，以及该系统在分区下的行为。

可以在家里创建分区！对于这些演示，我将运行一个由 Ubuntu 12.10 机器组成的五节点集群，使用 LXC 进行虚拟化，但您也可以使用真实的计算机、虚拟专用服务器、EC2 等。我将节点命名为 n1、n2、n3、n4 和 n5:将这些条目添加到您计算机上的`/etc/hosts`和每个节点本身可能是最简单的。

我们需要对集群和客户端应用程序进行一些配置，以测试它们的行为。你可以克隆 http://github.com/aphyr/jepsen 来跟进。

为了跨集群运行命令，我使用 salti cid([http://github.com/aphyr/salticid](http://github.com/aphyr/salticid))。我已经将我的`~/.salticidrc`设置为指向 Jepsen repo 中的配置:

```
load ENV['HOME'] + '/jepsen/salticid/*.rb' 
```

如果您看一下这个文件，您会看到它定义了一个名为`:jepsen`的组，主机为 n1 … n5。每个节点的用户名和密码都是“Ubuntu”——如果你在公共互联网上运行你的节点，你可能需要更改这个。

尝试`salticid -s salticid`查看当前配置定义的所有组、主机和角色:

```
$ salticid -s salticid
Groups
  jepsen

Hosts:
  n1
  n2
  n3
  n4
  n5

Roles
  base
  riak
  mongo
  redis
  postgres
  jepsen
  net

Top-level tasks 
```

首先，让我们用一些常用软件——编译器、网络工具等来设置这些节点。

```
salticid base.setup 
```

角色定义了一些基本的操作系统功能。`base.reboot`将重启集群，`base.shutdown`将取消其电源。

`jepsen`角色定义了模拟网络故障的任务。要引起分区，运行`salticid jepsen.partition`。该命令导致节点 n1 和 n2 丢弃来自 n3、n4 和 n5 的 IP 流量，主要是通过运行

```
iptables -A INPUT -s n3 -j DROP
iptables -A INPUT -s n4 -j DROP
iptables -A INPUT -s n5 -j DROP 
```

就这样，真的。要检查当前网络状态，运行`jepsen.status`。`jepsen.heal`将 iptables 链重置为默认值，解析分区。

为了模拟慢速网络或丢包的网络，我们可以使用`tc`来调整以太网接口。Jepsen 假设节点间接口是`eth0`。`salticid jepsen.slow`将增加网络延迟，使得依赖于被丢弃的特定消息的错误更容易重现。`salticid jepsen.flaky`很可能会被*丢弃*消息。调整节点间的延迟和损耗模拟了现实世界网络在拥塞情况下的行为，并有助于揭示分布式算法(如数据库复制)中的时间依赖性。

为了测试一个分布式系统，我们需要一个工作负载——一组发出请求并记录分析结果的客户机。对于这些帖子，我们将使用一个简单的应用程序，将几个数字写入数据库中的列表。每个客户端应用程序将独立地向数据库写入一些整数。有五个客户端，客户端 0 写 0，5，10，15，…；客户端 1 写入 1、6、11 等等。

对于每次写入，我们记录数据库*是否成功确认了*写入，或者是否有错误。在运行结束时，我们向数据库请求完整的集合。如果确认的写入丢失，或者存在未确认的写入，我们知道系统在某种程度上是*不一致的*:客户端应用程序和数据库对系统的状态不一致。

在这一系列的博客文章中，我们将针对几个分布式数据库运行这个应用程序，并在运行过程中产生分区。在每种情况下，我们将看到系统如何对丢失消息的不确定性做出反应。

我已经用 Clojure 编写了这个工作负载的几个实现。`jepsen/src/jepsen/set_app.clj`定义应用程序。`(defprotocol SetApp ...)`列出一个应用程序必须实现的功能，`(run n apps)`设置应用程序并并行运行它们，收集结果，并显示任何不一致的地方。特定的实现存在于`src/jepsen/riak.clj`、`pg.clj,`redis . clj’等等。

你需要一个 JVM 和 [Leiningen 2](https://github.com/technomancy/leiningen) 来运行这段代码。一旦您安装了 lein，并将其添加到您的路径中，我们就可以开始了！

*接下来在[杰普森](http://aphyr.com/tags/jepsen)，我们来看看 [Postgresql 的事务协议](http://aphyr.com/posts/282-call-me-maybe-postgres)是如何处理网络故障的。**