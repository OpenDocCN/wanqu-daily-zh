# 开发者的生产力可以衡量吗？-堆栈溢出博客

> 原文：<https://stackoverflow.blog/2020/12/07/measuring-developer-productivity/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

定义和度量程序员的生产率是软件行业中的一个大白鲸。这是巨大投资的基础，是 [的](https://codeclimate.com/) [的价值](https://www.gitclear.com/)[主张，是众多](https://waydev.co/) [创业公司](https://www.pluralsight.com/product/flow)的价值[，也是工程经理或 CTO 工作描述中最难的部分之一。这也是所有经验层次的开发人员焦虑的来源:你怎么知道你做得够不够，不管是在工作时间内还是工作时间外？当你所做的一切都是无形的，你该如何衡量？完全可以衡量吗？在这篇文章中，我将讨论生产率测量的最大陷阱和一些做好它的方法。](https://waydev.co/)

在软件开发中，就像在其他领域一样，许多人认为生产率是以投入和产出来衡量的。在美国，全职开发人员每周工作 40 小时，平均年薪为 107，510 美元。工时和工资是可见的、容易量化的投入。然后，开发人员会重复生成软件特性、文档、部署和/或错误修复。这些是输出。如果开发人员像我们想象的他们正在编写的软件一样简单，那么提高他们的生产率应该像要求他们工作更多的时间或支付他们更高的工资一样简单。当然，这是童话。开发者和软件都不是这样工作的。

## 投入测量的问题

“工作时间”是几个用来代表工作表现的虚假指标之一。我首先提到它，因为这是一个经常未经检查的违约，阻力最小的路径。如果一家公司不有意避免这样做，它迟早会恶化成一个只有几个小时的环境。在远程工作司空见惯的疫情之外，只工作几个小时的环境的症状很容易识别。工作时间被认为是没有商量余地的，出现在办公室被认为是某人在工作的证明。任何试图提前几个小时离开办公室的人都会遭到敌意(有时像几根竖起的眉毛一样温和，有时更加厚颜无耻)。任何工作到深夜或周末来上班的人都被认为是高绩效者。这种“最后一个离开健身房”文化的激励是不幸的:开发人员被迫将越来越多的时间花在工作上，没有任何其他方式来展示他们的价值，并被诱使只关注他们的工作成果。随着时间的推移，工作场所变得越来越像一个每个人都在工作但却一事无成的地方。

问题并没有就此结束。如果我们假设所有的工作都是“积极的工作”——也就是说，所有的工作都代表朝着一个目标前进——那么我们就错了。在筋疲力尽、心烦意乱或生病时工作的开发人员往往熟悉“消极工作”的概念:工作做得太差，以至于必须在以后撤消或补偿，从而增加而不是减少剩余的工作量。软件开发是复杂、抽象、专注的工作，因此对开发人员的精神状态非常敏感。也就是说，有隐藏的输入在起作用:焦虑、抑郁、[倦怠](https://stackoverflow.blog/2020/01/13/avoiding-burnout-as-an-ambitious-developer/)、工作中的毒性、悲伤、微侵犯以及其他上百种在任何一天都会降低或逆转个人生产力的事情。如果公司文化要求一周接一周的长时间工作，甚至每天八小时，没有弹性或休假时间，开发人员将不可避免地花时间做消极的工作:他们[熬夜完成的工作会比他们早点回家完成的工作少。由于疲劳，他们第二天完成的任务也会更少。](https://hbr.org/2015/08/the-research-is-clear-long-hours-backfire-for-people-and-for-companies)

另一方面，只有几个小时的环境并不是最坏的情况。它有一个关于公平的幽灵:如果两个开发人员工作相同的时间，有一个明确的方面他们是平等的。他们似乎都没有偷懒，也没有做得超过他们应得的份额。如果他们的产量低于预期，至少他们投入了时间。“工作时间”度量标准不像某些度量标准那样明确地激励坏代码。因此，尽管这是一个糟糕的衡量标准，甚至在许多情况下与生产率相违背，但我们应该讨论更糟糕的衡量标准。

考虑软件开发的另一个明显的投入:钱。我曾开玩笑地向我的经理建议过一两次，生产率应该用工资来衡量，如果我的工资翻倍，我会写出世界级软件架构师水平的代码。当然，你直觉上知道这很可笑。付给某人更多的钱并不会立刻让他们更有效率(虽然，间接的，在有限的范围内，它可能会有所作为)。然而，在我看来，金钱和时间属于同一个范畴:不仅仅是投入，而是辅助性的，只能微弱地推动生产率。一个是由雇主给出的，另一个是由雇员给出的，但是这种交换是创建有用软件的附带过程。

长话短说，度量输入是一种有缺陷的技术，因为软件开发不是一个等式，代码不能由流水线来构建。所以我们来谈谈输出。

[![](img/435cd3192b88447502421073141292ff.png)](https://stackoverflow.com/teams/tour?utm_source=so-owned&utm_medium=house-ads&utm_campaign=biz-self-serve&utm_content=LB-1)

## 产出衡量的陷阱

这里，也许与直觉相反，我们发现了软件开发世界中许多最差的度量标准。众所周知，有些人陷入了一个思维陷阱，认为软件开发的工作输出是代码行或版本控制中的提交。当然，这些是过程的一部分，但它们更像是副产品而不是结果。严格来说，一行不解决问题的代码比根本没有代码更糟糕。因此，用开发人员贡献了多少代码来衡量他们的生产力，就像用他们产生了多少垃圾来衡量发电厂，或者用他们通过了多少法案来衡量国会；它与实际价值无关。

更糟糕的是，利用这些测量数据非常容易。一个按代码行获得报酬的开发人员可以轻松地在一天内赚到一整年的薪水，而不会创造任何商业价值。大多数开发人员将采用一种更微妙的方法，但同样，你应该小心你的愿望。

当一个度量成为目标时，它就不再是一个好的度量。
~古德哈特定律

总的来说，开发人员理解这一点——然而，令人尴尬的是，我们仍然倾向于使用提交和代码行作为众所周知的孔雀羽毛。当我们读到谷歌(指截至 2015 年的所有谷歌品牌产品)[跨越 20 多亿行代码](https://www.wired.com/2015/09/google-2-billion-lines-codeand-one-place/)，或者 Windows 团队每天[推送超过 8400 条代码](https://devblogs.microsoft.com/bharry/the-largest-git-repo-on-the-planet/)时，我们的眼睛都睁大了，尽管我们知道这两者都不是让谷歌或 Windows 有用的东西。有时社区甚至会产生这样的废话:

(顺便说一句，我祝贺这个人，他的贡献图是为了建立日常编码习惯，也是为了偶尔休息一天。就我而言，这两个都是积极的迹象，尽管在没有更深入地了解他们的贡献历史之前，我不会说这个人很有成效。)

在任何情况下，我们都可以将这些措施添加到无效代理的列表中。根据修复的错误、完成的任务或发布的功能来衡量生产率同样是徒劳的，如果这比游戏更难的话。如果目标是修复更多的错误，开发人员可以故意编写有错误的软件，然后编写过多的修复程序；或者，为了达到相反的目标，他们可以通过尽可能慢地编写特性来减少 bug 数量。如果目标是发布特性，他们可以快速而天真地编写它们，导致软件运行缓慢且几乎不起作用；如果目标是完成任务，整个团队可以融入政治，因为每个开发人员都在追逐最容易的(或最被高估的)任务。一个好的团队可能会忽略你的措施而继续工作，但是即使在最好的情况下，一个糟糕的措施也是一个难以忽视的障碍。

一些组织表现出严重的偏执，在员工的电脑上安装间谍软件，通过鼠标移动、按键和截屏等人工制品来跟踪他们每时每刻的工作细节。我不清楚在这种审查下，任何员工如何能进行创造性的工作。我预计大多数开发者会立即退出。但是和上面讨论的方法一样，这个方法最明显的缺点是它没有捕捉到任何对业务或客户真正有意义的东西。你会因为一个高效的开发人员在 Reddit 上花了很多时间或者移动鼠标不够多而惩罚他们吗？你会因为开发人员在 Visual Studio 中花费大量时间打字而提拔他们吗，即使他们很难共事？一些经理显然是这样做的，但希望我们大多数人比这更聪明。

## 以正确的水平衡量生产力

现在你已经被警告不要采取你可能会尝试使用的最糟糕的措施，让我们来谈谈一些好的措施。不幸的是，除了“这个团队成员做出了贡献”或“这个团队成员没有做出贡献”的二元状态之外，很少能够衡量个人绩效而且无法远距离测量。

一个软件开发团队不是一群单独工作的孤立的个体；每个团队成员的工作产出都是他们所有队友的工作产出的函数，更不用说一天中几次有意义的不可测量的互动了。个人工作的相互依赖和细微差别过于复杂，无法由外部观察者来衡量。例如，一些团队成员是团队其他成员的力量倍增器——他们自己可能完成不了很多事情，但是如果没有他们的帮助和影响，他们的队友的工作效率会大大降低。像这样的个人是有效的工程组织的秘密武器，但是他们的生产力不能在个人尺度上衡量。其他团队成员可能不会产生大量的功能，但会充当“代码看门人”，无论走到哪里，都要仔细地测试、清理和重构代码，以便他们的团队成员可以更快、更轻松地开发功能。他们作为个人的生产力也是无法衡量的，但是他们对团队生产力的影响是指数级的。即使对于定期发布新特性的程序员来说，生产力[在短期内](https://insights.sei.cmu.edu/sei_blog/2020/01/programmer-moneyball-challenging-the-myth-of-individual-programmer-productivity.html)也会有很大的变化，这抑制了追踪任何特性的努力。出于这样的原因，个人绩效最好留给个人贡献者自己和彼此来衡量。

另一方面，团队的表现要明显得多。也许追踪它的最好方式是问，*这个团队在几周到几个月的时间尺度上持续地生产有用的软件吗？*这呼应了[的第三个敏捷原则](https://agilemanifesto.org/principles.html):“频繁地交付工作软件，从几个星期到几个月，优先选择更短的时间尺度。”一个定期开发有用软件的团队是高效的。不这样做的团队应该被问为什么不这样做。缺乏生产力通常有合理的原因；大多数没有效率的团队都想变得有效率，而大多数有效率的团队都想变得更有效率。

团队生产力可以通过简单、全面的观察在组织范围内进行衡量。由于团队成员往往很清楚彼此的贡献(无论是否可以衡量)，任何个人生产力的严重失误都可以通过良好的组织习惯来发现，例如经理和他们的直接下属之间经常进行一对一的访谈；定期收集诚实的匿名反馈；并鼓励每个团队成员通过报告他们的成就和为他们的失败负责来行使个人责任。

这里有很多依赖于人，而不是趋势图和原始数据。这是软件不可回避的事实:它更多的是关于人类，而不是 1 和 0，并且一直如此。生产力跟踪工具和激励计划永远不会像工作场所的积极文化一样产生巨大的影响。当责任感和健康的沟通融入这种文化时，生产力的关键时刻将很快被最有能力解决这些问题的人看到。

许多组织使用速度作为他们团队生产力的首选度量，如果做得好，这可以成为理解软件开发过程的有用工具。速度是一个团队在一段时间内完成的任务*的总度量，通常考虑开发人员自己对每个任务相对复杂性的估计。它回答了诸如“这个团队在接下来的两周能做多少工作？”基本答案是“大约和他们在过去两周做的一样多”，而速度是这种说法的背景。这是一种计划措施，而不是追溯措施，任何试图对其附加激励的人都会发现，它的准确性在压力下蒸发了(关于这一点的更多信息，请参见罗恩·杰弗里斯的[](https://pragprog.com/titles/rjnsd/the-nature-of-software-development/)**)。理解一个团队、部门或公司的发展速度是你优先考虑功能开发、与客户设定期望以及规划产品未来的基础。***

 **没有比“任务乘以复杂性”更精细的有用度量了。像某些工具一样，度量提交、代码行数或编码时间在团队范围内并不比在个人范围内更有用。一个团队生产的代码工件的数量，或者他们在代码工件上花费的时间，和他们贡献的价值之间没有关系。

许多组织在没有任何硬性措施的情况下茁壮成长。在组织中，有用的软件被很好地理解为开发工作的目标和主要的(尽管很难量化)测量结果，并且输入相应地被降低优先级，这有着深远的影响。开发人员被解放出来，无论何时何地，只要他们最有效率，就能做最好的工作。这可能看起来像朝九晚五，也可能看起来不像。有些人出于偏好或需要，会在清晨和深夜完成大部分工作。其他人将断断续续地工作:这里一小时，那里几小时。有些人在家工作，有些人在办公室工作，有些人在路上工作。这是功能，不是 bug。它强调真正的生产力，而不是试图将其硬塞给一个可观察的启发式方法，它使工作场所对于更深层次的人才库变得可行，例如，包括在职父母和残疾人士。关于唯结果工作环境(ROWE)、远程工作、减少会议时间和弹性工作时间的好处，已经有很多文章和言论；所有这些都只是精明的生产率衡量标准的体现。

据说[你得到你测量的](https://hbr.org/2010/06/column-you-are-what-you-measure)。因此，你应该只衡量你真正想要的东西——它是否能被绘制成线图。对一些人来说，做或管理无法简化的工作是令人沮丧的。但是对于像软件开发这样细致和抽象的工作，我们越是在细节上固守自己，我们就越是无法实现自己的目标。有用的软件是我们的目标，我们不应该满足于(或衡量)任何不那么重要的东西。

标签:

[management](https://stackoverflow.blog/tag/management/)

,

[measurement](https://stackoverflow.blog/tag/measurement/)

,

[productivity](https://stackoverflow.blog/tag/productivity/)**