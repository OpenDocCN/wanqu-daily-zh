# 不要浪费时间写完美的代码

> 原文:[https://dzone.com/articles/dont-waste-time-writing?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://dzone.com/articles/dont-waste-time-writing?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

一个系统可以持续 5 年、10 年甚至 20 年甚至更长时间。但是特定代码行的生命周期，甚至是设计的生命周期，通常要短得多:当你通过不同的方法迭代一个解决方案时，可以是几个月、几天甚至几分钟。

## 有些代码比其他代码更重要

研究[代码如何随时间变化](http://www.youtube.com/watch?v=0eAhzJ_KM-Q)，Michael Feathers 发现了[代码基的幂曲线](http://swreflections.blogspot.ca/2012/10/bad-things-happen-to-good-code.html)。每个系统都有代码，通常是大量的代码，它们只写一次，永远不会改变。但是少量的代码，包括最重要和最有用的代码，被一遍又一遍地修改，被多次重构或重写。

随着您对系统、问题域或架构方法的经验越来越多，了解和预测什么代码会一直改变，什么代码永远不会改变应该变得越来越容易:什么代码重要，什么代码不重要。

## 我们应该努力写出完美的代码吗？

我们知道我们应该写[干净的代码](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)，尽可能一致、明显和简单的代码。

有些人走极端，强迫自己写出尽可能漂亮、优雅、接近 T2 完美的代码，[痴迷于重构，并为每个细节而苦恼。](http://programmers.stackexchange.com/questions/43506/is-it-bad-to-have-an-obsessive-refactoring-disorder)

但是如果代码只被编写一次，并且永远不会改变，或者在另一个极端，如果它一直在改变，那么编写完美的代码难道不像试图编写完美的需求或试图预先提出完美的设计一样浪费和不必要(并且不可能实现)吗？

> 你不可能写出完美的软件。疼吗？不应该。接受它作为生活的公理。拥抱它。庆祝一下。因为完美的软件不存在。在计算机的短暂历史中，没有人写过一个完美的软件。你不太可能是第一个。除非你接受这个事实，否则你会浪费时间和精力去追逐一个不可能的梦想。
> 安德鲁·亨特，[务实的程序员:从熟练工到大师](https://pragprog.com/the-pragmatic-programmer)

写一次的代码不需要漂亮优雅。必须是正确的。它必须是可理解的——因为从未改变的代码在系统的生命周期中仍可能被多次读取。它不一定要干净和紧密——只要足够干净就行。这段代码中的复制粘贴和其他快捷方式是允许的，至少在一定程度上是允许的。这是永远不需要打磨的代码。这是不需要重构的代码(除非你需要改变它)，即使它周围的其他代码在改变。这是不值得花费额外时间的代码。

你一直在修改的代码怎么办？纠结于样式并想出最优雅的解决方案是浪费时间，因为这些代码可能会在几天或几周内再次更改，甚至重写。同样，[在每次你做出改变的时候强迫性地重构](http://programmers.stackexchange.com/questions/43506/is-it-bad-to-have-an-obsessive-refactoring-disorder)代码，或者重构你没有改变的代码，因为它可以变得更好。代码总是可以变得更好。但那不重要。

重要的是:代码是否做了它应该做的事情——它是正确的、可用的和有效的吗？它能在不崩溃的情况下[处理错误和坏数据](http://swreflections.blogspot.com/2012/03/defensive-programming-being-just-enough.html)吗——或者至少[安全失败](https://buildsecurityin.us-cert.gov/articles/knowledge/principles/failing-securely)？容易调试吗？换起来容易安全吗？这些都不是美的主观方面。这些是决定成败的实际措施。

## 实用编码和重构

精益开发的核心思想是:不要在不重要的事情上浪费时间。这应该告诉我们如何编写代码，如何重构代码，如何审查代码，如何测试代码。

只有[重构你需要](http://swreflections.blogspot.com/2012/04/what-refactoring-is-and-what-it-isnt.html)的东西，才能完成工作——这就是[马丁·福勒](http://martinfowler.com/articles/workflowsOfRefactoring/)所说的机会性重构(理解、清理、[童子军规则](http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule)之类的东西)和预备性重构。足以让改变变得更容易、更安全，仅此而已。如果你不改变代码，它看起来像什么并不重要。

在代码审查中，只关注重要的事情。代码是否正确？是防御性的吗？安全吗？你能跟上吗？换了安全吗？

忘掉风格吧(除非风格妨碍了理解)。让您的 IDE 负责格式化。对于代码是否可以“更面向对象”没有争议。只要有意义，它是否恰当地遵循这个或那个模式并不重要。喜欢不喜欢都无所谓。你是否能以更好的方式完成并不重要——除非你正在教一个对平台和语言不熟悉的人，并且你被期望做一些指导作为代码审查的一部分。

编写重要的测试。覆盖主要路径和重要异常案例的测试。用最少的工作量给你最多信息和最大信心的测试。大规模的测试，或者小规模的集中测试都没关系，不管你是在编写代码之前还是之后编写测试，只要它们能完成工作就行。

## 这不仅仅是代码的问题

架构和工程隐喻对于软件来说从来都是无效的。我们不会设计和建造几年或几代人都一成不变的桥梁或摩天大楼。我们正在建造一些更加可塑、更加抽象、更加短暂的东西。代码是为被改变而写的——这就是它被称为“软件”的原因。

> 经过五年的使用和修改，一个成功的软件程序的源代码通常与它的原始形式完全不同，而一个五年后成功的构建实际上是原封不动的
> 凯文·泰特，[可持续软件开发](http://www.amazon.com/Sustainable-Software-Development-Agile-Perspective/dp/0321286081)

我们需要将代码视为我们工作的暂时产物:

> …有时在面对更重要的事情时，我们会盲目崇拜代码。我们经常有一种错觉，认为交付产品所产生的有价值的东西是代码，而实际上它可能是对问题领域的理解，设计难题的进展，甚至是客户的反馈。
> 丹·格罗弗，[代码与创造性破坏](http://dangrover.com/2013/07/16/code-and-creative-destruction/)

迭代开发教会我们实验和检查我们工作的结果——我们解决了问题吗，如果没有，我们学到了什么，我们如何改进？我们正在构建的软件永远不会完成。即使设计和代码是正确的，它们也可能只在一段时间内是正确的，直到环境要求它们再次被改变或者被更适合的东西所取代。

我们需要编写好的代码:可理解的、正确的、安全可靠的代码。我们需要重构和检查它，并编写好的有用的测试，同时知道这些代码中的一些，或者全部，可能很快就会被丢弃，或者可能永远不会被再次看到，或者可能根本不会被使用。我们需要认识到我们的一些工作必然会被浪费，并为此进行优化。做该做的事，别再做了。不要浪费时间去写完美的代码。