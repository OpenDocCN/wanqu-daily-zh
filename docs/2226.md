# 编写易于删除的代码，而不是易于删除的代码...—编程太可怕了

> 原文：<http://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>





# 写容易删除，不容易扩展的代码。



> “每一行代码都是毫无理由的写出来，出于软弱维护，偶然删除” *Jean-Paul Sartre 的 ANSI C 编程*

每写一行代码都要付出代价:维护。为了避免支付大量代码，我们构建可重用的软件。代码重用的问题是，它会妨碍你以后改变主意。

一个 API 的消费者越多，就必须重写越多的代码来引入变化。同样，你越依赖第三方 api，当它改变时你就越痛苦。管理代码如何组合在一起，或者哪些部分依赖于其他部分，是大规模系统中的一个重要问题，并且随着您的项目越来越老，这变得越来越困难。

> 我今天的观点是，如果我们希望计算代码的行数，我们不应该把它们视为“产生的行数”，而是“消耗的行数” *EWD 1036*

如果我们将“代码行”视为“花费的行”，那么当我们删除代码行时，我们就降低了维护成本。我们应该尝试构建一次性软件，而不是构建可重用的软件。

不用我说，删除代码比编写代码更有趣。

要编写易于删除的代码:重复自己以避免产生依赖，但不要重复自己来管理它们。将你的代码分层:用更容易实现但使用起来笨拙的部分构建简单易用的 API。分割你的代码:将难以编写和可能改变的部分与代码的其余部分隔离开来，并相互隔离。不要对每一个选择都进行硬编码，也许允许在运行时进行一些更改。不要试图同时做所有这些事情，也许一开始就不要写那么多代码。

# 步骤 0:不要写代码

代码行数本身并不能告诉我们太多，但是数量级可以告诉我们 50、500、5000、10000、25000 等等。一个百万行的庞然大物将会比一个万行的更烦人，而且要花费更多的时间、金钱和精力去替换。

尽管代码越多，就越难删除，但是保存一行代码本身并不能保存任何东西。

即便如此，最容易删除的代码是你一开始就避免编写的代码。

# 步骤 1:复制粘贴代码

通过代码库中的几个使用示例，构建可重用代码是一件事后诸葛亮的事情，而不是你以后可能需要的预见。从好的方面来说，你可能仅仅通过使用文件系统就重用了很多代码，为什么要这么担心呢？一点点冗余是健康的。

最好将代码复制粘贴几次，而不是创建一个库函数，只是为了掌握如何使用它。一旦你让某个东西成为共享的 API，你就很难改变它。

调用您的函数的代码将依赖于它背后的实现的有意和无意的行为。使用你的函数的程序员不会依赖你的文档，而是依赖他们的观察。

删除函数内部的代码比删除函数更简单。

# 第二步:不要复制粘贴代码

当你已经复制和粘贴了足够多的东西，也许是时候把它提升到一个函数了。这就是“把我从我的标准库中拯救出来”的东西:“打开一个配置文件，给我一个哈希表”，“删除这个目录”。这包括没有任何状态的函数，或者有一点全局知识的函数，比如环境变量。最终保存在一个名为“util”的文件中的东西。

旁白:创建一个`util`目录，将不同的实用程序保存在不同的文件中。一个单独的`util`文件将一直增长，直到它变得太大而难以分割。使用单一的`util`文件是不卫生的。

代码越不特定于您的应用程序或项目，它们就越容易重用，被更改或删除的可能性就越小。库代码，如日志、第三方 API、文件句柄或进程。其他不打算删除的代码的好例子有列表、哈希表和其他集合。不是因为它们通常有非常简单的接口，而是因为它们不会随着时间的推移而扩大范围。

我们没有让代码变得易于删除，而是试图让难以删除的部分尽可能远离易于删除的部分。

# 第三步:写更多的样板文件

尽管编写库是为了避免复制粘贴，但我们经常最终通过复制粘贴来编写更多的代码来使用它们，但我们给了它一个不同的名称:样板文件。Boiler plate 很像复制粘贴，但是您每次都在不同的地方更改一些代码，而不是一遍又一遍地更改相同的位。

像复制粘贴一样，我们复制部分代码以避免引入依赖性，获得灵活性，并为冗长付出代价。

需要样板文件的库通常是网络协议、网络格式或解析工具包之类的东西，很难将策略(程序应该做什么)和协议(程序可以做什么)交织在一起而不限制选项。这段代码很难删除:它通常是与另一台计算机对话或处理不同文件的要求，我们最不想做的事情就是在其中加入业务逻辑。

这不是一个代码重用的练习:我们试图让频繁变化的部分远离相对静态的部分。最小化库代码的依赖性或责任，即使我们不得不写样板文件来使用它。

你写了更多的代码行，但是你把这些代码行写在了容易删除的部分。

# 第四步:不要写样板

当图书馆被期望迎合所有人的口味时，样板文件工作得最好，但是有时有太多的重复。是时候用一个对策略、工作流和状态有意见的库来包装您的灵活库了。构建简单易用的 API 就是将样板文件转化为一个库。

这并不像您想象的那样不常见:最受欢迎和喜爱的 python http 客户端之一，`requests`是一个提供更简单接口的成功例子，它由更详细的底层库`urllib3`提供支持。`requests`在使用 http 时迎合常见的工作流，对用户隐藏了很多实用的细节。同时，`urllib3`执行流水线操作、连接管理，并且不对用户隐藏任何东西。

当我们将一个库包装到另一个库中时，我们并没有隐藏太多细节，而是将关注点分开:`requests`是关于流行的 http 冒险，`urllib3`是关于给你选择你自己的冒险的工具。

我并不提倡你去创建一个`/protocol/`和一个`/policy/`目录，但是你确实想试着让你的`util`目录摆脱业务逻辑，并且在更容易实现的库之上构建更容易使用的库。你不必写完一个库就开始写另一个。

包装第三方库通常也是好的，即使它们不符合协议。您可以构建一个适合您的代码的库，而不是在整个项目中锁定您的选择。构建一个易于使用的 API 和构建一个可扩展的 API 通常是相互矛盾的。

这种关注点的划分允许我们让一些用户高兴，而不会让其他用户觉得不可能。当你从一个好的 API 开始时，分层是最容易的，但是在一个坏的 API 之上写一个好的 API 是非常困难的。好的 API 是为使用它的程序员设计的，分层意识到我们不能同时取悦所有人。

分层不在于编写我们以后可以删除的代码，而是让难以删除的代码变得易于使用(不会被业务逻辑污染)。

# 第五步:写一大段代码

你已经复制粘贴了，重构了，分层了，组合了，但是代码最终还是要做一些事情。有时候，最好的办法就是放弃，写大量无用的代码来把剩下的部分组合在一起。

业务逻辑是以一系列永无止境的边缘案例和快速肮脏的攻击为特征的代码。这很好。我对此没意见。其他风格如“游戏代码”或“创始人代码”都是一样的:走捷径以节省大量时间。

原因？有时候，删除一个大错误比试图删除 18 个交错的小错误更容易。许多编程都是探索性的，犯几次错误并重复比认为第一次就做对更快。

更有趣或更有创造性的努力尤其如此。如果你正在写你的第一个游戏:不要写引擎。同样，不要在写应用之前先写 web 框架。第一次就去写个一塌糊涂。除非你有通灵能力，否则你不知道怎么把它分开。

Monorepos 是一个类似的权衡:你不知道如何提前分割你的代码，坦白地说，一个大的错误比 20 个紧密耦合的错误更容易部署。

当你知道什么代码将很快被放弃，删除，或者很容易被替换，你就可以走捷径。尤其是如果你制作一次性的客户网站，活动网页。任何你有一个模板并删除副本的地方，或者你填补框架留下的空白的地方。

我不是建议你把同一个烂泥球重复写十遍，完善你的错误。引用 Perlis 的话:“除了第一次，一切都应该自上而下地构建”。你应该每次都尝试犯新的错误，承担新的风险，并通过迭代慢慢积累。

成为一名专业的软件开发人员会积累很多遗憾和错误。你从成功中学不到任何东西。并不是你知道好代码是什么样子，而是坏代码的伤疤在你脑海里记忆犹新。

项目要么失败，要么最终成为遗留代码。失败比成功多。写十个大泥球，然后看看它能给你带来什么，比试着擦亮一坨屎要快得多。

删除所有代码比逐段删除更容易。

# 步骤 6:将你的代码分成几部分

大泥球最容易建造，但维护成本最高。看似简单的改变最终以一种特别的方式触及了代码库的几乎每一部分。以前容易整体删除的，现在已经不可能分段删除了。

同样，我们将代码分层以分离职责，从特定平台到特定领域，我们需要找到一种方法来梳理顶层的逻辑。

> [开始]列出困难的设计决策或可能改变的设计决策。每个模块都被设计成对其他模块隐藏这样的决定。 *D .帕纳斯*

我们不是将代码分解成具有共同功能的部分，而是将代码分解成与其他部分不共享的部分。我们将最令人沮丧的部分隔离开来，让它们彼此分开来写、维护或删除。

我们构建模块不是为了能够重用它们，而是为了能够改变它们。

不幸的是，有些问题比其他问题更加错综复杂，难以分开。虽然单一责任原则建议“每个模块只应处理一个难题”，但更重要的是“每个难题只由一个模块处理”

当一个模块做两件事时，通常是因为改变一部分需要改变另一部分。拥有一个简单接口的糟糕组件通常比两个需要仔细协调的组件更容易。

> 今天，我不打算进一步定义我所理解的包含在这个简写描述[“松散耦合”]中的各种材料，也许我永远无法明白地做到这一点。但我一看就知道，本案涉及的代码库不是那个。*斯科特大法官斯图尔特*

一个可以删除部分而不重写其他部分的系统通常被称为松耦合的，但是解释一个系统看起来像什么比首先如何构建它要容易得多。

即使硬编码一个变量*一次*也可以是松耦合的，或者在变量上使用命令行标志。松耦合是指能够在不改变太多代码的情况下改变想法。

例如，微软视窗有内部和外部的 API 就是为了这个目的。外部 API 与桌面程序的生命周期相关联，内部 API 与底层内核相关联。隐藏这些 API 给微软带来了灵活性，同时不会破坏太多软件。

HTTP 也有松耦合的例子:在 HTTP 服务器前面放一个缓存。将您的图像移动到 CDN，并更改它们的链接。两者都不会破坏浏览器。

HTTP 的错误代码是松耦合的另一个例子:跨 web 服务器的常见问题都有唯一的代码。当你得到一个 400 错误，再做一次会得到同样的结果。一辆 500 可能会变。因此，HTTP 客户端可以代表程序员处理许多错误。

当把失败分解成更小的部分时，必须考虑你的软件如何处理失败。这样做说起来容易做起来难。

> 我已经决定，不情愿地使用 L<sup>a</sup>T<sub>e</sub>x*在存在软件错误的情况下制造可靠的分布式系统。阿姆斯特朗，2003 年*

Erlang/OTP 在选择如何处理失败方面相对独特:监督树。大致来说，Erlang 系统中的每个进程都是由一个监管者启动和监控的。当一个进程遇到问题时，它就退出。当一个进程退出时，它被管理程序重新启动。

(这些监控器由引导进程启动，当监控器遇到故障时，它由引导进程重新启动)

关键思想是，快速失败和重启比处理错误更快。像这样的错误处理可能看起来违反直觉，通过在错误发生时放弃来获得可靠性，但是重新关闭和打开有抑制瞬时故障的诀窍。

错误处理和恢复最好在代码库的外层完成。这就是所谓的端到端原则。端到端原则认为，处理连接远端的故障比处理中间的任何地方都容易。如果你在里面有任何处理，你仍然要做最后的顶层检查。如果顶层的每一层都必须处理错误，那么为什么要在内部处理呢？

错误处理是将系统紧密结合在一起的众多方式之一。还有许多其他紧密耦合的例子，但是挑出一个设计糟糕的例子有点不公平。除了 IMAP。

在 IMAP 中，几乎每个操作都是一片雪花，有独特的选项和处理方式。错误处理是痛苦的:错误可能在另一个操作的结果中途出现。

IMAP 生成唯一的令牌来标识每封邮件，而不是 UUIDs。这些也可能在手术结果的中途改变。许多操作不是原子的。人们花了 25 年多的时间才找到一种可靠的方法，将电子邮件从一个文件夹转移到另一个文件夹。有一种特殊的 UTF-7 编码，也有一种独特的 base64 编码。

我没有瞎编。

相比之下，文件系统和数据库都是更好的远程存储例子。对于文件系统，您有一组固定的操作，但是您可以操作大量的对象。

尽管 SQL 看起来像一个比文件系统更广泛的接口，但它遵循相同的模式。集合上的许多操作，以及要操作的许多行。虽然您不能总是将一个数据库换成另一个数据库，但是与任何自制的查询语言相比，更容易找到使用 SQL 的数据库。

松散耦合的其他例子是其他具有中间件、过滤器和管道的系统。例如，Twitter 的 Finagle 为服务使用了一个公共 API，这使得通用超时处理、重试机制和身份验证检查可以毫不费力地添加到客户端和服务器代码中。

(我敢肯定，如果我不在这里提到 UNIX 管道，有人会抱怨我)

首先，我们对代码进行了分层，但现在其中一些层共享一个接口:一组带有各种实现的通用行为和操作。松散耦合的好例子通常是统一接口的例子。

一个健康的代码库不需要完全模块化。模块化让编写代码变得更有趣，就像乐高积木一样有趣，因为它们可以组合在一起。一个健康的代码库有一些冗长，一些冗余，移动部分之间有足够的距离，这样你就不会陷入其中。

松散耦合的代码不一定容易删除，但是它更容易替换，也更容易修改。

# 第七步:继续写代码

能够在不处理旧代码的情况下编写新代码，使得尝试新想法变得容易得多。这并不是说你应该写微服务而不是单片，但你的系统应该能够支持一个或两个实验，而你正在做什么。

功能标志是以后改变主意的一种方式。虽然特性标志被视为试验特性的方法，但是它们允许您在不重新部署软件的情况下部署更改。

谷歌 Chrome 是它们带来的好处的一个引人注目的例子。他们发现保持常规发布周期最困难的部分是合并长期特性分支所花费的时间。

通过能够在不重新编译的情况下打开和关闭新代码，可以在不影响现有代码的情况下将较大的更改分解为较小的合并。随着新特性更早地出现在同一代码库中，长时间运行的特性开发会影响代码的其他部分变得更加明显。

特性标志不仅仅是一个命令行开关，它还是一种从合并分支中分离特性发布，以及从部署代码中分离特性发布的方式。当推出新软件可能需要几小时、几天或几周的时间时，在运行时能够改变想法变得越来越重要。问问任何一个 SRE:任何能在晚上叫醒你的系统都是值得在运行时控制的。

与其说你在迭代，不如说你有一个反馈回路。与其说你是在构建可重用的模块，不如说你是在隔离组件以进行改变。应对变化不仅仅是开发新的功能，还要摆脱旧的功能。编写可扩展代码是希望在三个月的时间里，你把一切都做对了。编写可以删除的代码是基于相反的假设。

我谈到的策略——分层、隔离、公共接口、组合——不是关于编写好的软件，而是如何构建可以随时间变化的软件。

> 因此，管理问题不是要不要建立一个试点系统，然后把它扔掉。你会做到的。[……]因此计划扔掉一个；不管怎样，你会的。弗雷德·布鲁克斯

你不需要把它们都扔掉，但是你需要删除一些。好的代码不在于第一次就做对。好的代码只是不会碍事的遗留代码。

好的代码很容易删除。

* * *

# 承认

感谢我所有的校对人员付出的时间、耐心和努力。

# 进一步阅读

## 分层/分解

[关于将系统分解成模块所用的标准](https://href.li/?https://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf)，D.L. Parnas。

如何设计一个好的 API 以及为什么它很重要。

[API 设计小手册](https://href.li/?http://www4.in.tum.de/~blanchet/api-design.pdf)，J. Blanchette。

[人类的 Python](https://href.li/?https://www.youtube.com/watch?v=uqIx4VRIuwM)，K. Reitz。

# 通用接口

MH 邮件系统的设计，兰德公司的技术报告。

[分布式系统的 Styx 架构](https://href.li/?http://www.vitanuova.com/inferno/papers/styx.pdf)

[你的服务器作为一种功能](https://href.li/?http://monkey.org/~marius/funsrv.pdf)，M. Eriksen。

## 反馈循环/运营生命周期

[铬释放周期](https://href.li/?http://www.slideshare.net/Jolicloud/chrome-release-cycle)，A. Laforge。

为什么电脑会停下来，我们能做些什么？，j .格雷。

复杂系统是如何失败的？

## 技术在成为技术之前是社会的。

[所有的后期项目都是一样的](https://href.li/?http://www.systemsguild.com/pdfs/DeMarcoNov2011.pdf)，[软件工程:一个时代来了又去的想法？](https://href.li/?http://www.computer.org/cms/Computer.org/ComputingNow/homepage/mostread/MostRead-SW-SoftwareEngineeringAnIdeaWhoseTimeHasCome.pdf)，T. DeMarco。

[编程中的警句](https://href.li/?http://www.cs.yale.edu/homes/perlis-alan/quotes.html)，A. Perlis。

委员会是如何发明的？，M.E .康威。

无结构的暴政

## 我写过的关于软件的其他帖子。

(已于 2019-07-22 添加)

[重复自己，不止做一件事，重写一切。](https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and)

如何将一块巨石切成两半？

编写易于删除、易于调试的代码。

## 投稿翻译

T0 编写易于删除而非补充 T1 的代码。

Write codes that are easy to delete, not easy to expand [](https://href.li/?http://blog.yongfengzhang.com/cn/blog/write-code-that-is-easy-to-delete-not-easy-to/).

[写一个容易删除的代码，而不是容易扩展的代码](https://href.li/?https://harfangk.github.io/2016/10/30/write-code-that-is-easy-to-delete-not-easy-to-extend-ko.html)。

