# Gregory Szorc 的数字家庭|基于单片存储库

> 原文:[http://gregoryszorc . com/blog/2014/09/09/on-monolithic-repositories/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

当公司或组织部署版本控制时，他们必须做出许多选择。其中之一是要创建多少个存储库。你的选择本质上是 a)一个单一的、整体的存储库，包含所有的东西 b)许多独立的、较小的存储库，包含所有单独的部分 c)介于两者之间的东西。

当今流行的惯例(尤其是在开源领域)是创建许多独立的、松散耦合的存储库，每个存储库映射到一个特定的产品或服务。这看起来确实很合理:如果你在你的文件系统上组织文件，你应该按照功能或角色(照片、音乐、文档等)来分组。并且，版本控制工具在功能上是文件系统。因此，在目录/角色级别绘制存储库边界是有意义的。

我们的版本控制工具的伸缩行为进一步加强了独立存储库的约定。Git 是目前开源领域流行的工具，但它不能很好地扩展到非常大的存储库，原因之一是它没有窄克隆(获取文件的子集)。它对绝大多数项目都有足够好的伸缩性。但是如果您是一个为版本控制生成大量数据的大型组织(阅读:数十万个文件和提交的千兆字节数据), Git 的当前形式是不合适的。其他工具(如 Mercurial)目前并没有好到哪里去(尽管 Mercurial 计划解决这些扩展向量)。

尽管有流行的惯例，甚至工具上的限制，像谷歌和脸书这样的公司还是选择运行大型的整体式存储库。谷歌运行 Perforce。脸书正在使用 Mercurial ，或者至少正在向 Mercurial 迁移。

为什么这些公司运行整体式存储库？用谷歌的话说:

我们有一个大型仓库，里面存放着谷歌几乎所有的项目。这有助于敏捷开发，并深受我们用户的喜爱，因为它允许几乎任何人轻松地查看几乎任何代码，允许项目共享代码，并允许工程师在项目之间自由移动。文档和数据以及代码都存储在服务器上。

因此，整体式存储库是关于快速移动和更有效地完成工作的。换句话说，整体式存储库提高了开发人员的生产力。

此外，整体式存储库也更能适应大型组织和大型软件项目的兴衰。组件、特性、产品和团队来来去去，合并和分裂。唯一不变的是变化。如果您维护着试图映射到这种不断变化的组织拓扑的单独的存储库，您将会有一段糟糕的时间。要么您将不断地复制、移动、合并、拆分等数据和存储库。否则，您的存储库将会以一种非常不符合逻辑和不直观的方式进行组织。这转化为开销和生产力损失。我认为整体存储库更好地处理了大型组织的现实。你想反映的大变化或重组？你可以做一个单一的、原子的、保存历史的提交来移动事物。我认为这更容易管理，尤其是当您考虑跨存储库保存历史变更的困难和烦恼时。

反对者将基于原则和实践的理由谴责整体储存库。

有原则的阵营会说，独立的存储库构成了一个松散耦合的(我敢说是面向服务的)架构，它更好地映射了软件是如何被消费、组装和部署的，并且以独立存储库的形式建立障碍有意地加强了这个架构。我同意。然而，您仍然可以用整体式存储库维护一个松散耦合的架构。从更大的存储库中签出单个树*的 Subversion 模型证明了这一点。此外，我认为架构决策应该由人来执行(通过代码审查等)，而不是通过版本控制库拓扑来执行。我认为这种反对整体存储库的原则性论点是相当无力的。*

生活在开源领域的有原则的阵营也可能谴责整体式存储库是对开源精神的冒犯。他们会说，单一的存储库与操作它的组织建立了不公平的紧密联系，并为分叉设置了障碍，等等。这可能是真的。但是整体式存储库本质上并没有侵犯基本的软件自由，组织会。因此，我觉得这个原则性的论点相当薄弱。

实践阵营会说，整体式存储库无法扩展，或者不适合一般受众。这些担忧是真实的。

完全分布式版本控制系统(每台机器上的每次提交)绝对不会超过一定的限制。根据您的存储库和用户群，您的扩展限制包括磁盘空间(存储库数据兆兆字节大小)、带宽(存储库数据兆字节大小)、文件系统(存储库数十万或数百万个文件)、CPU 和内存(对大型存储库的操作占用太多系统资源)以及许多头/分支(像 Git 和 Mercurial 这样的工具不能很好地扩展到数万个头/分支)。完全分布式版本控制的这些限制是为什么像 Git 和 Mercurial 这样的分布式版本控制工具支持部分分布式模式的原因，这种模式的行为更像经典的服务器-客户端模型，就像 Subversion、Perforce 等使用的那些模型一样。Git 支持浅层克隆和稀疏校验。Mercurial 支持浅层克隆(通过 remotefilelog ),并计划在 2015 年底支持狭义克隆和稀疏校验。当然，您可以通过使用非分布式工具，比如 Subversion，来避免分布式版本控制的伸缩限制。许多公司今天仍然得出这个结论。然而，适应分布式工作流的用户可能会反对(他们可能会使用 hg-subversion 或 git-svn 等工具来维护他们的工作流)。因此，虽然版本控制的伸缩可能是一个真正的问题，但还是有解决方案和变通办法的。然而，它们确实涉及到退回到部分分布式模型。

整体存储库的另一个问题是用户访问控制。您不可避免地拥有更敏感的代码或数据，并希望限制谁可以更改甚至访问它们。独立的存储库似乎有助于一个更简单的模型:基于存储库的访问控制。对于整体存储库，您必须担心每个目录/子树的权限，增加数据泄漏的风险，等等。这种担心在分布式版本控制中更加真实，因为分布式数据和访问控制天生就不兼容。但是这些问题是可以解决的。如果工具支持的话，管理存储库之间的访问控制和管理单个存储库的组件之间只有语义上的区别。

说到存储库托管转换，我同意谷歌和脸书的观点:**我更喜欢整体存储库**。当我与版本控制交互时，我只想把事情做完。我不想浪费时间处理多个命令来管理多个存储库。我不想浪费时间或增加认知负荷来处理子模块、子存储或大文件管理。我不想浪费时间去寻找和重用代码、数据或文档。我希望所有的东西都在我的指尖，在那里可以很容易地被发现、检查和使用。整体存储库比单独的存储库更有利于这些工作流，结果使我更有效率。

现在，如果我们使用和喜爱的所有工具和过程都能够与整体式存储库一起工作，那该多好...

想了解更多关于整体式存储库的信息吗？我强烈推荐 Dan Luu 的[单片版本控制的优点](http://danluu.com/monorepo/)。