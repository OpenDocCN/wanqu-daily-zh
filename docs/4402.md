# Asana 如何创建一个优秀的开发环境

> 原文：<https://blog.asana.com/2017/07/developer-environment-making-it-reliable-by-making-it-fast-to-reset/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

我们都知道，当工程师可以完全定制他们的开发环境时，他们的工作效率最高，但是很多时候，定制意味着增加事情发生的次数。为了给我们所有的团队——IT、开发人员体验和工程等——提供最佳的开发人员环境，我们的团队在需要支持的一小组平台和高度定制化之间进行平衡。

今天，这意味着每个工程师都会收到一台 Mac，它的硬件按照他们的规格预先构建，用我们的默认编辑器(IntelliJ)预先配置，并在第一天收到一份完整的代码库副本，他们可以根据自己的需要自由配置和定制。虽然有些人谈到要清除整个操作系统，转而使用 Linux，但到目前为止，每个人都坚持使用 OS X。

除了文本编辑器和网络浏览器之类的标准工具，我们每个人还需要自己的 Asana 私人副本来开发。运行 Asana 的副本需要很多服务(我们使用 MySql、ElasticSearch、Zookeeper、Redis 等等)，以及 Asana 应用程序本身，它被设计为在 Linux 上运行。为了提供这些，每个开发者都有他们自己的“沙箱”——一个运行 Linux 的虚拟机。我们使用 ansible 脚本来安装和配置所有需要的服务，并使用 rsync 不断地从 Mac 复制代码更改。

### 头号工程师投诉:不起作用的沙箱

在我们做这里描述的工作之前，我们损失工程师生产力的最大来源是 Linux 沙箱的问题。这很痛苦，因为它经常坏，当它坏了，可能要花一天时间才能恢复工作。在崩溃的高峰期，一个团队几乎全职工作，疏通人们的沙盒问题。

沙盒崩溃的原因有很多。因为它们是一个有状态的系统，有几个数据库，所以即使是暂时的错误也会以令人困惑的方式存在和显现。在我们的例子中，构建规则的细微问题可能会导致沙箱产生不正确的构建输出，而那些陈旧或不正确的输出会一直存在。

人们也很难验证他们对沙盒配置所做的任何更改。因为人们在运行由不同版本的代码构建的沙箱，所以改变对一些工程师有用，但对其他人来说却破坏了一切。实际上，我们的沙箱包含了我们整个生产基础设施的一个小拷贝。虽然我们的生产基础设施有整个团队来管理，但我们的沙箱只由开发人员自己管理。

更让我们感到痛苦的是，当问题出现时，解决问题是困难的，因为每个沙盒都有微妙的不同。尽管我们团队中的大多数人都是构建 web 应用程序的专家，但他们并不是维护 linux 虚拟机的专家——所以当出现故障时，他们不知道该怎么办。

一个常见的选择是摧毁整个沙盒并重新开始，但这也很痛苦。没有办法验证配置更改，所以这经常会失败，因为我们的配置脚本会递增地工作，而不是从头开始。由于构建沙盒还需要下载和安装大量第三方软件，任何互联网故障都会导致该过程失败，经常出现令人困惑的错误。即使它们运行成功，这个过程也需要几个小时才能完成。

### 新方法

我们破碎的沙盒让我们付出了代价，包括生产力和快乐(Asana 雇佣了真正关心影响的工程师)，所以必须做点什么。我们的结论是，由于我们的沙箱本质上是生产环境的迷你版本，我们应该将管理生产系统的最佳实践应用于它们。

1.  **不可变的基础设施:**我们的许多痛苦都是由维护脚本引起的，这些脚本可以从头构建一个沙箱，并将更新应用到现有的沙箱。这是生产服务器的常见问题。一个很好的解决方案是切换到*不可变的基础设施*，这意味着一旦构建了系统，就永远不要对其进行配置更改。相反，如果系统配置需要更改，您可以使用新脚本从头构建一个新系统，并丢弃旧的系统。
2.  **机器是牛，不是宠物:**是什么让一些动物(比如牛)成为牛，而另一些动物(比如狗)成为宠物？一个病态的定义就是问它生病了会怎么样。如果它是一只宠物，你护理它恢复健康。如果是牛，你就对它实施安乐死。使用这个比喻，我们意识到我们一直把我们的沙盒当作宠物——当它们有问题时，护理它们恢复健康。这非常耗时，并且导致每个人的沙箱都略有不同。相反，如果沙盒重建很容易，那么我们可以删除一个沙盒，然后创建一个新的。
3.  从关键路径中移除缓慢且有风险的工作:正如我们已经讨论过的，创建沙箱所涉及的大部分工作都是缓慢且容易失败的。当一个人需要等待它成功时，这真的很痛苦。幸运的是，计算机非常擅长多次做同一件事。我们认为，创建沙盒的过程有点慢和不可靠是没问题的，只要这项工作是作为非交互式过程的一部分发生的——这意味着工程师不必等待它——并且每当该过程失败或花费太长时间时，它可以被放弃并重新开始。

### 我们做了什么来改善沙盒

在我们开始改进沙箱之前，我们已经做好了使用预配置映像的准备。我们所有的沙箱都已经在亚马逊网络服务的 [EC2](https://aws.amazon.com/ec2/) 实例上运行，这些实例是基于[亚马逊机器映像](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html) (AMIs)建立的。为了切换到使用预先配置的沙箱，我们只需要开始构建一个定制的 AMI，而不是使用一个基本的 Ubuntu AMI。

为了构建 AMI，我们使用了 [Packer](https://www.packer.io/) ，这给了我们一个构建定制 AMI 的简单方法。我们在我们的测试服务器 [Jenkins](https://jenkins.io/) 上设置了一个名为 *packer-sandbox* 的任务来完成以下任务:

1.  检查最新的代码版本
2.  运行封隔器模板，该模板:
    *   用基本 AMI 创建一个新机器
    *   调用我们所有现有的配置脚本
    *   基于结果创建新的 AMI
3.  将 AMI 复制到我们有沙箱的每个 AWS 区域

我们现在有了 ami，开发人员可以通过最少的配置来下载和使用。当开发人员想要一个全新的沙盒时，他们可以运行脚本来:

1.  删除他们的旧沙盒
2.  通过 packer-sandbox 从当前 AMI 构建中提供一个新的 EC2 映像
3.  个性化他们的沙箱(为他们的用户名设置一些环境变量)
4.  使用映像上的缓存重建我们所有的服务

很简单，对吧？

我们认为是的。这一变化意味着我们可以更快、更可靠地创建沙盒。现在，运行我们的配置脚本的缓慢且有风险的工作发生在 Jenkins——在那里，我们不在乎它是否需要一个小时，如果它失败了，一个有知识的开发人员可以在他们有机会的时候研究它，而不是一个随机的开发人员被它完全阻止。

### 我们如何让它变得*快*

即使我们这样做了，它仍然没有我们希望的那么快。这有几个原因:

1.  配置开发人员的本地机器(Mac)仍然很慢
2.  将文件同步到 EC2 机器上仍然很慢
3.  构建我们的服务可能会很慢

#### 1.配置开发人员的本地机器(Mac)仍然很慢

我们的沙盒设置脚本通常采取“用核武器摧毁一切以确保我们解决问题”的态度为此，他们会创建一个新的沙箱*和*在开发者的 Mac 上卸载和重装大量的包(使用 pip、brew 等)。).即使我们大大加快了沙盒的配置时间，Mac 配置仍然存在问题。

所以我们决定停止重新配置开发者的 MAC 电脑。我们发现，配置脚本通常会产生比它们解决的问题更多的问题，不运行它们可以节省大量时间，并提高虚拟机创建过程的可靠性。如果开发人员仍然愿意，他们可以手动运行这个本地配置脚本。

#### 2.将文件同步到 EC2 机器上仍然很慢

即使 AMI 包含我们所有的文件，我们仍然需要同步这些文件和每个开发人员机器上的文件之间的差异。此外，我们使用 rsync 来完成这项工作，它主要使用文件修改时间来决定源文件和目标文件是否相同。因为开发人员的苹果机检查出来了

因为开发人员的 MAC 在与创建沙盒映像不同的时间签出源代码，所以它们不会对齐，所以 rsync 必须比较每个文件的完整散列。

我们还没有修复 ry sync 速度慢的根本问题，但是一些分析显示，将同步文件打印到标准输出会严重增加时间，所以我们只是在初始 rsync 中关闭了它。

#### 3.构建我们的服务可能会很慢

除了同步已更改的文件，我们还必须基于这些更改重建所有服务。我们所有的新服务都使用 [Bazel](https://bazel.build/) ，它缓存构建输出，因此您只需做增量工作。也就是说，增量工作仅仅是当前代码和构建 AMI 的代码之间的差异。

为了确保这些尽可能相似，我们非常定期地运行 packer-sandbox 作业(每 12 小时一次)。这确保了 Bazel 的增量构建尽可能的小。

这也有一个很好的副作用，当打包沙盒崩溃时，我们有一个非常窄的提交范围可能会导致它。

### 后续步骤

当我们谈论这项工作时，一个常见的问题是，“你为什么不直接使用 Docker？”这里的答案是实用主义的——我们现有的脚本让我们有 80%的能力构建 AMI 映像。如果我们想构建 Docker 图像，我们必须完全重写它。

然而，目前的解决方案仍然是要么全有，要么全无。如果出现任何问题，整个沙箱都必须被删除并重新创建。我们很可能会慢慢地将不同的沙盒服务拆分成容器，这样，如果它们失败了，只需要重建那些服务，而不是整个映像。

我们还希望有一种更快的方式来重置整个沙盒——理想情况下不到 5 分钟。这方面的障碍是同步文件所需的时间，以及构建源代码所需的时间。

如上所述，当文件修改时间不一致时，rsync 非常慢(正如在不同时间完成的 git 签出一样)。我们认为我们可以通过使用 git 来确定哪些文件在沙箱创建和当前本地开发环境之间没有改变，并在同步之前强制未改变文件的时间戳匹配来改善这一点。

我们正在积极努力减少编译时间。我们最近向 Bazel 添加了一个远程缓存，由我们所有的开发人员和测试环境共享。由于我们的持续集成管道总是在构建我们代码的每一个分支，沙箱能够使用缓存的构建工件，这意味着只有开发人员自己在本地更改的文件才需要重新构建。我们还将编译器切换为 TypeScript 和 Scala 的 [Bazel 持久工作进程](https://blog.bazel.build/2015/12/10/java-workers.html)，这在构建时间上产生了很大的差异。未来看起来很快！