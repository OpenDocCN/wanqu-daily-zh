# 选择(语言)堆栈。这篇文章和这个实验是由尼克·戈登制作的

> 原文：<https://engineering.wework.com/choosing-a-language-stack-cac3726928f6?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

# 选择(语言)堆栈



Kotlin vs. Go vs. Ruby



这篇文章和实验是由迈克尔·法里纳奇(负载测试)、尼克·戈登(Ruby)、伊恩·麦金尼斯(科特林)和凯文·斯图尔(Go)合作完成的。

# 介绍

我们团队的任务是为 WeWork 构建下一代身份基础设施。随着 WeWork 及其兄弟企业的预期增长速度，这一新系统必须高效、全球分布、可扩展，并在未来几年随着需求的变化而合理发展。

基于这些挑战，团队认为值得投入时间来比较构建微服务的可用语言和软件堆栈。我们有三种候选语言:Go、Kotlin 和 Ruby。这种比较是通过在每个系统中构建相同的身份系统现实组件来进行的。我们选择了令牌制造服务，它在基于 OAuth2 的基础设施中生成不记名令牌，如刷新和访问令牌。每种语言在 WeWork 构建的其他系统中都有一些先例，并且每个实现都是由具有该语言经验的开发人员编写的。

完成这些实施后，团队通过以下定性和定量指标对其进行了比较:

*   代码可读性的定性比较。
*   在单元和集成测试级别，定性比较测试每个实现的简单程度。
*   每个实现中必需的“样板文件”与代表服务本质的代码的定性比较。
*   对每个堆栈可用的工具进行定性比较，如 ide、静态分析、调试器、分析器等。
*   每个实现的性能的定量比较，如往返时间百分比和主机资源利用率。

最终，像这样的实验不可能是完全科学的——软件工程受社会学因素的影响不亚于受科学和数学的影响。我们的目标主要是选择一个好的全能型语言和工具集，让团队在未来五年内能够轻松使用。

## 代币造币服务

本练习选择的服务是“令牌制造厂”，它生产三种类型的不记名令牌:刷新令牌、访问令牌和“动作”令牌。将令牌生产和验证隔离到它自己的服务中有助于隔离密钥的使用，这对系统范围的安全性至关重要。

此服务生成的刷新和访问令牌具有通常的 OAuth2 语义:刷新令牌不会过期，但可以被撤销，并用于生成 18 小时后过期的访问令牌。“动作”令牌是非标准添加；在单个外部 API 调用的上下文中，访问令牌被交换为动作令牌。我们将在 API 网关处使用请求拦截器(我们使用 [Kong](https://konghq.com/) )来执行这种交换，以帮助降低与意外或恶意令牌记录或不当下游服务泄漏相关的风险。

从任何其他系统或客户端的角度来看，生成的令牌值只是 url 安全的 ASCII 字符串。然而，它们确实有内部结构。它们是二进制[协议缓冲区](https://developers.google.com/protocol-buffers/docs/overview)的 Base64 编码，包含令牌元数据和数字签名。实验中使用的签名算法是 ECDSA，在 NIST P-256 曲线上。

该服务通过 gRPC 向身份系统的其他授权组件提供五种操作:

*   为指定用户创建刷新令牌
*   撤销刷新令牌
*   给定一个未撤销的刷新令牌，创建一个访问令牌
*   给定一个未过期的访问令牌，创建一个动作令牌
*   获取所提供令牌的信息

该服务非常简单，只需一名工程师就能在几周内实现，同时代表了我们必须构建的真实系统:

*   该服务必须与数据库进行交互，以存储它生成的令牌的信息，并记住哪些刷新令牌已被撤销。
*   该服务必须处理多个并发请求，并且能够进行扩展和分发，以每秒处理数千个请求。
*   作为一个安全敏感的服务，输入和输出必须仔细验证，并且小心使用密码原语是必要的。

这种性质的系统主要受 I/O 限制，通过网络执行数据库写入和查询。计算最密集的操作是数字签名的生成和验证。相比之下，令牌元数据和协议缓冲区的产生和验证在计算上是微不足道的。

# 负载测试

在 Go 中实现了一个负载测试客户端，使用了从服务定义中生成的 gRPC 客户端存根。负载测试人员模拟了与系统交互的用户群体，给出了预期使用模式的合理近似值。

对于一个用户，我们可以预期(平均)每六个月一次刷新令牌请求，每天一次访问令牌请求，每小时一次操作令牌请求。将这些假设与模拟的群体大小 *p* 相结合，产生了对系统平均负载的估计: *l(p) = p × 2.894 × 10⁻⁴* 每秒请求，其中 95%的请求是动作令牌请求。给定 100，000 个用户，负载测试器每秒将生成大约 29 个令牌请求。通过调整模拟的群体大小，和/或并行运行多个负载测试过程(如果需要，在不同的机器上)，服务上的负载得到了调整。

负载测试客户端记录了每个请求的往返时间(以微秒计),以及发生的任何错误。这些信息随后被用于生成请求散点图、直方图和其他统计数据。当服务的平均延迟和/或第 90 个百分点开始显著攀升时，我们可以判断服务何时开始达到其扩展限制，这通常表明某种形式的资源匮乏。

## 负载测试结果

数据库在大约 150 万人时开始限制吞吐量，我们在 100 万人时比较了实现的性能。在这一群体规模下，负载测试客户端试图平均每秒生成 289.4 个请求。最有趣的统计数据是:



Load Testing Performance Numbers (Population of 1.0 million)



在这里，我们可以看到每个实现都提供了非常相似的中值响应时间，在几分之一毫秒之内。然而，Kotlin 实现开始表现出明显更差的 95%和 99%延迟；我们推测这可能是由于在网络、协程执行和实现所使用的 JDBC 查询线程池之间传递数据时所涉及的上下文切换。这种上下文切换在 Go 和 Ruby 实现中都是不必要的。同样清楚的是，Go 在三个实现中需要最少的计算时间来处理所提供的负载。Ruby 的 CPU 使用统计数据可能有点误导，因为产生的错误(约 3%的请求)对 CPU 使用的影响很小:请求在任何实际处理之前就被拒绝了。

## 负载测试结论

尽管我们可能有先入为主的想法，但很明显，每个堆栈都完全有能力实现对性能敏感的服务。每一个实现，在适度的硬件上有一个单独的容器，能够处理我们不期望在 2021 年之前在 WeWork 上看到的人口规模，并且可能通过我们的数据库使用模式的一些优化处理更多。

Ruby 将本机代码用于实现中计算最密集的部分，这意味着它的解释性质几乎不引人注意；只是 Ruby gRPC 实现的质量让它失望了。Go 实现似乎是三个实现中最高效的，并且随着我们增加服务负载，它具有最可预测的性能特征。

所有这三个实现都有可能被进一步优化——这些负载测试结果是在没有具体尝试分析或改进实现性能的情况下产生的。就目前的实现情况来看，Go 略有优势。JVM 有最好的分析工具和最多的配置选项来提高运行系统的性能，但是这种优化是脆弱的；最好将时间投入到架构级别的性能优化上。

总的来说，我们得出了一个老生常谈的结论:性能与方法的选择比与语言的选择关系更大。了解其细微差别的熟练工程师几乎可以在任何堆栈中实现良好的性能。

# 获胜者是…

**Go** ，由团队的多数票决定。科特林第二，鲁比第三。该团队认为 Go 是更好的技术选择，原因如下:

*   一种更简单的语言自然会约束程序员使用更简单的代码，这将使日常审查和维护变得更容易。我们需要关于工具选择和架构的强有力的建议，以确保这扩展到更高层次的关注点——如果不注意代码是如何组成的，总体来说，更简单的代码可能更难理解。
*   使用 Go，开发生命周期通常更简单——在开发机器上直接运行服务、在容器中运行服务以及运行服务的集群实例之间几乎没有区别。为 Go 微服务生产的容器非常紧凑，因为除了 POSIX OS 接口之外，Go 二进制文件基本上没有外部需求。
*   Go 提供了比其他语言稍微好一点的性能，而且没有什么麻烦。它内置的异步处理机制和相关的库似乎使它更适合我们可能在核心平台组中编写的微服务类型。

这一选择带有强烈的警告，即我们必须在以下方面提供规则或建议:

*   依赖性管理。一旦准备就绪，我们很可能会为此采用 [go 模块](https://github.com/golang/go/wiki/Modules)。
*   错误传播和处理——这是该语言众所周知的弱点，我们必须为此定义一个可行的方法。
*   Channel 和 goroutine 的用法——初学者可能会对此感到困惑。然而，它并不比 EcmaScript 或 ReactiveX 模式中的 async/await 差；这正迅速成为软件工程实践的一个正常部分。

# 实施细节

以下部分深入讨论了每种实现，并具体讨论了每种实现的各种利弊。

# 评估科特林

Kotlin 是一种静态类型的对象函数语言，由 [JetBrains](https://www.jetbrains.com/) 设计，于 2011 年首次发布。它主要被编译成 [JVM 字节码](https://kotlinlang.org/docs/reference/server-overview.html)，但是对编译原生二进制文件(通过 [LLVM](https://kotlinlang.org/docs/reference/native-overview.html) )和转换成 [Javascript](https://kotlinlang.org/docs/reference/js-overview.html) 有实验支持。

我们认为 Kotlin 是 Java 更灵活、更简洁的替代方案，也是 Scala 更简单的替代方案。它在 Android 生态系统中的受欢迎程度迅速增长，现在它作为 Android 应用程序和库的一等公民受到谷歌的支持。

## 实施说明

在 Kotlin 实现中做出了三个关键决策，这对最终代码的结构以及性能都有很大的影响:

*   代码中避免使用框架，除了由 gRPC-java 本身引入的类似框架的元素。这项服务非常简单，我们觉得像 [Spring Boot](https://spring.io/projects/spring-boot) 、[拉贡](https://www.lagomframework.com/)或 [Vert.x](https://vertx.io/) 这样的框架除了混淆实现之外没什么作用，特别是对于那些不熟悉 Kotlin 或 JVM 的人来说。因此，与使用框架相比，初始化逻辑和与数据库的交互更加清晰。
*   Arrow 函数式编程库被广泛用于促进大功能风格。特别是[任一类型](https://arrow-kt.io/docs/datatypes/either/)被普遍使用，而不是抛出错误异常。这给了代码一种类似 Go 的感觉，在方法调用上有明确的错误检查，尽管 Arrow 的[单子理解](https://arrow-kt.io/docs/patterns/monad_comprehensions/)或[平面图](https://arrow-kt.io/docs/typeclasses/monad/#kindf-aflatmap)链接被用来使这比等价的命令式 Go 代码对可读性的破坏更小。
*   协同程序与 [async/await](https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions) 结合使用，试图简化代码的并发和异步部分。

## 优点

Kotlin 是一种优秀的多面手语言:在语言上，它与 Ruby 的表现力相匹配，同时保留了强大的静态类型安全性。它的语言特性允许比 Java 更紧凑、更有表现力的代码，而不会过分坚持 OOP / FP 二分法。这种语言灵活性特别适合于构建特定领域的抽象来帮助解决问题。这也是 Ruby 的一个核心优势，也可以说是 Go 的一个核心弱点。

扩展方法是一个很好的特性，有助于提高代码的可读性。通过使用扩展方法，可以很容易地将通过方法链接的“流畅”编程风格添加到现有类型中，我们在实现协议缓冲区消息的生成器和验证器时很好地利用了扩展方法。

与 JVM 库、工具和框架的直接互操作也是一个核心优势:Java 程序员可以在几分钟内开始使用 Kotlin，即使他们没有调整自己的编程风格以包含函数模式，他们也可以看到有意义的生产率提高。Kotlin 有一个优秀的 IDE 也不足为奇，因为它来自 JetBrains。

## 棘手问题

虽然在 Kotlin 中，灵活、实用的函数式编程方法是一个独特的优势，但它也可以被视为一个弱点:很容易被函数式风格冲昏头脑，最终得到难以阅读的代码。这发生在我们使用 Arrow 库太深入的实现中——虽然等效的命令式代码可能更长，但它可能更容易理解，更少细微差别。

作为一种相对较新的语言，它为程序员提供了各种各样的语言工具，但还没有使用这种语言的成熟的最佳实践。结果，这种*将*导致项目、团队和个人之间大相径庭的编码风格和解决问题的方法。相比之下，Go 和 Ruby 有更多的惯用法。

在使用 Kotlin 协程时发现了一些尴尬的问题，kot Lin 协程仍然是该语言的实验部分。特别是，用 Arrow 的任一类型单子理解来组成协程是困难的。Arrow 的[either](https://arrow-kt.io/docs/datatypes/eithert/)monad transformer 有所帮助，但对于外行人来说有点[魔法](https://en.wikipedia.org/wiki/Clarke%27s_three_laws)。

一些核心的 Java APIs 已经开始过时，不适合当代的异步编程。JDBC 就是一个典型的例子:像获取数据库连接和分发查询这样的操作会阻塞操作。在 JDBC 的异步继任者[可用之前，JDBC 调用必须通过单独的线程池进行，以避免阻塞协程线程。](http://www.oracle.com/technetwork/database/application-development/jdbc/con1491-3961036.pdf)

# 评估 Go

Go 是一种静态类型的命令式语言，由 Google 于 2009 年首次发布。T2 的动机是为了解决谷歌的大规模软件工程问题，通常编译成静态链接的本地二进制文件。

我们认为 Go 是 C/C++的当代替代品，它保留了语言的简单性，同时提供了内置的基本功能，如垃圾收集和异步编程原语。Go 正在被许多工程组织用于后端系统，包括优步、Slack、Dropbox 和 Twitch。

## 实施说明

我们使用 go grpc 框架，利用[go-grpc-中间件](https://github.com/grpc-ecosystem/go-grpc-middleware)，为[处理混乱](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/master/recovery)、[打开跟踪](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/master/tracing/opentracing)和[请求属性验证](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/master/validator)处理我们的公共基础设施模式。这产生了一个清晰的公共服务器模式，我们可以在我们的微服务中重用它。

对于我们的库，我们采用了带有智能默认值的功能选项模式，这是受[戴夫·切尼的博客文章](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)和 gRPC 的启发。

## 优点

“我们选择 Go 的原因”一节介绍了优势，以及其他一些原因:

*   并发原则是内置的。Channels 和 goroutines 使并发应用程序的可读性更好。
*   自动格式化。我们不必讨论制表符和空格:)
*   [godoc](https://godoc.org/golang.org/x/tools/cmd/godoc) 。文档是作为 go 工具的标准内置的

## 实施难点

对于实现来说，遇到的最大工具难点是使用[go-SQL lock](https://github.com/DATA-DOG/go-sqlmock)的数据库单元测试。最初，SQL 语句是为 MYSQL 风格 vs Postgres 编写的，直到集成测试运行时才被发现。另一种方法可能是使用一个使用 postgres 协议的内存 db 数据库。

Go 中的错误可以说是太简单了，错误检查似乎很乏味，并且代表了代码的很大一部分。这导致团队提出他们自己的错误类型或策略。

依赖性管理工具的碎片化导致了采用哪种工具的困惑。Go 模块最近在 Go 1.11 中发布，所以这个问题可能会完全解决。

# 评估 Ruby

Ruby 是一种动态类型的、面向对象的、解释型脚本语言。1995 年松本由 Yukihiro "Matz" Matsumoto 首次发布，直到今天，他仍然大量参与了该语言的设计。Ruby 的解释器是用 C 和 Ruby 混合编写的，包(称为“gems”)能够包含本机扩展，如 C、C++或 Rust。

我们认为 Ruby 是更灵活的动态类型语言之一，公司在这方面有大量的经验。WeWork 的大部分应用(截至 2018 年 6 月)都是用 Ruby 编写的，主要使用 Ruby on Rails。

## 实施说明

Ruby 实现中没有使用框架，但是代码是以 Ruby on Rails 开发人员熟悉的方式组织的(模型、控制器、服务等)。).由于数据模型的简单性，围绕 [pg gem](https://github.com/ged/ruby-pg) 编写了一个简单的包装器，而不是使用 [activerecord](https://www.rubydoc.info/gems/activerecord/5.2.1) 或其他 DAO/ORM 库。

我们使用 BigCommerce 编写的 [gruf](https://github.com/bigcommerce/gruf/) 来管理 gRPC 请求。它抽象出了与管理 GRPC 服务器相关的大部分样板级问题，同时仍然公开底层配置(如果需要的话)。

## 多线程/水平缩放

异步纯粹是在服务器级处理的——从控制器到数据库调用，每个请求都在自己的线程中运行。解释器有一个全局锁，因此在应用程序级别的 Ruby 代码中，更复杂的线程通常不是惯用的。这可能导致替代实现更容易水平扩展。

Docker 映像明显更大(使用 alpine 的可比部署映像的大小仍然是 Kotlin 或 Go 容器的 2.5 倍)，但在大多数部署中这并不是一个巨大的差异，因为只有编排的初始拉动会处理网络时间。

Ruby gRPC 服务器(使用官方库)不排队请求(自从[这个 pr](https://github.com/grpc/grpc/pull/8632) 合并以来)，这意味着在重负载下它会拒绝很多传入的请求。

## 优点

作为测试套件的一部分，集成测试被编写成易于打包为套件的其他实现的验收测试套件。RSpec 得到了很好的支持，并且很容易扩展，同时对于非 ruby 开发人员来说也会产生可读的错误。

虽然这个项目中的数据库逻辑足够简单，作者认为没有必要做比基本的 Ruby postgres gem 更复杂的事情，但是更复杂的数据库项目可以转而使用 [ActiveRecord](https://github.com/rails/rails/tree/master/activerecord) 并利用使 Rails 如此强大的 ORM。

虽然在撰写本文时 OpenTracing 还没有添加到项目中，但是添加 NewRelic 跟踪和监视需要添加一个简单的 Gruf 拦截器。还添加了额外的工具来进行微调，并且只需要对代码进行最小的更改。

## 棘手问题

这个项目的大部分消息内容都是关于字节和加密的。

将 UUIDs 作为字节处理并不难做到，但这不是一等公民。这需要编写一些助手方法，这些方法很容易编写，但是在这样的项目环境中是一个额外的开销。

Ruby 中的加密通常是通过系统库来完成的( [Ruby NaCl](https://github.com/crypto-rb/rbnacl) 或 [OpenSSL](https://ruby-doc.org/stdlib-2.5.1/libdoc/openssl/rdoc/OpenSSL.html) )，但是这个项目特别指定了 Tink。由于 Tink 没有在 Ruby 中实现(在本文发表时只有 C++、Java 和 Go)，所以需要多个导入和处理程序来匹配其他实现。

在撰写本文时，ruby 生成的代码的语法中的一个主要难点已经得到了解决: *ruby_package* 现在可以用来动态声明名称空间，这使得 Ruby 代码更加习惯化([发布](https://github.com/google/protobuf/releases/tag/v3.6.0)和 [gRPC pr](https://github.com/grpc/grpc/pull/16014) )。

有兴趣加入我们的团队吗？WeWork 正在特拉维夫、纽约和旧金山招聘软件工程师。 [*查看开口*](https://boards.greenhouse.io/weworkglobalit)