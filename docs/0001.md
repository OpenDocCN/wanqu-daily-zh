# StackOverflow 更新:每月 5.6 亿的页面浏览量，25 台服务器，一切都是为了性能——高可扩展性——

> 原文:[http://high scalability . com/blog/2014/7/21/stack overflow-update-560m-pageviews-a-month-25-servers-and-I . html？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://highscalability.com/blog/2014/7/21/stackoverflow-update-560m-pageviews-a-month-25-servers-and-i.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

![](../Images/85ffbec924f9896a08e0740e47a435dc.png)

Stack Overflow 的人对他们在做什么和为什么做仍然非常开放。所以又到了[更新](http://highscalability.com/blog/2011/10/24/stackexchange-architecture-updates-running-smoothly-amazon-4.html)的时候了。堆栈溢出是怎么回事？

组成 stack exchange 的网站网络，包括 StackOverflow，目前在世界流量排名中位列第 54 位；他们有 110 个站点，并以每月 3 到 4 个的速度增长；400 万用户；4000 万回答；以及每月 5.6 亿的浏览量。

这是在只有 25 台服务器的情况下。为了一切。那就是高可用性、负载平衡、缓存、数据库、搜索和实用功能。都只有相对少数的员工。这就是质量工程。

此次更新基于马尔科·塞科尼的 StackOverflow 架构(视频)和尼克·克雷文的 Stack Overflow 架构(视频)。此外，我还融合了各种来源的评论。毫无疑问，一些细节已经过时了，因为我很久以前就打算写这篇文章，但它仍然应该是有代表性的。

栈溢出还是用微软的产品。微软的基础设施是可行的，而且足够便宜，所以没有令人信服的理由去改变。然而，务实也是如此。他们在有意义的地方使用 Linux。没有纯粹的推动力去把所有东西都做成 Linux 或者保留所有微软的东西。那不会有效率。

堆栈溢出仍然使用纵向扩展策略。站点中没有云。由于他们的 SQL 服务器装载了 384 GB 的内存和 2TB 的固态硬盘，AWS 将会花费一大笔钱。云还会降低它们的速度，增加优化和解决系统问题的难度。另外，SO 不需要水平扩展策略。在大峰值负载的情况下，向外扩展是有意义的，这并不是一个问题，因为他们在正确调整系统规模方面非常成功。

因此，杰夫·阿特伍德的名言:“硬件很便宜，程序员很贵”，似乎仍然是该公司的生活传说。

Marco Ceccon 在他的演讲中说，当谈到建筑时，你需要首先回答这个问题:什么样的问题正在被解决？

首先是简单的部分。StackExchange 是做什么的？它收集主题，围绕主题创建社区，并创建非常棒的问答网站。

第二部分与规模有关。正如我们将在下一个 StackExchange 中看到的那样，它发展得非常快，处理着大量的流量。它是怎么做到的？让我们来看看…

## 统计数据

*   StackExchange network 拥有 110 个站点，每月增长 3 到 4 个。

*   400 万用户

*   八百万个问题

*   四千万个答案

*   作为全球流量排名第 54 位的网站

*   同比增长 100%

*   一个月 5.6 亿的浏览量

*   在大多数工作日，峰值更像是 2600-3000 请求/秒。编程作为一种职业，意味着工作日明显比周末忙。

*   25 台服务器

*   2 TB 的 SQL 数据全部存储在固态硬盘上

*   每个 web 服务器在一个 RAID 1 中有 2 个 320GB 固态硬盘。

*   每个 ElasticSearch box 有 300 GB 也使用固态硬盘。

*   堆栈溢出的读写比为 40:60。

*   数据库服务器的平均 CPU 利用率为 10%

*   11 台网络服务器，使用 IIS

*   2 个负载平衡器，1 个活动，使用 HAProxy

*   4 个活动数据库节点，使用 MS SQL

*   3 个应用服务器实现了标签引擎，通过标签命中进行搜索

*   3 台使用 ElasticSearch 进行搜索的机器

*   2 台使用 Redis 进行分布式缓存和消息传递的机器

*   2 个网络(每个都是 Nexus 5596 +结构扩展器)

*   2 个思科 5525-X asa(想想防火墙)

*   2 台思科 3945 路由器

*   2 个只读 SQL 服务器，主要用于堆栈交换 API

*   虚拟机还执行部署、域控制器、监控、系统管理员操作数据库等功能。

## 平台

## UI

*   用户界面有消息收件箱，当你得到一个新徽章，收到一条消息，重大事件等时，收件箱会收到一条消息。使用 WebSockets 完成，由 redis 提供支持。

*   搜索框由 ElasticSearch 使用 REST 接口提供支持。

*   有这么多问题，所以不可能只显示最新的问题，它们会变化太快，每秒一个问题。开发了一种算法来观察你的行为模式，并显示你对哪些问题最感兴趣。它使用基于标签的复杂查询，这就是为什么开发了专门的标签引擎。

*   服务器端模板用于生成页面。

## 服务器

*   这 25 台服务器并没有做太多事情，也就是说 CPU 负载很低。它被设计成只能在 5 台服务器上运行。

*   数据库服务器为 10%，除非它在执行备份时爆发。

*   怎么这么低？数据库服务器有 384GB 的内存，web 服务器的 CPU 使用率为 10%-15%。

*   扩大规模仍在发挥作用。其他具有相似浏览量的横向扩展网站倾向于在 100、200 甚至 300 台服务器上运行。

*   简单系统。建立在. Net 上。只有 9 个项目，其他系统有 100 个。项目如此之少的原因是因为编译非常快，这需要在开始时就进行规划。在单台计算机上编译需要 10 秒钟。

*   110K 行代码。考虑到它的作用，这个数字很小。

*   这种极简主义的方法带来了一些问题。一个问题是测试不多。测试是不需要的，因为有一个伟大的社区。Meta.stackoverflow 是社区的一个讨论站点，也是报告错误的地方。Meta.stackoverflow 也是新软件的测试网站。如果用户发现任何问题，他们会报告他们发现的错误，有时是解决方案/补丁。

*   Windows 2012 在纽约州使用，但正在升级到 2012 R2(俄勒冈州已经开始使用)。对于 Linux 系统，它是 Centos 6.4。

*   负载实际上几乎遍布 9 台服务器，因为 10 和 11 只用于 meta.stackexchange.com、meta.stackoverflow.com 和开发层。这些服务器还运行大约 10-20%的 CPU，这意味着我们有相当多的可用空间。

## 固态硬盘

*   英特尔 330 作为默认配置(web 层等。)

*   面向中间层的英特尔 520 支持弹性搜索

*   面向数据库层的英特尔 710 和 S3700。S3700 只是高耐久性 710 系列的继任者。

*   专用 RAID 1 或 RAID 10 (10 是任何包含 4 个以上驱动器的阵列)。故障不是问题，即使生产了数百个英特尔 2.5 英寸固态硬盘，也没有一个出现故障。每个型号都有一个或多个备件，但多个驱动器故障并不是问题。

*   ElasticSearch 在固态硬盘上的表现要好得多，因为写入/重建索引非常频繁。

*   SSD [改变搜索](http://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow/#comment-1201059884)的用途。由于锁定问题，Lucene.net 无法处理 SO 的并发工作负载，所以他们转向了 ElasticSearch。事实证明，在全 SSD 环境中，二进制读取器周围的锁真的没有必要。

*   到目前为止，唯一的扩展问题是 SQL 盒子上的 SSD 空间，这是由于可靠性与非消费者空间中的空间相比的增长模式，即具有用于掉电等的电容器的驱动器。

## 高可用性

*   主数据中心位于纽约，备份数据中心位于俄勒冈州。

*   Redis 有 2 个从服务器，SQL 有 2 个副本，tag engine 有 3 个节点，elastic 有 3 个节点——任何其他服务也具有高可用性(并且存在于两个数据中心中)。

*   并不是所有的东西都在数据中心之间(非常临时的缓存数据，不需要通过同步来消耗带宽，等等。)但大件物品是这样，所以在活动数据中心发生故障的情况下，仍然有一个共享缓存。没有缓存的启动是可能的，但这不是很好。

*   Nginx 用于 SSL，但是已经过渡到使用 HAProxy 来终止 SSL。

*   发送的总 HTTP 流量仅占发送的总流量的 77%左右。这是因为俄勒冈州的辅助数据中心以及其他 VPN 流量正在进行复制。这种流量的主要部分是到俄勒冈州的 SQL 副本和 redis 从属服务器的数据复制。

## 数据库

*   MS SQL Server。

*   堆栈交换每个站点有一个数据库，因此堆栈溢出有一个，超级用户有一个，服务器故障有一个，依此类推。这些的模式是相同的。这种拥有不同数据库的方法实际上是一种分区和水平扩展的形式。

*   在主数据中心(纽约)，每个集群中通常有一个主服务器和一个只读副本服务器。在灾难恢复数据中心(俄勒冈州)还有一个只读副本(异步)。当在俄勒冈州运行时，主副本在那里，两个纽约副本都是只读和异步的。

*   有一些皱纹。有一个“网络范围”的数据库，其中包含登录凭证和聚合数据(主要通过 stackexchange.com 用户配置文件或 API 公开)。

*   职业堆栈溢出、stackexchange.com 和 51 区都有自己独特的数据库模式。

*   所有架构更改同时应用于所有站点数据库。它们需要向后兼容，例如，如果你需要重命名一列——最坏的情况——这是一个多步骤的过程:添加一个新列，添加适用于两列的代码，回填新列，更改代码使其仅适用于新列，删除旧列。

*   不需要分区。索引处理了所有的事情，但是数据还是不够大。如果某些东西需要过滤索引，为什么不让它更有效呢？只对 DeletionDate = Null 进行索引，这是一种常见的模式，其他的是枚举中特定的 FK 类型。

*   投票在每个项目的 1 个表格中，例如 1 个表格用于帖子投票，1 个表格用于评论投票。我们实时渲染大多数页面，只为匿名用户缓存。鉴于此，没有要更新的缓存，它只是一个重新查询。

*   分数是非规格化的，所以经常需要查询。都是 id 和日期，post votes 表目前只有 56，454，478 行。由于索引，大多数查询只需要几毫秒。

*   标签引擎是完全自包含的，这意味着不必依赖外部服务来获得非常非常核心的功能。这是一个巨大的内存中的结构数组结构，优化了用例，并预计算了大量命中组合的结果。这是一个简单的 windows 服务，运行在冗余团队中的几台机器上。CPU 几乎都是 2-5%左右。负载不需要三个盒子，只是冗余。如果所有这些都同时失败，本地 web 服务器将在内存中加载标记引擎并继续运行。

*   与传统的 ORM 相比，Dapper 缺少检查查询的编译器。编译器正在检查你告诉它的数据库的样子。这可以帮助很多事情，但仍然有基本的断开问题，你会在运行时得到。这种权衡的一个大问题是生成的 SQL 很糟糕，而且找到它的原始代码通常很不容易。缺乏提示查询、控件参数化等功能。也是优化查询时的一个大问题。比如说。Dapper 中添加了文字替换，以帮助查询参数化，从而允许使用过滤索引之类的东西。Dapper 还拦截对 dapper 的 SQL 调用，并准确地添加它来自的地方。它节省了很多时间。

## 编码

*   流程:

    *   大多数程序员远程工作。程序员在他们自己的蝙蝠洞里编码。

    *   编译速度非常快。

    *   然后运行他们仅有的几个测试。

    *   一旦编译完成，代码就被转移到开发阶段服务器。

    *   新功能通过功能开关隐藏。

    *   运行在与其余站点相同的硬件上。

    *   然后将它移动到 Meta.stackoverflow 进行测试。每天有 1000 名用户使用这个网站，所以这是一个很好的测试。

    *   如果通过，它将在网络上直播，并由更大的社区进行测试。

*   为了简单和更好的性能，大量使用静态类和方法。

*   代码之所以简单，是因为复杂的部分被打包在一个库中，并被开源和维护。的数量。Net 项目保持低水平，因为使用了社区共享的代码部分。

*   开发者得到两到三台显示器。屏幕很重要，它能帮助你提高工作效率。

## 贮藏

*   缓存所有的东西。

*   5 级缓存。

*   1st:是网络级缓存:浏览器、CDN 和代理中的缓存。

*   第二:由免费提供。这是一个内存中的每服务器缓存。

*   第三:Redis。分布式内存中键值存储。在为同一站点服务的不同服务器之间共享缓存元素。如果 StackOverflow 有 9 个服务器，那么所有服务器都能够找到相同的缓存项。

*   第四:SQL Server 缓存。整个数据库都缓存在内存中。整件事。

*   5 号:SSD。通常只在 SQL server 缓存预热时命中。

*   例如，每个帮助页面都被缓存。访问页面的代码非常简洁:

    *   使用静态方法和静态类。从面向对象的角度来看非常糟糕，但是对于简洁的代码来说非常快并且非常友好。所有代码都是直接寻址的。

    *   缓存由 Redis 和微 ORM[Dapper](https://code.google.com/p/dapper-dot-net/)的库层处理。

*   为了避免垃圾收集问题，只创建模板中使用的类的一个副本，并保存在缓存中。一切都被测量，包括 GC 操作，从统计数据可以知道，间接层增加了 GC 的压力，以至于明显变慢。

*   CDN 命中各不相同，因为查询字符串哈希是基于文件内容的，所以只能在构建时重新获取。对于 300 到 600 GB 的带宽，通常每天有 3000 万到 5000 万次点击。

*   CDN 不是用于 CPU 或 I/O 负载，而是帮助用户更快地找到答案。

## 正在部署

*   想一天部署 5 次。不要建造宏大的东西，然后把它投入使用。重要是因为:

*   TeamCity 构建然后通过 powershell 脚本复制到每个 web 层。每台服务器的步骤如下:

    *   告诉 HAProxy 通过一个帖子将服务器退出轮换

    *   让 IIS 完成当前请求的延迟时间(约 5 秒)

    *   停止网站(通过以下所有操作的相同步骤)

    *   机器人复制文件

    *   启动网站

    *   通过另一个帖子在 HAProxy 中重新启用

*   几乎所有的东西都是通过 puppet 或 DSC 部署的，因此升级通常只需要对 RAID 阵列进行 nuking 并从 PXE 启动进行安装。它非常快，而且你知道它是正确的/可重复的。

## 合作

*   团队:

    *   SRE(系统可靠性工程):- 5 人

    *   核心开发人员(问答网站) :大约 6-7 人

    *   移动核心开发人员:6 人

    *   专门为 SO 职业产品进行开发的职业团队:7 人

*   Devops 和开发者团队真的很紧密。

*   团队之间有很多动作。

*   大多数员工远程工作。

*   办事处大多是销售部，丹佛和伦敦也是如此。

*   在其他条件相同的情况下，人们更倾向于待在纽约，因为面对面的时间有助于在“完成任务”的间隙进行随意的互动。但是这种设置使得真正的工作成为可能，官方团队的合作几乎完全在网上进行。

*   他们已经认识到，你能在任何地方雇佣到热爱该产品的最优秀人才，而不仅仅是那些愿意住在你所在城市的人才，这远远超过了面对面的好处。

*   一个人变得冷漠最常见的原因是成家。纽约很棒，但不够宽敞。

*   办公室在曼哈顿，那里有很多人才。数据中心不需要太远，因为它总是在改进。纽约市的许多主干网的连接速度也稍快一些——尽管我们说的只是几毫秒的差别。

*   组建一个令人敬畏的团队:热爱极客。例如，早期的微软充满了极客，他们征服了世界。

*   从堆栈溢出社区租用。他们寻找对编码的热情，帮助他人的热情，和交流的热情。

## 预算

## 测试

*   快速移动，打破东西。推直播。

*   重大变革通过推动它们来检验。开发有一个同样强大的 SQL server，它运行在同一个 web 层上，所以性能测试不是很糟糕。

*   很少测试。Stack Overflow 不使用很多单元测试，因为它们的社区很活跃，大量使用静态代码。

*   基础设施的变化。每样东西都有两个，所以只要有可能，就用旧配置进行备份，并带有快速回切机制。例如，keepalived 可以在负载平衡器之间快速进行故障恢复。

*   冗余系统故障转移经常只是为了进行定期维护。SQL 备份通过专门的服务器进行测试，专门用于不断地恢复它们(这是一个免费的许可——做吧)。计划每 2 个月左右启动一次完整的数据中心故障转移——备用数据中心在所有其他时间都是只读的。

*   单元测试、集成测试和 UI 测试在每次推送时运行。在生产构建运行之前，所有的测试都必须成功。所以关于测试有一些混杂的信息。

*   那些明显应该有测试的东西都有测试。这意味着 Careers 产品中大部分涉及金钱的东西，以及核心端易于单元测试的功能(具有已知输入的东西，例如，标记，我们的新顶栏等)，对于大多数其他东西，我们只是手工进行功能测试，并将其推送到我们的孵化网站(以前的 meta.stackoverflow，现在的 meta.stackexchange)。

## 监控/记录

*   现在考虑使用 http://logstash.net/进行日志管理。目前，一项专门的服务将 syslog UDP 流量插入 SQL 数据库。网页在输出途中添加了计时头，这些计时头由 HAProxy 捕获，并包含在 syslog 流量中。

*   [Opserver](https://github.com/opserver/Opserver) 和 Realog。有多少指标浮出水面。Realog 是一个由 Kyle Brandt 和 Matt Jibson 在 Go 中构建的日志显示系统

*   日志记录是通过系统日志而不是通过 IIS 从 HAProxy 负载平衡器进行的。这比 IIS 日志更加通用。

## 湿润

## 表现为特征

*   StackOverflow 非常重视性能。主页的目标是在不到 50 毫秒的时间内加载，但也可以低至 28 毫秒。

*   程序员热衷于减少页面加载时间和改善用户体验。

*   每个网络请求的时间都会被记录下来。有了这些度量，你就可以决定在哪里改进你的系统。

*   他们的服务器以如此低的利用率运行的主要原因是高效的代码。Web 服务器平均使用 5-15%的 CPU、15.5 GB 的 RAM 和 20-40 Mb/s 的网络流量。SQL 服务器平均使用大约 5-10%的 CPU、365 GB 的 RAM 和 100-200 Mb/s 的网络流量。这有三大好处:一般成长空间大，升级是必要的；当事情变得疯狂时(错误的查询、错误的代码、攻击，无论是什么)，保持在线的空间；以及在需要时恢复供电的能力。

## 吸取的教训

*   **如果用 MS 产品为什么要用 Redis？** [加比奇](http://www.reddit.com/r/programming/comments/1r83x7/what_it_takes_to_run_stack_overflow/cdkpv7w):不是 OS 福音主义。我们在他们运行得最好的平台上运行。句号。C#在 windows 机器上运行最好，我们用 IIS。Redis 在我们使用的*nix 机器上运行得最好。

*   **作为策略的过度杀戮**。Nick Craver 解释为什么他们的网络被过度配置:20 Gb 是不是大材小用？没错，在 20 Gb 的管道中，活动的 SQL 服务器平均占用 100-200 Mb。然而，像备份、重建等等。由于内存和 SSD 存储的数量，它可以完全饱和，因此它确实有其用途。

*   **固态硬盘摇滚**。数据库节点都使用 SSD，平均写入时间为 0 毫秒。

*   [了解自己的读写工作量](http://sqlblog.com/blogs/louis_davidson/archive/2009/06/20/read-write-ratio-versus-read-write-ratio.aspx)。

*   保持高效率意味着不经常需要新机器。只有当一个新项目由于某种原因需要不同的硬件时，才会添加新的硬件。通常会添加内存，但除此之外，高效的代码和低利用率意味着它不需要更换。因此，通常谈论添加 a)固态硬盘以获得更多空间，或 b)为新项目添加新硬件。

*   **不要害怕专攻**。所以使用基于标签的复杂查询，这就是为什么开发了专门的标签引擎。

*   只做需要做的事情。测试是不必要的，因为一个活跃的社区为他们做了验收测试。仅在需要时添加项目。仅在必要时添加一行代码。你不需要它真的有用。

*   **重新发明是可以的**。典型的建议是不要重新发明轮子，你只会让它变得更糟，比如把它弄成方形。所以他们不担心做一个“方轮子”。如果开发人员能写出比已经开发的替代方案更轻量级的东西，那就去做吧。

*   **下到裸机**。进入 IL(汇编语言的。网)。有些编码是 IL，不是 C#。看看 SQL 查询计划。获取 web 服务器的内存转储，看看实际发生了什么。例如，我发现一个拆分调用产生了 2GB 的垃圾。

*   **没有官僚主义**。你的团队总会需要一些工具。比如编辑器，最新版本的 Visual Studio 等。只要让它发生，没有太多的过程阻碍。

*   **垃圾收集驱动编程**。所以不遗余力地减少垃圾收集成本，跳过像 TDD 这样的实践，避免抽象层，并使用静态方法。虽然极端，结果是高性能的代码。当您在一个短窗口中处理数亿个对象时，您实际上可以在 GC 运行时测量应用程序域中的暂停。这些对请求性能有相当大的影响。

*   **低效代码的成本可能比你想象的还要高**。高效代码进一步扩展了硬件，降低了功耗，让程序员更容易理解代码。

## 相关文章