# 难道我们的代码不是最好的吗🙄|肥胖|保险杠|中号

> 原文:[https://medium . com/bumpers/not-our-code-just-the-best-f 028 a 78 f 33 a 9？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://medium.com/bumpers/isnt-our-code-just-the-best-f028a78f33a9?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

# 难道我们的代码不是最好的吗🙄

## 我花了 6 周时间在 react 里重写保险杠。



[Download bumpers.fm](http://bumpers.fm/download) to read narrate your own Medium article.



我刚刚用 [react](https://facebook.github.io/react/) 完全重写了[保险杠](http://bumpers.fm)网络应用。(*如果你不知道什么是 bumpers，这是一个超级酷的应用程序，用于在手机上记录/分享音频故事。* [*下载它*](http://bumpers.fm/download) *，它会实实在在地 f***起你的整个人生。这是有史以来最伟大的应用程序。反应？没关系。*)



无论如何，以下是我所有的笔记、想法等。在这个过程中。(我希望我在开始之前已经读过的东西)。希望你能从中有所收获。

# **前言**

*神*。我讨厌框架。很多。

我也讨厌没有框架，任何人“滚”自己的“框架”。总的来说，我也讨厌编码。最重要的是，我讨厌写代码。

所以请容忍我。

最近，我的编码风格变得有些反社会，在严重的自我怀疑和极端的 kanye 式的上帝情结之间摇摆不定——我要么整天独自在我的公寓周围哭泣，要么打电话给我母亲，让她知道她 30 岁的儿子正在“以一种好的方式搞砸游戏”。所以很自然地，这似乎是一个休息一下并写下它的好时机。



(morale over a project lifecyle, red notes mine) — [https://medium.com/@iano/moral-over-a-project-lifecycle-975792b54c12#.uwkzt7x4v](/@iano/moral-over-a-project-lifecycle-975792b54c12#.uwkzt7x4v))



# 选择反应

一点历史:保险杠“网站”是如此之好。大约有 7 个 es6 类，没有外部依赖，只有大约 759 行代码。总计。

它的布局由我们的 Go 应用程序呈现在服务器上。我们使用了 postcss。我们有一个非常简单的资产目录，里面放了我们所有的 SVG 和一两个视频。太棒了。我们写了一些 javascript。我们忘了这件事。

> 太棒了。我们写了一些 javascript。我们忘了这件事。

与此同时，[尼古拉斯·加拉格尔](http://twitter.com/necolas)是团队的一员，他们刚刚完成了为期一年的项目，改写了 Twitter 的移动网络产品 React。



我认识尼古拉斯很久了。他无疑是我认识的最体贴的人之一。因此，当他告诉我 React 已经基本上解决了前端开发领域的所有问题，并且他已经开始担心其他事情时，我告诉他马上离开。





T2】

**从表面上看，React 有以下优势**:

**但与此同时，react 也有一些我不感兴趣的事情**:

*   我的 700 行 javascript 包即将变成大约 1.5mb
*   生产服务器端渲染需要一个节点服务器(即使这样，解决方案看起来也是半生不熟的)
*   整个社区的风格实践是非常分散的(你使用 aphrodite，css 模块，风格标签等等。—你的依赖怎么办？)
*   facebook 书呆子写的
*   webpack → babel → jsx →热加载→源码图→ chrome tools 作为一个堆栈残废了我可怜的小 macbook
*   我不得不看这些该死的“书呆子”视频来学习 redux
*   工具似乎是脱节的，而且有些过头了…



尽管如此，我们还是决定放手一搏。(主要的希望是 react 会以某种方式让我们建立一些更“app-y”的东西)。

# 选择“其余的”

事实证明，在您决定使用 react(您的视图库)之后，您实际上还剩下一些其他的决定:您将如何管理状态？你将如何设计你的组件？你要用 es6 吗？es7？es2015？jsx？这些是什么意思？你要用 webpack 吗？还是 browserify？万物将生活在哪里？…

我开始把 TJ Holowaychuk 的样板回购([https://github . com/TJ/frontend-boilerplate/tree/master/client](https://github.com/tj/frontend-boilerplate/tree/master/client))和 Nicolas 写给我的关于 twitter 登陆的长邮件混在一起(其中一半我当时不明白，但不管怎样，你可以在这里阅读邮件全文:[https://gist . github . com/fat/it](https://gist.github.com/fat/9ab5325ab39acfe242bc7849eb9512c4)

我也看了 github 上的许多“universal-reaction-redux-glahblbhalkd”样板文件中的一些，但它们基本上都让我恐慌发作。

无论如何，我设法到达了一个我有点满意的地方，它看起来像是:



*   **Babel** (带“预置”:[“es 2015”、“stage-0”、“react”])这样我就可以使用所有疯狂的新玩意儿，比如 spread 运算符、箭头函数等等。
*   带有热加载器的 Webpack ，当我在特定的应用程序状态下更新样式时，我发现它很方便。但确实让我很焦虑。*老实说，我觉得没有人真正理解 webpack 是如何工作的。我们只是不停地向它扔随机的属性和插件，祈祷它会变成现实。AggressiveMergingPlugin？当然可以。OccurrenceOrderPlugin？好的。重复数据删除插件？好吧。*
*   Redux 与 normilzr 和 denormalizr 相结合，帮助对 api 响应进行析构和再水合。
*   **阿芙罗狄蒂/不重要的** js 风格，不是 css，但是没有那些！处处重要。
*   **Svg-react-loader** 将 Svg 作为 react 组件内联加载。
*   如果你在依赖列表中看到了其他你感兴趣的东西，请留言，我会解释的。

# 目录结构



好吧。一旦我确定了网站没有要求的 **38** 依赖关系 [bumpers.fm](http://bumpers.fm) ，是时候写一些实际的代码了。💪

我们的目录结构是围绕两个入口点组织的:

*   ***index.js*** 为我们的核心 app bundle 实例化路由器和商店。
*   ***embed.js*** 负责我们较小的 embed bundle(如 slack、twitter、medium 等所见)**。**

在那里，我们从名副其实的“route”目录中提取路由，该目录目前只是一个简单的单一 react-router 组件，如下所示:



注意这些路线指向我们称之为✨screen containers✨.的地方

在 Bumpers 中，我们的 react 组件实际上被分成 3 个不同的目录，这取决于它们的功能(如果包括 routes 目录的话是 4 个)。这种组织组件的方式基本上是直接从推特上偷来的，我认为推特上的人又从 T2、脸书和其他项目中借鉴来的。看起来像是:



*   组件这是我们的功能 ui 组件所在的地方
*   容器这是我们 ui 组件的动作处理程序所在的地方
*   从技术上来说，这些只是容器——但是通常做更多的顶级页面抓取，而不太关心动作处理。

> **旁注**我实际上从一个容器目录开始，没有“屏幕”(这在我所看到的 react 社区中很常见)。在 Nicolas 的建议下，我离开了这个地方，因为看到一堆“screen”后缀的文件和我的非“screen”后缀的文件混杂在一起，让我心烦意乱。











T2】

最后两个目录是“存储”目录和“常量”目录。“存储”包含我们所有的 redux 逻辑，如动作、reducers、选择器、api 端点等。(我将在下面进行更深入的讨论)，而“constants”目录包含…嗯…常量。

# **UI 组件**

我们的 UI 组件是非常标准的、功能性的、无状态的、表示性的、反应性的组件。这是一个标准的[剧集](http://bumpers.fm/e/auvl1h7i11c000tqocl0)组件(由许多其他更小的、标准的、功能性的、无状态的、表示性的、反应性的组件组成)。



正如我上面提到的，我们使用可汗学院的阿芙罗狄蒂来生成我们的 css。

> **快速提示**最初，我使用[风格加载器](https://github.com/webpack/style-loader)包编写应用程序，但它无法提供令人信服的服务器策略(这是我最终想要探索的)，足以让我尝试其他东西。(我也习惯性地考虑 React-Native，Nicolas 会不断提醒我，这比我独立得出的任何解决方案都要好，因为这是他写的)。

然而，用 javascript 编写我的风格变得非常自然，在 ES6 新特性的帮助下，它可以变得非常优雅。



当我在 Medium 工作的时候，我能够实现与我们[相似的风格，创建类型标度、颜色标度、zIndex 标度等等。甚至能够使用 ES6 计算属性名特性将我的媒体查询抽象成变量。](/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06)





T2】

有一件事我不能理解，那就是给我所有的类名起一个通用的名字，比如“box”或“container”或“main”或“root”。我得到了整个 ***本地*** 范围的 css 迷因——但这似乎是以可调试性为代价的。相反，我实际上采用了一种命名语义，它与 [SuitCSS](https://suitcss.github.io/) 中概述的语义相差不远，只是针对 javascript 稍作修改(使用“_”而不是“-”)。实际上，这看起来像这样:

T2】

最后一件我要快速提及的事情是，我们所有的相关文件都存在于它们各自的组件目录中。



样式放在一个名为 *style.js、*的单独文件中，旁边是使用 **svg-react-loader** 直接导入的相关 svg 资产。这样做使得删除组件/特性变得非常容易，而不是不断地问自己:等等，我还需要这个 css 吗？我还需要这个 svg 吗？



# 集装箱间歇

老实说，我不会对容器说太多。除了分离屏幕/容器目录之外，我们在这里没有做什么特别的事情(我已经在上面介绍过了)。

我*做了*然而为你画了另一幅画(哇，就在那边),因为我为没有说太多关于容器的话而感到难过😬。我想这是你休息一下的好时机。拉伸？

抱歉。

# 商店

**~好吧~** 。这个商店区很容易成为它的👏自己的👏全部的👏文章👏，但我会努力帮你们渡过难关…所以请原谅我。还有一个合理的警告——T2 即将变得密集。

> **旁注**接下来的内容可能毫无意义，除非你熟悉 redux(【http://redux.js.org/】)这个词。如果你有兴趣了解更多关于 Redux 的知识，并使用它来管理 react 应用程序中的状态——我推荐看看这些书呆子教程，它们是免费的，而且都被认为非常好:【https://egghead.io/courses/getting-started-with-redux

我们的商店由 4 个顶级文件组成(下面我会对每个文件进行更详细的介绍，但只是很快地介绍)…

*   **index.js** —我们的存储初始化器
*   **reducer.js** —将不同对象的所有 reducer 拉入一个巨大的“combineReducers”方法中
*   **schema.js** —我们所有的 normalizr 模型
*   **api.js** —我们商店的 api 助手



除此之外，我们的商店是围绕模型构建的，有类似于**用户**、**提示**、**等**的目录。—而不是传统的 redux 顶层功能目录层次结构 **actions/、reducers/、selectors/、bleh。**

当然，我们仍然有传统的行动分离，减速器等。redux 需要——但是现在这是在文件级别上完成的，嵌套在它的模型目录中(请看左边图片中展开的用户文件夹以了解我想说的内容)。

好吧，但是为什么呢？在开发这个应用的过程中，我发现自己经常说这样的话:“该死的，我真的很想做*用户资料 rn】*，几乎从来不说这样的话:“该死的，我真的很想一次改变一堆 reducer，真高兴它们都在这个巨大的该死的 reducer 目录中”。

> 我不记得我是在哪里第一次看到这个策略的……但是我确信我没有发明它。如果你知道谁这么做了，或者谁解释得很好，请留言，我很乐意向人们指出这一点。我也~认为~推特也做类似的事情。但这可能是我编的。

# 根级文件的本质

好的，所以商店的 ***index.js*** *(上面简单提到过)*负责 3 个主要任务:

1.  将预先获取的嵌入式数据导入我们的 redux store，并设置存储的初始状态(当用户访问类似 bumpers.fm/fat 的东西时，我们的后端会预取数据，这样当 react 应用程序加载时，它不必立即对用户数据发出 xhr 请求，而是可以快速填充页面)。
2.  用根 reducers 初始化 redux 存储。
3.  应用中间件如 thunk，react 路由器的 browserhistory，devtools 等等…

在实践中，这一切最终看起来有点像下面的方法——但不管出于什么原因，给我带来了很多痛苦:







T2】

接下来让我们简单地访问一下我们的 ***reducers.js*** 文件，它本质上只是一个单独的`combineReducers`方法，它从我们的其他目录中提取 reducer，并将它们作为一个单独的巨型 reducer 瀑布一样的东西公开。tbqh，这个文件很无聊，我可能会把它放到 index.js 中🐴。哎呦。



然而！这里有一点*是*值得一提的，那就是我们的“实体”缩减器(如上所示)就像我们商店的*缓存*一样运行。

为了实现这一点，我们使用了一个名为 normal izr([https://github.com/paularmstrong/normalizr](https://github.com/paularmstrong/normalizr))的项目，将我们深度嵌套的 JSON api 响应强制转换为更易于管理/缓存的 ID 索引对象。也就是说，我们从一个更传统的 api 响应开始，然后将其转换为一个更安全的、ID 索引的实体哈希:

正如你可能想象的那样，当你开始在 react 应用中导航时，这种缓存技术非常有用——因为如果你获取了一个*集*，你可能已经获取了一个*用户*(作为一个*作者* ) *，*，你现在可以使用其中一种选择器方法通过 ID 来查找，而不必点击你的后端(阅读:几乎即时的导航。哇)。



T2】

然后，我们的 ***schema.js*** 就是我们为缓存(和 normalizr)指定上述实体转换的逻辑的地方。这些关系映射写起来非常简单，但是很容易忘记。如果你打算走 redux 缓存路线，它的 def 值得看看这些。



> **边注**上图没有， **Schema.js** 也包含了一个定制的 mergeStrategy，这是我们专门为 [**保险杠**](http://bumpers.fm) 编写的。不管出于什么原因，normalizr 提供的默认 mergeStrategy 本身就是错误的，但我不会在这里深入讨论，因为这几乎肯定是用户错误😅。(也就是说，如果你遇到类似的问题，请留言，我很乐意分享我们的解决方案。)



T2】

我们在商店目录中的最后一个根文件是 ***api.js.***

在我绞尽脑汁之后，我注意到 thunk 中间件(我们依赖它来进行异步操作)允许我们向所有 redux 操作传递一个额外的参数(在 *dispatch* 和 *getState* 之上)。



Remember this from the store/index.js



这*非常*强大，我最终用它将一个全局 api 助手传递到我们所有的动作中。这个 api 助手(在 **api.js** 中定义)提供了对我们所有 api 端点的快速访问，以及用于 JSON 解析、错误检查等的额外助手。你会在下面的*动作*中看到这个…当我们进入… *动作* …文件时…

# 还原剂

我们的 redux reducers 进化出 3 个主要功能。

1.  定义初始状态
2.  定义一个 preloadData 处理程序(用于我们的嵌入数据)
3.  公开操作处理程序减少器

我们的初始状态通常看起来像这样，请求状态和活动 id 的状态常数如下:



我们的预加载处理程序获取原始数据对象，并解包数据实体，在这种情况下设置一个默认的活动用户:



一个典型的缩减器看起来像这样(注意计算属性名的使用(Es2015))。我们直接从下面的动作定义中提取这些内容)。



# 行动

在我们的动作文件中发生了一些神奇的事情。首先，我们使用“redux-actions”*create actions*方法来定义我们的动作名称:



我们这样做是为了在 reducers 文件中，我们可以使用计算属性名(前面提到过),只在一个地方定义我们的动作名。再来看看我们给自己的行为命名的方式:`method + object + property`。这对于保持所有 reducer 键的可读性和唯一性非常重要。我在网上看到过很多例子，人们使用懒惰的、通用的名称，如“username”或“setUsername”作为键…相信，如果你这样做，你会有一段很糟糕的时间(记住，键是全局的，由命名冲突引起的错误是要追踪的主要问题)。

对于异步操作，我们使用 redux thunk 和上面提到的 api 助手。这有助于保持我们的异步方法超级紧密和集中。



在上面的例子中，我们在用户对象上设置`isFetching`，向我们的 api 发出请求，检查错误状态代码的响应，设置我们的 jwt 令牌，将响应转换为 json，使用 normalizr(用于缓存)规范化响应，然后设置活动用户状态。

这是我*见过的*redux 中最干净的处理异步方法的方式。

# 端点

我还没有见过其他人做这些端点文件——但是我发现这是一种非常干净的方法，可以将相关的 api 调用都放在一个地方(更不用说使存根测试变得非常容易)。还要注意“同构获取”——*我发誓有一天我们会在服务器上渲染这些东西*😤*。*与此同时，使用 fetch 很酷的一点是它返回一个承诺，当被拉入我们的异步操作时，它会成为一个非常干净的 api。



# **选择器**

最后，我们的选择器文件使用 denormalizr 库([https://github.com/gpbl/denormalizr](https://github.com/gpbl/denormalizr))(normal izr 的姊妹项目)从我们的缓存中重新构建更多可用的数据。它基本上只是使用名称模型来重建一个大的嵌套对象——你不一定要这样做，但是我发现以这种方式处理数据更令人愉快/可预测。

除此之外，我们的选择器方法看起来很像您所期望的:



# **结论**

**哇**。好吧，你们都觉得这是一次严肃的旅行。商店里的东西可能太无聊了，失去了 90%的读者，所以我很抱歉。

非常感谢你的阅读，如果这篇文章令人难以忍受，我很抱歉。我只是向自己保证我会发表这样的东西，因为我发现学习这些东西是如此的分散/困难。

如果你对任何事情有任何问题，请留下评论或留言，我会尽力回答。

❤脂肪

# 一些问答

是啊，我真的很开心！如果我没有说它是一个主要的 pita，那我是在撒谎，但 Bumpers 基本上只是一个大规模的音频播放器应用程序——否则，管理导航和我们所有的许多小反馈元素的状态会非常困难。

我认为，当你有“熟悉的”工具时，使用它们也是值得一提的——我希望，如果我们能在 Bumpers 雇佣更多的前端人员，他们将能够相当容易地投入工作，而不会感到完全不知所措(就像他们需要从头开始学习一切)。

是的，差不多。我在 Medium 的时候，我们也做过类似的事情。你必须小心你如何做，因为脚本注入黑客，但这是一个很酷的方式来实现类似“服务器端渲染”的感觉，而不必在服务器上渲染 react 模板。













