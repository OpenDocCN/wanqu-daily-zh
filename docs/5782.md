# 在 Reddit - Upvoted 上发展移动架构

> 原文:[https://Reddit blog . com/2018/09/12/evolving-mobile-architecture-at-Reddit/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://redditblog.com/2018/09/12/evolving-mobile-architecture-at-reddit/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

***安德鲁·罗恩*T3】**

这是我们在 Reddit iOS 应用程序上所做的架构工作系列的第一篇。第一部分将讨论我们在 UI 方面所做的工作。特别是，我们将讨论我们如何转移到模型-视图-展示者(MVP)架构:

*   为未来的发展和更快的迭代改进代码的灵活性、可理解性和可维护性。
*   在滚动性能方面实现了 58%的平滑提升。
*   鼓励单元测试，并将测试数量从少数几个增加到 200 多个。

为了清楚起见，下面是我们最终得到的分层架构的高级图。在第一篇文章中，我们将关注视图和演示者层。



 高层:我们最终得到的分层架构。 



## **设置舞台**

一年多前，我们发布了为 Reddit iOS 应用构建 Feed 的文章[。在那里，我们讨论了如何构建一个高性能的、可扩展的提要，具有令人钦佩的 99.95%的无崩溃会话率。我们解释了模型-视图-控制器(MVC)架构的应用程序，并创建了提取分页数据的抽象。](https://redditblog.com/2017/06/08/building-the-feed-for-the-reddit-ios-app/)

快进到今天，作为一个组织和一个产品，Reddit 已经成长并继续成长。因此，Reddit iOS 应用被置于更高的需求之下。该应用程序需要支持更多的功能请求、更快的开发迭代周期和更高的质量标准。它还必须支持一个从大约三个开发人员发展到二十多个开发人员的开发团队。最初的 MVC 架构在这些增加的需求下变得紧张，我们需要做出架构上的改变来适应。

## **说明问题**

守则也变得更加僵硬和难以理解。在 iOS 开发社区中，“大规模视图控制器”是对 MVC 初始化的一个众所周知的挪用，因为对于视图控制器来说，膨胀到 1，000 多个线神对象是很常见的。尽管我们尽了最大努力，这个问题还是开始出现了。除此之外，我们的视图控制器继承层次已经发展到令人不安的深度。这意味着我们的控制者开始成长为不可理解的难以改变的上帝物品。

当我们想要改变提要的视图层实现时，MVC 棺材中的最后一颗钉子*需要*重新架构。随着 Reddit 应用的持续增长，提要滚动性能开始从持续的 60 fps 下降到偶尔的 45-55 fps。这意味着我们需要重写提要的视图层，同时仍然支持原来的实现。但是，在现有的 MVC 架构中，如果没有数千行代码的重复，我们无法重写提要的视图层。

此外，代码库中存在许多难以测试的部分。代码被放入难以测试的视图层类中，依赖关系通常是单一的或者硬编码到类本身中。我们希望做出一些改变，来解开测试所提供的保证。

最重要的是，这些变化需要保持高的无崩溃会话率，为下一阶段的增长奠定基础，并且在不中断依赖于现有基础架构的功能团队的情况下工作。这意味着变化必须是渐进的，而不是革命性的。

## **走向模型-视图-演示者**

我们决定，我们需要解决上述问题的应用程序的下一个迭代。当我们考虑了几个选项时，我们决定采用[模型-视图-展示者](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter) (MVP)架构。除了满足上述标准之外，MVP 还有一个好处，那就是它是一个众所周知的、有文档记录的架构，这意味着它更容易培养工程师。它还保留了“视图模型”的概念如果有必要，我们可以在 presenter 中创建[单责任聚焦的](https://en.wikipedia.org/wiki/Single_responsibility_principle)视图模型对象，并使用它们来扩展我们的视图。



 模型-视图-演示者关系图。 



## **分解“海量视图控制器”**

通常在一个 iOS 应用中，视图对象是 UIView 的子类，控制器对象是 UIViewController 的子类，而你的模型对象是普通的 ol '对象。正如你在“UIViewController”这个名字中所读到的，视图和控制器的角色都被组合成一个单独的对象。这意味着 iOS 上的 MVC 往往会失去它所提出的好处，因为它的视图和控制器层紧密耦合。有趣的是，苹果自己也承认了这种结合。



 iOS 上的模型-视图-控制器最终看起来像什么。 



在 iOS 上的 MVP 架构中，我们接受这一概念，并通过将 UIViewController 视为只是一个美化的视图层对象来形式化它。这种将 UIViewController 作为一个视图对象来对待的概念，用了一个不恰当的命名，在最近几年已经[获得了](https://www.raywenderlich.com/1073-model-view-controller-mvc-in-ios-a-modern-approach) [的流行](https://davedelong.com/blog/2018/04/24/a-better-mvc-part-5-an-evolution/)。

因此，在我们的 UIViewControllers 中，我们删除了任何非视图逻辑。然后，我们允许演示者承担视图和模型之间的中介角色。在这个新角色中，演示者不了解诸如 UIViewControllers 之类的视图具体化。请注意，演示者通过界面与视图进行通信。理论上，我们可以用 NSViewController (MacOS)或其他视图具体化来替换视图实现。



 通过引入一个演示者和划分职责来精简视图控制器。 



## **通过 MVP 思考**

正如你在上面的 MVP 图中看到的，这个架构实际上看起来很像 MVC。事实是相似之处多于不同之处。这个架构只是帮助我们恢复 MVC 目标的表示代码和业务逻辑的适当分离。事实上，派生的 MV(x)架构，如 MVP、MVVM、MVAdapter 等。，其实只是这个核心概念的不同味道。

有人可能会进一步怀疑为什么我们完全抛弃了 MVC。事实上，苹果描述了[不同种类的控制器](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html#//apple_ref/doc/uid/TP40010810-CH14-SW7)如模型控制器、中介控制器和协调控制器。事实上，我们可能会用不同类型的控制器替换我们的演示者。然而，我们选择不这样做，因为出于各种原因，大多数 iOS 开发人员都被灌输了 UIViewControllers 是控制器的同义词的信念。通过使用单词“presenter ”,我们向开发人员发出信号，这个对象与具有特定职责和属性集的典型控制器有意义地不同。

## **改进的灵活性、可维护性和可理解性**

“[优于继承](https://en.wikipedia.org/wiki/Composition_over_inheritance)”是编程中众所周知的口头禅。有了继承，你必须预测未来并构建一个宏大的对象分类法。然而，当你“完美”构建的继承层次因为不可预见的变化而开始分崩离析时，就很难改变这种僵化的结构了。使用组合，您可以用其他对象组合您的对象，并将工作委托给它们。这很有用，因为现在您可以通过简单地更改组成对象的对象来轻松地更改对象在运行时的行为。这些可组合的对象也更容易理解，因为您已经将代码从继承层次结构中推出到一个更加单一责任的抽象中。

这种可组合性是 MVP 架构带给我们的最大好处之一。由于我们的视图控制器现在是由一个呈现者组成的，我们可以通过简单地改变组成它的具体呈现者来改变视图控制器的行为。我们也可以更少地担心必须构建和破译一个复杂和僵化的继承结构。最后，演示者和视图控制者更容易理解，因为他们有更集中的职责。通过引入一个 presenter 并把非视图逻辑推入其中，我们能够展平我们的视图控制器继承层次。在下图中，您可以看到我们能够删除 GalleryFeedViewController 类，因为我们将所有图库模式逻辑都推送到一个演示者中。如前所述，这种更扁平的继承层次结构更容易理解，也不那么死板。



 通过组合使继承层次变平。 



## **自由改变视图层实现**

如前所述，提要滚动性能开始从持续的 60 fps 下降到偶尔的 45-55 fps。所以，我们决定使用[纹理](http://texturegroup.org/)来重写提要的视图层实现。Texture 是建立在 Apple UI kit 之上的开源框架，它通过在后台线程上预先计算工作来提高 UI 性能。但是，考虑到当前的 MVC 架构，如果没有大量的代码重复，我们实际上无法改变视图层的实现。



 MVP 之前:ViewControllers 中重复的非视图代码(橙色)。 



使用新的 MVP 架构，我们能够*发展*来支持纹理，而不是从头开始重写。我们简单地将所有非视图逻辑推到一个共享的 presenter 类中。然后，我们编写了视图层的新纹理实现，并重用了演示者代码。这给了我们支持两种视图实现的好处，直到我们可以向所有用户提供纹理提要。



 MVP 之后:将非视图代码移动到共享演示者中。 



那么有什么影响呢？这张图表显示了我们在提要滚动性能方面的改进程度。我们希望尽可能接近每秒 60 帧，以实现流畅的滚动。

## **单元测试**

尽管 MVP 并不是唯一负责支持和鼓励单元测试的人，但它是一个很大的因素。最值得注意的是，MVP 通过将代码从难以测试的视图层转移到更容易测试的表示层，增加了单元测试的表面积。方便的是，这也有让我们的观点更愚蠢的副作用。随着视图变得越来越愚蠢，我们越来越不关心测试它们。



 通过将非视图代码移出视图层来增加可测试中心。 



单元测试使我们的代码库更容易维护，因为它们给我们信心去做改变，并帮助我们理解什么是正确的行为。它们还使我们的代码更加灵活和易于理解，因为它们鼓励像依赖注入、组合和编程这样的技术抽象化而不是具体化。自从 MVP 重构以来，我们已经从仅有的几个单元测试发展到 200 多个。

## **Reddit 对 MVP 的严格审查**

虽然我们的 MVP 重构工作确实给了我们很多，但也有一些东西需要严格检查。

使用 Texture 重写提要引入了一系列新的线程问题。该应用程序最初并不支持这种异步视图实现。这意味着我们遇到了视图状态和应用程序状态不一致的问题。例如，提要的视图可能期望有 N 篇文章。然而，在一个后台线程上，应用程序状态在我们脚下发生了变化，现在包含< N 个帖子。如果我们没有正确地解决这种差异，当视图试图显示提要中的第 n 篇文章时，应用程序将会崩溃。

线程错误是最难修复的。它们很难被一致地复制，这意味着它们很难被调试。我们不得不改变一些逻辑来为我们的提要视图检索数据源。特别是，当提要视图发生任何变化时，我们已经设置了安全防护措施来“冻结”数据源的任何变化。这个和其他较小的修复减少了线程相关的错误。然而，在改进我们对更加异步的多线程世界的支持方面，仍然有改进的空间。

其次，presenter 层是另一个需要跳过的“环”。这种循环跳跃确实会增加代码复杂性和降低性能。有时出于奢侈或习惯，您可能只想在 UIViewController 中执行非视图逻辑。在最不幸的情况下，您可能会发现您的演示者只是一个过客，实际上没有执行任何有意义的逻辑。在这种情况下，拥有一个演示者的成本似乎不值得它存在。



 MVP 真正的样子。有时，在有或没有演示者的情况下，从视图到 RedditCore 的层桥接。 



事实上，这款应用还没有完全转换成 MVP 架构。首先，将每一个 UIViewController 转换成一个 presenter 将是一个巨大的工程——而不是进化。其次，如前一段所述，有时候演示者是不必要的。正如我们在 Texture feed refactor 工作中发现的那样，如果您试图精简庞大的视图控制器，或者您需要一个可变视图实现，或者您想要测试复杂的逻辑，那么 presenter 是一个很好的工具。但是有时候你的 UIViewController 太简单了，以至于你没有理由添加一个演示者。这相当于表示器是可选的，开发人员应该只在必要的时候实现一个。

## **总结与未来工作**

Reddit iOS 应用程序中的 MVP 架构重构帮助我们实现了许多预期目标。通过引入表示层，我们能够逐步发展应用架构，以支持新的视图层实现，而不会干扰功能团队。随着我们通过将非视图逻辑代码推到表示层来精简我们的“大规模视图控制器”,代码变得越来越容易理解。我们也给了功能团队更多的杠杆来快速迭代和开发新功能。最后，我们在提高应用程序的可测试性方面取得了长足的进步。

尽管如此，我们仍有很长的路要走。我们仍在培养和完善我们的演讲者。我们需要继续将非视图逻辑移出 UIViewControllers 并移入 presenter 层。我们还需要让演示者更加专注于单一职责。最后，应用程序和它的架构正在——并且将永远——演变。

接下来，我们将更全面地了解 iOS 应用程序的架构。我们将通过创建单独的框架(如 RedditCore 和 RedditUI)来讨论 Reddit iOS 应用程序的模块化。我们将把它与 MVP 架构的工作方式联系起来。敬请期待！