# 技术笔记:谷歌的打字稿

> 原文：<http://neugierig.org/software/blog/2018/09/typescript-at-google.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

<main>

我已经从事 TypeScript 工作两年多了。)所以我想我应该写一两篇帖子来反思一下。我应该以标准的免责声明开始:我只是一个随机的工程师，在一个有成千上万个这样的人的公司里，其他人肯定不同意这里表达的观点。

谷歌很早就接受了网络应用。你能相信 Gmail 发布已经 14 年了吗？那时的 JavaScript 纯粹是疯狂的。Gmail 工程师不得不担心 Internet Explorer 糟糕的垃圾收集算法，以至于他们需要手动将字符串从 for 循环中取出，以避免 GC 暂停。我最近找到了那个时代的一份设计文档，其中他们考虑做我们今天称之为“缩小”JavaScript 的事情，但指出一些候选工具仅适用于 Windows。今天，这感觉难以想象。

这些年来，谷歌为开发大型 JavaScript 应用建立了许多基础设施。例如，有一个模块系统让源文件表达它们的相互依赖关系。有一个捆绑器可以将源文件合并和缩小成浏览器兼容的工件。另一部分通过可动态加载的入口点来分析应用程序的依赖图，并提取公共子集块来提供服务。服务器端渲染很常见。所有这些概念对于今天的 web 开发人员来说都是熟悉的，但是 Google 的堆栈比今天的更早，并行发展，因此在概念上是相似的，但具体来说完全不同，具有不同的过程、工具，甚至这些思想的名称。

在另一个并行进化的例子中，谷歌、脸书和微软都构建了相似但不兼容的编译器，它们向 JavaScript 添加了静态检查。谷歌的编译器俗称 Closure。(不要与 Clojure 语言混淆；为了避免额外的混淆，请注意 ClojureScript 使用了闭包编译器。)

谷歌的 JavaScript 堆栈参差不齐。它让谷歌能够编写和维护改变了互联网面貌的网络应用。(还记得地图出来的时候有多惊艳吗？如今，制作一个拖沓的地图小部件似乎很容易让人厌烦。)它的某些部分超越了当今最好的技术。例如，闭包编译器可能仍然是最复杂的 JavaScript 优化器，能够使用类型信息优化代码，跨热加载块边界内联函数，以及将未使用的代码分解为[个单独的符号](https://closure-compiler.appspot.com/home#code%3D%252F%252F%2520%253D%253DClosureCompiler%253D%253D%250A%252F%252F%2520%2540compilation_level%2520ADVANCED_OPTIMIZATIONS%250A%252F%252F%2520%2540output_file_name%2520default.js%250A%252F%252F%2520%253D%253D%252FClosureCompiler%253D%253D%250A%250Aclass%2520C%2520%257B%250A%2520%2520constructor()%2520%257B%250A%2520%2520%2520%2520this.member%2520%253D%25203%253B%250A%2520%2520%257D%250A%2520%2520f(x)%2520%257B%250A%2520%2520%2520%2520console.log('hello')%253B%250A%2520%2520%2520%2520if%2520(x)%2520console.log(this.member)%253B%250A%2520%2520%257D%250A%257D%250A%250Alet%2520c%2520%253D%2520new%2520C()%253B%250Ac.f(false)%253B)。

谷歌的 JavaScript 栈也有问题。从 linter 开始的渐进式发展意味着闭包是 JavaScript 的静态类型变体，其中语言特性被引入到注释中。闭包有不可预测的语义，它很慢，有很多错误，而且如果你不恰当地使用它，它会破坏你的代码。虽然它是开源的，但也许因为这些原因，它并没有在行业中广泛使用，除非是那些雇佣熟悉它的谷歌员工的公司。在谷歌内部，我认为 JavaScript 的声誉很低，部分是因为我们挑剔的工具，它结合了静态语言的冗长和动态语言的不可预测性。

与此同时，在谷歌之外，JavaScript 也在继续发展，甚至出人意料地变得流行起来。在某种程度上，为了解决 IE 垃圾收集的问题，我们开发了 Chrome，这导致了 v8，V8 导致了 nodejs，这意味着今天大多数 web 工具本身都是用 JavaScript 编写的，不像 Google 使用 Java 来开发这种工具。模块系统(UMD、AMD、CommonJS)激增。(ES6 也来了，发明了自己的模块系统，出于某种原因，它与其他所有的模块系统都不兼容，唉。)npm 统一了工具和库的共享方式。Webpack 可以在你开发它的时候动态地将模块交换到一个正在运行的应用程序中。

谷歌没有使用这些。经验丰富的网络开发人员出现在谷歌，这就像访问一个替代的时间线。有一种 CSS 预处理语言，比如 SASS，但它不是 SASS，也没有人喜欢它。花哨的块分离器并不真正支持第三方 JavaScript 库，部分原因是这些工具早于 JavaScript 库生态系统的存在。

那都只是历史。你可以争辩说我们不应该走到这一步，但这并不能改变我们现在的处境。相反，有趣的问题是:我们现在去哪里？有几个选择。我的观点肯定会被我更喜欢的观点所偏袒。

第一个诱人的选择是放弃这个被毁坏的星球，建立一个新的甚至不涉及 JavaScript 的星球。如果我们在 GWT(一个将 Java 编译成 JavaScript 的谷歌项目)或 Dart(一个将一种新语言编译成 JavaScript 的谷歌项目)或 WASM 或[在此插入你最喜欢的语言— Clojure？哈克斯？榆树？]我们根本不需要担心 JavaScript！

作为一个 PL 爱好者，我非常喜欢这个想法。我想给它应有的仔细分析，但这篇文章足够长，我认为讨论将作为自己的文章。这里不是一个全面的反驳，而是一些世俗的担忧:采用不同的语言(1)对我们现有的数百万行代码没有任何作用——“从头开始用一种新语言重写”在某些情况下是正确的选择，但这很难成为最好地利用 gmail 工程师时间的理由——以及(2)对前面提到的我们想要雇用的有经验的前端程序员没有什么作用。

重写一切的反面就是什么都不改变。你可以正确地指出，公共 JavaScript 世界充满了业余代码和 leftpad 灾难。一个好的工程师总是能适应我们制作前端的特殊方式，我们总是能改进或构建更多自己的工具。我赞同这种观点。我认为在权衡的空间中有一个点，在这个点上构建我们自己的工具是有意义的，而在另一个点上，我们已经偏离主流如此之远，以至于我们的工具是一种负担。接下来的争论是关于我们在那个空间中的位置，我相信我们离后者太远了。我们受益于对 LLVM/Clang 的贡献，因为我们依赖 C++，但我们不会从构建自己的 LLVM 中获得太多额外的价值。

这将我引向中间的道路，这也是我的小团队一直在追求的:通过弄清楚如何使它与我们现有的代码库互操作，在有意义的地方增量地采用一些外部工具。这项任务并不有趣——我们不能扔掉遗留下来的烂摊子，然后“这次把它做好”——但我喜欢更谦虚地思考，向外看，而不是向内看。

我们从 Google JavaScript Galapagos 回到大陆的桥梁的第一部分是采用一个得到很好支持的静态检查器，它(1)不是自己开发的；(2)既流行，又与我们现有的代码相似；(3)设计成桥入 JavaScript(4)旨在支持最初激励我们定制工具的大规模开发。这个工具是打字稿。闭包编译器的优势在于它的优化输出，而 TypeScript 有很好的用户界面，根本没有优化。这两个工具是互补的，并且(通过一些工作)可以放在一起。

因为 TypeScript 已经大部分工作了——毕竟这是采用它的部分原因——我们获得了采用一种已建立的语言的许多好处，从 IDE 风格的代码完成到能够检查 StackOverflow 以获得答案。留给我们的工作主要是集成:允许我们的应用程序逐渐进入 TypeScript，而无需从头重写。我们整合到谷歌的构建系统中小心翼翼地进行增量编译，这对于大型应用程序来说至关重要；一个模块中不影响其导出 API 的更改不会导致下游模块重新编译。我们对闭包类型/模块系统的集成意味着 ES6 类型脚本模块可以[导入 Google-module-system 模块](https://github.com/angular/clutz)和[反向导入](https://github.com/angular/tsickle)，并保留(大部分)类型信息。[一家公司成功地使用我们发布的工具](https://www.lucidchart.com/techblog/2017/11/16/converting-600k-lines-to-typescript-in-72-hours/)自动翻译了他们的整个代码库，同时保留了他们缩小的输出。

在 Google 中，现在随处可见不同数量的 TypeScript 如果你使用谷歌产品，你很可能会与一些打字稿代码进行交互。TypeScript 本身是一系列有趣的妥协，平衡了静态类型编程语言和自由运行的 JavaScript 生态系统。但这就是我们工程师所做的:我们做出有趣的妥协，试图平衡不同的关注。我希望将来能写更多关于这些年来我们发现的一些有趣的角落。正如我在第一次开始走这条路的时候所写的，我认为 TypeScript 在设计空间中做了很好的权衡。

</main>