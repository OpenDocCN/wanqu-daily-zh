# 编织代码清理(第 1 部分)

> 原文:[http://number-none . com/blow/blog/programming/2016/07/16/braid _ code _ clean up _ 1 . html？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://number-none.com/blow/blog/programming/2016/07/16/braid_code_cleanup_1.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

我仍然在困惑如何正确地思考压缩中的一些想法，所以让我们休息一下，谈谈如何清理源代码。

为了减轻游戏未来的可维护性，有很多事情可以做。我将在这里详述其中的一些。我刚刚花了几个小时尝试了其中最明显的一个；我将首先列出已完成的任务，以及它们对源代码的影响。

在此过程之前，Braid 源代码是 95，366 行，使用以下方法计算:

```
cloc --no3 --by-file-by-lang 
```

与往常一样，报告的数字不包括注释和空行。这只是计算来自游戏的源代码，不包括第三方库，事实上缺少了游戏的一些部分，如着色器，在各种操作系统上构建和安装的脚本等。但这是一个很好的衡量程序规模的标准。

**目前完成的事情**。

**从游戏中删除一堆不用的代码:删除 10254 行。**当时，Braid 是使用“我的游戏库”的代码体构建的；我从来不知道 Braid 可能会使用什么代码，也可能不会使用什么代码，所以我只是把所有东西都留在那里，以防我可能会需要它。在这一点上，所有代码都足够旧了，即使我真的想重用其中的一部分，也应该重写它，或者至少给它一个好的外观。

删除的代码:优先级队列、时间平均和时间平均方差、浮点量化和编码、算术编码器、网络、网络数据包的字节打包、网格和骨架动画代码、三角形交集、Jenkins 哈希、crc32、三角形交集、三次样条拟合和编辑、视图截锥、两个不同的邻近网格、冰箱内存分配器、冗余目录导航代码、位数组。

**删除 Xbox-360 专用代码:删除 3，694 行。**去掉#ifdef XBOX360 包围的一堆特例代码。例如:关于用户资料，菜单，排行榜，xbox live 成就，从 xbox 界面启动 Speed Run 的特殊情况的恼人的 cert 要求。游戏也移植到了 PlayStation 3 上，但这是由一个不同分支的外部团队完成的，所以我现在不必担心这个问题。

取消演示功能/升级到“完整游戏”:删除 319 行。管理演示很复杂(在不支持演示的系统上，大多数系统都不支持演示，这使您必须管理的构建数量增加了 2 倍，并增加了许多复杂的细节)。此外，演示在今天并不是真正必要的；如果人们想了解一款游戏，他们可以在 YouTube 上看看，或者在网上看看很多人对这款游戏的看法。在 Steam 这样的平台上，玩家可以退回一款游戏(玩了不到两个小时)获得全额退款，因此演示的很大一部分原因已经消除了(你可以将演示视为一种不为糟糕的事情付费的方式，但退款也会这样做)。根据经验，在 Steam 上，很少有人再下载这个演示了。

这只删除了 319 行，但这 319 行包含了很多“如果”语句和游戏流程关键时刻的复杂性，所以这是一个相当不错的胜利。

从数据上来说，这也让我可以删除 3 个只在演示中使用的游戏关卡。在游戏数据中仍然有一些复杂的东西可以被删除(比如在演示中帮助控制游戏流程的各种实体上的成员变量)。还有一堆现在可以删除的字符串。

摆脱已经倒闭的非 Steam PC 在线出版商:删除了 31 行。移除温室，冲动，游戏门的 ifdefs。没有很多代码，也不是很复杂，但是，嘿，它现在不见了。

这就是我目前所做的一切。我们已经将代码行数从 95，366 减少到 81，068，这是一个好的开始。

这是有待清理的物品清单。我会在以后的文章中报道这些事件的影响。我当然也会想出更多的东西来清理。

**使用 C++11 初始化器初始化类成员；在适当的地方消除构造函数。在 C++11 之前，你必须在构造函数中独立于声明值的地方初始化值。如果您关心编译时间和可读的头文件，这些文件倾向于放在单独的文件中。这没有什么好的理由，我一直认为这是 C++中的一个基本问题，但它在 C++11 中得到了解决。据我所知，在某些情况下，你仍然不能做“正确的事情”(例如，如果你想初始化基类中的值)。这应该可以减少程序中的代码行数，并减少出错的可能性(因为初始化失败的可能性会减少)，但这也非常繁琐，所以我可能会分几部分来做。**

**消除位图 _ 加载器 _ 模块系统。**当我第一次组装我的“引擎”时，我知道我想要加载不同类型的位图。所以我建立了一个系统，其中有一个 Bitmap_Loader，你告诉它你想要加载什么文件名，它解析出扩展名，然后查看每个 Bitmap_Loader_Module 以确定它是否处理该扩展名。“好”的一点是，我可以通过将新文件放入项目来实现对新格式的支持，而项目的任何其他部分都不知道它们(因为新的 Bitmap_Loader_Modules 会通过一个全局变量的构造函数向 Bitmap_Loader 注册自己)。这是一种非常“抽象引擎”的思维方式，你知道吗，嗯。我的意思是，经过多年的经验，这种构造代码的方式并不比仅仅编辑一个查看文件扩展名并调用适当代码的硬编码过程更有用。(虽然不再有用，但它需要更多的精力来维护，需要更长的时间来编写——这里有样板代码，每个 Bitmap_Loader_Module 都必须符合一个 API，但这不是必需的)。

大大简化位图加载。最初，Braid 中的位图加载非常简单。但在项目接近尾声时，很明显这个游戏不适合 Xbox 360 的内存(它有 512MB 的物理内存，但当然一个游戏不能使用所有的内存)，即使所有的位图都被压缩为 DDS。一种选择是引入动态位图流，当你进入每一级时暂停，直到位图被加载。但是 Xbox 360 很慢，Xbox Live 游戏必须使用的文件格式是 *extra* 慢，这似乎会使许多事情复杂化，并对玩家的体验产生负面影响。相反，我选择让游戏适合内存。Jpeg 的压缩效果比 dds 好得多，所以我将大多数位图存储为 jpeg(在两个不同的文件中，一个用于颜色，一个用于 alpha，因为当时 jpeg 实际上不处理 4 通道图像)。但是我们还需要在 GPU 上保持小的东西，所以 jpeg 将被解码并作为两个不同的纹理上传到 GPU，一个用于 Y 通道，一个用于 CbCr 通道，CbCr 下采样就像在 JPEG 中一样。但是我们在 DXT 保留了角色动画，因为这些需要锐利的边缘。所以所有的着色器需要有两个变体，一个用于 DXT 纹理，一个用于 Y/CbCr 纹理的组合；所有关于设置纹理和应用着色器的游戏级逻辑也需要理解这一点。这让事情变得复杂了很多。(幸运的是，西恩·布瑞特在我们接近发货时间时做了所有这些事情，所以我能够专注于满足 Xbox 360 的认证要求)。最后，因为 jpeg 解压缩在 xbox 360 上不是特别快，所以游戏使用原始作业系统异步解压缩 JPEG；因为上面提到的“位图加载器模块”系统没有预见到这些，所以用这种方式工作的能力以一种丑陋的方式被侵入了那个系统。

这一切都正常，但未来并不美好。此外，还有性能影响(Y 和 CbCr 纹理以线性布局存储在 GPU 上，随着每一代 GPU 的发展，速度越来越慢。)所以我计划简化回一个方案，我们使用 DXT 或任何其他 GPU 理解的本地压缩格式，可能采用代码转换器库，如来自 [binomial.info](http://binomial.info) 的代码转换器库。

帧率和全屏模式的东西。这将是*有趣的*。在开发过程中，我非常清楚地意识到，我希望 Braid 具有一致的物理特性，而不管平台或帧速率如何(在控制台上，变化的帧速率并不是一个真正的问题，但在广泛的 PC 上，你不知道你将能够在一些随机的未知机器上运行多快。)似乎有理由说，60Hz 是目标帧速率，我们为此而设计，我们永远不会跑得更快。(“60Hz 对任何人来说应该都够了”)。我写了一个物理例程，打算每 1/60 秒运行一次，我认为这足以防止隧道效应。在游戏机上，我们总是以 60 的速度运行；在个人电脑上，我们将以 1/60 秒的倍数运行，我们的想法是，我们只需多次运行相同的物理步骤，这与许多帧每帧运行一次的结果一致。这就限制了我们在电脑上平均分配 60: 60Hz，30Hz，20Hz，15Hz，12Hz，10Hz 等帧速率。

在 PC 上，我需要选择这些帧速率中的一个并坚持下去，所以在启动时，游戏花费 0.7 秒渲染一个中等强度的测试场景，并查看它能够多快做到这一点(丢弃前几帧以丢弃非驻留纹理贴图或冷内存的任何效果)。然后，游戏将其帧速率设置为它认为可以持续达到的最高速率。如果在游戏过程中，它开始丢失那个帧速率，那么它会下降到下一个稳定的帧速率。

它实际上比这更复杂，因为有一个选项来消除视觉效果以获得速度，所以这个启动序列也尝试两种质量水平。还有一个将分辨率降低到一半的选项，所以启动序列也会尝试这样做(如果必要的话)。

在 Windows 上，因为调度程序很粗糙，不适合我们今天认为的可靠的多媒体应用程序，除非你同步到 60Hz 的显示信号，否则很难以 60Hz 的频率翻页。因为 Braid 使用 DirectX9，以 60Hz 同步显示器意味着进入全屏独占模式(因为你不能在窗口模式下进行 vsync)。这里的问题是 Windows 的全屏独占模式一直以来都是一个彻底的灾难，并且在支持问题列表中排在很高的位置。它会触发驱动程序错误，使你的游戏看起来失真和丑陋(因为出于某种原因，显示器和电视供应商决定，如果你切换到显示器支持的纵横比以外的纵横比，正确的做法是非比例地拉伸图像，以填充显示器的每个像素，~~fffffuuuuuuuuuuck yoouuuuuuuuuuuuuu 你这个混蛋~~)。它有时会导致车窗锁死。它会让你的显示器在尴尬的几秒钟内变黑并抖动。无论发生什么，几乎都不是好事。

因为所有这一切都太可怕了，现在的游戏倾向于以桌面已经有的任何帧速率和分辨率进行渲染——只是根本没有在视频模式上做手脚。这通常需要渲染比以前多得多的像素，或者渲染到屏幕外的表面并放大，但 GPU 现在很快，所以这不是什么大问题。但是，Braid 不一定能以直接的方式做到这一点(即使在切换到允许我们在窗口模式下 vsync 的较新的 DirectX 之后)，因为如果播放器的桌面刷新率不是上面列出的帧率之一，我们就不能 vsync！所以我们将不得不撕掉(这看起来很糟糕)或者改变显示频率(这可能会导致很多问题)。

“60Hz 对任何人来说都足够了”的假设当然也不再成立。144Hz 显示器非常受欢迎，G-Sync 是一种东西(尽管我知道没有人知道如何在 G-SYNC 显示器上正确渲染)，谁知道未来会发生什么。所以，下面的事情需要发生:

*   重写物理系统以在任意帧速率下产生一致的结果
*   更改显示代码以桌面分辨率和帧速率运行
*   更改 DX 版本以支持窗口模式下的 vsync(可能通过使用 DXGI，虽然这很可怕而且会引起问题，所以可能通过升级到 DX11，这也很讨厌)。

尽管如此，值得指出的是，在世界 4 中(时间随着你的移动而移动)，我们必须根据你移动的速度来模拟任意长的时间，尽管我在这里没有做任何超级愚蠢的事情(例如，我细分时间步长以尝试产生有点一致的结果)，但由于代码现在是结构化的，没有办法使结果与游戏的其余部分完全一致，因为你必然会看到 1/60 秒官方物理样本之间的结果。这似乎没有引起任何人注意的问题，所以可能只要物理时间步长低于某个大小，就没有人会抱怨。

**完成升级到 Visual Studio 2015 修复头文件混乱。**昨天换了 Visual Studio 2015。出于神秘的原因，启动程序不再编译，但其他一切都正常。需要修理发射器。需要为 Steam 安装设置 Visual Studio 2015 redist。我需要弄清楚微软这次在 Visual Studio 2015 中放置了什么定时炸弹，使软件更难可靠地分发(弄清楚 Windows XP 兼容性情况，弄清楚我需要关闭的任何其他选项，以禁用遥测技术，防止不可思议的不良依赖)。修复项目文件中永远丢失的头文件，这使得 Visual Studio 中的全局搜索和替换无效。

在我最新的作品中，我的目标是永远远离 Visual Studio，但这对 Braid 来说不会很快发生，所以我最好保持友好。

**去掉池，使用 Isolated_Heap_Pool。Pool 是一个简单的快速分配器，它的默认风格只是在后端使用 C 运行时的 malloc。Isolated_Heap_Pool 是它的变体，它为每个池创建一个单独的堆，这意味着您可以创建一堆池，然后销毁它们，而不用担心会导致碎片。这样做是因为在游戏机上，碎片是一个大问题。我也可以保持这种方式，因为它更干净，但是旧的池仍然被我的字体代码使用。因此，如果我改变字体代码(应该是微不足道的变化)，我可以删除 pool.cpp 和 pool.h。**

使 Entities_By_Type 使用数组而不是列表。删除列表。 List 是一种链表数据结构。在 Braid 中，每种实体都有一个该实体类型的所有实例的数组。通常游戏代码会遍历这样一个列表(“对于关卡中的每一个怪物，做以下事情。”)问题在于，在这种用例中(集合很少被修改，而遍历非常频繁)，链表不太适合缓存行为。所以，我想把它改成一个数组结构。这将是乏味的，因为许多网站遍历列表，即使他们使用宏来做这件事，列表有时会把它的头戳进用户代码。但也不会太差。我们已经对见证服务器进行了这种更改，这非常有帮助。

删除 add_color 和 multiply_color 的奇怪用法。在开发期间，我知道我想让屏幕有时变成黑色，有时变成白色。然而，GPU 速度太慢，我们不清楚是否能在大多数机器上进行 postpass。因此，渐黑是通过降低到 0 的每实体乘法颜色实现的，渐白是通过升高到 1 的每实体加法颜色实现的。这与全屏淡入淡出的效果并不完全相同，但它“足够接近”，没有人会注意到或抱怨。然而，这阻止了我们进行更复杂的过渡，传递这些额外的颜色会影响速度。如果我在后期处理中设置所有这些淡入淡出，代码会变得更简单。然后，在那之后，我们可以和他们一起做一些更有趣的事情。