# 坚实的围棋设计|戴夫·切尼

> 原文：<http://dave.cheney.net/2016/08/20/solid-go-design?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

*本文基于我在 2016 年 8 月 18 日发表的 GolangUK 主题演讲的文本。
YouTube 上的[有这次谈话的录音。](https://www.youtube.com/watch?v=zzAdEt3xZ1M)*

[此贴已由](http://www.jianshu.com/p/0aebd9618300) [【田】](https://github.com/llitfkitfk) *翻译成简体中文 *。谢谢郝好！*
*[本文由 Artem Zinoviev 翻译成俄文](https://habrahabr.ru/post/348852/)。谢谢 Artem！**

* * *

# 世界上有多少围棋程序员？

世界上有多少围棋程序员？想出一个数字，记在脑子里，我们会在演讲结束时再来讨论这个问题。

# 代码审查

这里谁把代码审查作为他们工作的一部分？[整个房间都举起了手，这是令人鼓舞的]。好吧，你为什么要做代码审查？[有人喊出“阻止不良代码”]

如果代码审查是为了捕捉坏代码，那么你如何知道你审查的代码是好的还是坏的呢？

现在，说“那个代码很丑”或“哇，那个源代码真漂亮”是没问题的，就像你可能会说“这幅画很漂亮”或“这个房间很漂亮”一样，但这些都是主观的术语，我正在寻找客观的方法来谈论好代码或坏代码的属性。

# 错误代码

在代码评审中，你可能会发现坏代码的哪些特性？

*   *刚性*。代码是刚性的吗？它有一个霸道的类型和参数的直夹克，使修改困难吗？
*   *脆弱*。代码脆弱吗？最轻微的变化会不会波及到代码库，造成巨大的破坏？
*   *不动的*。代码难重构吗？一次击键就能导入循环吗？
*   *复杂*。有没有为了有代码而有代码，事情是不是工程化过度了？
*   *啰嗦*。只是用代码很累吗？当你看着它的时候，你能说出这段代码想要做什么吗？

这些听起来是正面的话吗？你会高兴地看到在你的代码审查中使用这些词吗？

大概不会。

# 好的设计

但这是一个进步，现在我们可以说“我不喜欢这样，因为它太难修改了”，或者“我不喜欢这样，因为我不知道代码试图做什么”，但如何用积极的东西开头呢？

如果有一些方法来描述好的设计的属性，而不仅仅是坏的设计，并且能够用客观的术语来描述，这不是很好吗？

# 固体

2002 年 Robert Martin 出版了他的书， [*【敏捷软件开发、原则、模式和实践】*](https://www.amazon.co.uk/dp/0135974445/ref=pd_lpo_sbs_dp_ss_2/253-1946330-6751666?pf_rd_m=A3P5ROKL5A1OLE&pf_rd_s=lpo-top-stripe&pf_rd_r=23C4AHYV7EXGYHKD6G8Q&pf_rd_t=201&pf_rd_p=569136327&pf_rd_i=0132760584) 。在里面，他描述了可重用软件设计的五个原则，他称之为坚实原则，以它们名字的第一个字母命名。

*   单一责任原则
*   开/闭原理
*   利斯科夫替代原理
*   界面分离原理
*   从属倒置原则

这本书有点过时了，它谈论的语言是十多年前使用的语言。但是，也许坚实的原则的某些方面可能会给我们一个关于如何谈论一个设计良好的围棋程序的线索。

这就是我今天早上想花点时间和你们讨论的。

# 单一责任原则

固体的第一个原则，即 S，是单一责任原则。

> 一个类应该有且只有一个改变的理由。罗伯特·马丁

现在，Go 显然没有类——相反，我们有更强大的组合概念——但如果你能超越类这个词的使用，我认为这里有一些价值。

为什么一段代码只有一个改变的原因很重要？嗯，就像你自己的代码可能会改变的想法一样令人沮丧，更令人沮丧的是发现你的代码所依赖的代码正在你脚下改变。当你的代码必须改变时，它应该是对直接刺激的反应，而不应该是间接伤害的受害者。

因此，具有单一职责的代码更改的理由最少。

## 耦合与凝聚

描述改变一个软件的难易程度的两个词是耦合和内聚。

耦合只是一个描述两个事物一起变化的词——一个事物的运动引起另一个事物的运动。

一个相关但独立的概念是凝聚力，一种相互吸引的力量。

在软件的上下文中，内聚性是描述代码块自然地相互吸引的属性。

为了描述 Go 程序中的耦合和内聚单元，我们可能会谈到函数和方法，这在讨论 SRP 时很常见，但我相信这是从 Go 的包模型开始的。

## 包名

在 Go 中，所有代码都存在于一个包中，一个设计良好的包从它的名字开始。包的名称既是对其用途的描述，也是名称空间前缀。来自 Go 标准库的一些好的包的例子可能是:

*   `net/http`，提供 http 客户端和服务器。
*   `os/exec`，运行外部命令。
*   `encoding/json`，实现 JSON 文档的编码和解码。

当您在自己的包中使用另一个包的符号时，这是通过“import”声明来实现的，它在两个包之间建立了源代码级的耦合。他们现在互相认识了。

## 错误的包名

这种对名字的关注不仅仅是卖弄学问。一个命名不当的包错过了列举其用途的机会，如果它确实曾经有过用途的话。

`package server`提供什么？…嗯，希望是服务器，但是是哪种协议呢？

`package private`提供什么？我不该看到的东西？它应该有什么公共符号吗？

而`package common`，就像它的犯罪伙伴`package utils`一样，经常被这些其他罪犯发现靠近。

像这样的包裹成了杂物堆的垃圾场，因为他们有许多责任，所以他们经常无故更换。

## Go 的 UNIX 哲学

在我看来，如果不提到道格·麦克洛伊的 Unix 哲学，任何关于解耦设计的讨论都是不完整的；小而锋利的工具组合起来解决更大的任务，通常是原作者没有预见到的任务。

我认为 Go 包体现了 UNIX 哲学的精神。实际上，每个 Go 包本身就是一个小的 Go 程序，一个单一的变化单元，有一个单一的责任。

# 开/关原则

第二个原理，O，是 Bertrand Meyer 在 1988 年写的开闭原理:

> 软件实体应该对扩展开放，但对修改关闭。Bertrand Meyer，面向对象软件构造

这个建议如何适用于 21 年后写的语言？

```
package main

type A struct {
        year int
}

func (a A) Greet() { fmt.Println("Hello GolangUK", a.year) }

type B struct {
        A
}

func (b B) Greet() { fmt.Println("Welcome to GolangUK", b.year) }

func main() {
        var a A
        a.year = 2016
        var b B
        b.year = 2016
        a.Greet() // Hello GolangUK 2016
        b.Greet() // Welcome to GolangUK 2016
}
```

我们有一个类型`A`，有一个字段`year`和一个方法`Greet`。我们有第二种类型，*嵌入*一个`A`，因此调用者看到`B`的方法覆盖在`A`的方法上，因为`A`作为字段嵌入在`B`中，并且`B`可以提供自己的`Greet`方法，模糊了`A`的方法。

但是嵌入不仅仅针对方法，它还提供了对嵌入类型的字段的访问。如您所见，因为`A`和`B`都在同一个包中定义，`B`可以访问`A`的私有`year`字段，就好像它是在`B`中声明的一样。

所以嵌入是一个强大的工具，它允许 Go 的类型可以扩展。

```
package main

type Cat struct {
        Name string
}

func (c Cat) Legs() int { return 4 }

func (c Cat) PrintLegs() {
        fmt.Printf("I have %d legs\n", c.Legs())
}

type OctoCat struct {
        Cat
}

func (o OctoCat) Legs() int { return 5 }

func main() {
        var octo OctoCat
        fmt.Println(octo.Legs()) // 5
        octo.PrintLegs()         // I have 4 legs
}
```

在这个例子中，我们有一个`Cat`类型，它可以用它的`Legs`方法计算它的腿的数量。我们将这个`Cat`类型嵌入到一个新类型中，一个`OctoCat`，并声明`Octocat` s 有五条腿。然而，尽管`OctoCat`定义了自己的`Legs`方法，返回 5，但是当调用`PrintLegs`方法时，它返回 4。

这是因为`PrintLegs`是在`Cat`类型上定义的。它把一个`Cat`作为它的接收者，因此它分派给`Cat`的`Legs`方法。`Cat`不知道它被嵌入的类型，所以它的方法集不能被嵌入改变。

因此，我们可以说，Go 的类型，当*对扩展*开放时，*对修改*关闭。

事实上，Go 中的方法只不过是一个带有预先声明的形式参数(它们的接收者)的函数的语法糖。

```
func (c Cat) PrintLegs() {
        fmt.Printf("I have %d legs\n", c.Legs())
}

func PrintLegs(c Cat) {
        fmt.Printf("I have %d legs\n", c.Legs())
}
```

接收器就是你传递给它的东西，函数的第一个参数，因为 Go 不支持函数重载，`OctoCat` s 不能替代常规的`Cat`，这就引出了下一个原则。

# 利斯科夫替代原理

由 Barbara Liskov 创造的 Liskov 替代原则，粗略地说，如果两种类型的人表现出的行为使得打电话的人无法区分，那么这两种类型是可以替代的。

在基于类的语言中，Liskov 的替换原则通常被解释为具有各种具体子类型的抽象基类的规范。但是 Go 没有类，也没有继承，所以不能用抽象的类层次来实现替换。

## 接口

相反，替代是 Go 接口的权限。在 Go 中，不要求类型指定它们实现一个特定的接口，相反，任何类型实现一个接口，只要它有签名与接口声明匹配的方法。

我们说在 Go 中，接口是隐式满足的，而不是显式满足的，这对它们在语言中的使用方式有着深远的影响。

设计良好的界面更可能是小界面；流行的习语是一个只包含单一方法的接口。从逻辑上讲，小接口导致简单的实现，因为否则很难实现。这导致了由简单实现组成的包，这些实现通过*公共行为*连接起来。

## io。读者

```
type Reader interface {
        // Read reads up to len(buf) bytes into buf.
        Read(buf []byte) (n int, err error)
}
```

这让我想到了`io.Reader`，这是我最喜欢的围棋界面。

木卫一。阅读器界面非常简单；`Read`将数据读入提供的缓冲区，并向调用者返回读取的字节数，以及读取过程中遇到的任何错误。看似简单却很强大。

因为`io.Reader`处理任何可以用字节流表示的东西，我们可以在任何东西上构造读取器；常量字符串、字节数组、标准输入、网络流、gzip 格式的 tar 文件、通过 ssh 远程执行的命令的标准输出。

所有这些实现都可以互相替换，因为它们完成了相同的简单契约。

因此，应用于围棋的利斯科夫替代原理可以用已故的吉姆·威里奇的这句可爱的格言来概括。

> 要求不多，承诺不少。吉姆·威里奇

这是对第四个固体原理的一个很好的继承。

# 界面分离原理

第四个原则是界面分离原则，即:

> 不应该强迫客户依赖他们不使用的方法。罗伯特·马丁

在 Go 中，接口分离原则的应用可以指的是隔离一个函数完成其工作所需的行为的过程。作为一个具体的例子，假设我被分配了一个任务，编写一个将`Document`结构持久化到磁盘的函数。

```
// Save writes the contents of doc to the file f.
func Save(f *os.File, doc *Document) error
```

我可以定义这个函数，让我们称它为`Save`，它以一个`*os.File`作为目的地来写提供的`Document`。但是这有几个问题。

`Save`的签名排除了将数据写入网络位置的选项。假设网络存储很可能成为以后的需求，那么这个函数的签名将不得不改变，从而影响它的所有调用者。

因为`Save`是直接用磁盘上的文件操作的，所以测试起来并不愉快。为了验证其操作，测试必须在文件被写入后读取其内容。此外，测试必须确保`f`被写入一个临时位置，并且之后总是被删除。

`*os.File`还定义了许多与`Save`无关的方法，比如读取目录和检查路径是否是符号链接。如果我们的`Save`函数的签名可以只描述`*os.File`中相关的部分，那将是非常有用的。

对于这些问题我们能做些什么呢？

```
// Save writes the contents of doc to the supplied ReadWriterCloser.
func Save(rwc io.ReadWriteCloser, doc *Document) error
```

使用`io.ReadWriteCloser`,我们可以应用接口分离原则来重新定义`Save`,以获得一个描述更一般的文件形式的东西的接口。

有了这一改变，任何实现了`io.ReadWriteCloser`接口的类型都可以替代之前的`*os.File`。这使得`Save`的应用更加广泛，并且向`Save`的呼叫者澄清了`*os.File`类型的哪些方法与其操作相关。

作为`Save`的作者，我不再选择在`*os.File`上调用那些不相关的方法，因为它隐藏在`io.ReadWriteCloser`接口之后。但是我们可以把接口分离的原则做得更进一步。

首先，如果`Save`遵循单一责任原则，它不太可能读取刚刚编写的文件来验证其内容——这应该是另一段代码的责任。所以我们可以将传递给`Save`的接口规范缩小到只写和关闭。

```
// Save writes the contents of doc to the supplied WriteCloser.
func Save(wc io.WriteCloser, doc *Document) error
```

其次，通过为`Save`提供一个关闭其流的机制，我们继承了这个机制，希望它看起来像一个文件形状的东西，这就提出了一个问题:在什么情况下`wc`将被关闭。可能`Save`会无条件调用`Close`，也可能成功的情况下会调用`Close`。

这给`Save`的调用者带来了一个问题，因为它可能希望在文档被写入后向流中写入额外的数据。

```
type NopCloser struct {
        io.Writer
}

// Close has no effect on the underlying writer.
func (c *NopCloser) Close() error { return nil }
```

一个简单的解决方案是定义一个新类型，嵌入一个`io.Writer`并覆盖`Close`方法，防止`Save`关闭底层流。

但是这可能会违反里斯科夫替换原则，因为`NopCloser`实际上并没有关闭任何东西。

```
// Save writes the contents of doc to the supplied Writer.
func Save(w io.Writer, doc *Document) error
```

一个更好的解决方案是重新定义`Save`,只接受一个`io.Writer`,完全剥夺它做任何事情的责任，除了将数据写入流。

通过将接口分离原则应用到我们的`Save`函数中，结果同时是一个就其需求而言最具体的函数——它只需要一个可写的东西——并且是其函数中最通用的，我们现在可以使用`Save`将我们的数据保存到任何实现`io.Writer`的东西中。

> Go 的一个重要经验是**接受接口，返回结构**。杰克·林达穆德

退一步说，这句话是一个有趣的迷因，在过去几年里一直渗透在 Go 时代精神中。

这个 tweet 大小的版本缺乏细微差别，这不是杰克的错，但我认为它代表了第一个可防御的 Go 设计知识。

# 从属倒置原则

最后一个坚实的原则是依赖性倒置原则，它规定:

> 高层模块不应该依赖低层模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。罗伯特·马丁

但是，在实践中，依赖倒置对 Go 程序员意味着什么呢？

如果您已经应用了我们到目前为止讨论过的所有原则，那么您的代码应该已经被分解成独立的包，每个包都有一个明确定义的职责或目的。你的代码应该用接口来描述它的依赖关系，并且那些接口应该被分解成只描述那些函数需要的行为。换句话说，应该没什么可做的了。

所以我认为马丁在这里谈论的，当然是 Go 的上下文，是你的导入图的结构。

在 Go 中，你的导入图必须是非循环的。不遵守这个非循环的要求是编译失败的原因，但更严重的是代表设计中的严重错误。

在所有条件相同的情况下，一个设计良好的围棋程序的输入图应该是一个宽而相对平坦的图，而不是又高又窄的图。如果您有一个包，它的功能不能在没有另一个包的帮助下运行，这可能是代码没有很好地沿着包边界分解的一个迹象。

依赖倒置原则鼓励你将细节的责任推给你的`main`包或顶层处理程序，尽可能高的沿着导入图向上，让底层代码处理抽象——接口。

# 立体围棋设计

概括地说，当应用于 Go 时，每一个坚实的原则都是关于设计的强有力的陈述，但是放在一起，它们有一个中心主题。

单一责任原则鼓励您将功能、类型和方法组织成包，展示自然的内聚性；这些类型属于同一类，函数服务于一个目的。

开放/封闭原则鼓励您使用嵌入将简单类型组合成更复杂的类型。

Liskov 替换原则鼓励您根据接口而不是具体类型来表达包之间的依赖关系。通过定义小接口，我们可以更加确信实现将忠实地满足它们的契约。

接口替换原则进一步发展了这一思想，并鼓励您定义仅依赖于所需行为的函数和方法。如果你的函数只需要一个具有单一方法的接口类型的参数，那么这个函数很可能只有一个责任。

依赖倒置原则鼓励你将你的包所依赖的知识从编译时转移到运行时——在 Go 中，我们看到一个特定的包使用的`import`语句的数量减少了。

如果你要总结这个演讲，可能会是:接口让你将坚实的原理应用到 Go 程序中。

因为接口让程序员描述他们的包提供了什么——而不是它是如何做的。这只是“解耦”的另一种说法，而这确实是目标，因为松散耦合的软件更容易改变。

正如桑迪·梅斯指出的:

> 设计是一种编排代码的艺术，它需要今天**有效**，并且永远**易于更改**。
> –桑迪·梅斯

因为如果 Go 将成为一种公司长期投资的语言，那么 Go 程序的维护，它们可以改变的容易程度，将是他们做出决定的一个关键因素。

# 乐章结尾部

最后，让我们回到我开始演讲时提出的问题上来；世界上有多少围棋程序员？这是我的猜测:

> 到 2020 年，围棋开发者将达到 50 万人。我

五十万围棋程序员会用他们的时间做什么？很明显，他们会写很多 Go 代码，如果我们诚实地说，并不是所有的代码都是好的，有些会很糟糕。

请理解，我这样说并不是残酷的，但是，在座的每一个有过其他语言开发经验的人——你们来自的语言，将要去的语言——都从自己的经历中知道，这个预测有一定的真实性。

> 在 C++中，有一种更小、更简洁的语言正在努力发展。
> –比雅尼·斯特劳斯特鲁普，C++的设计和发展

所有 Go 程序员使我们的语言成功的机会直接取决于我们的集体能力，即不要把事情搞得一团糟，以至于人们开始谈论他们今天对 C++开玩笑的方式。

嘲笑其他语言臃肿、冗长和过于复杂的叙述，可能有一天会变成 Go，我不想看到这种情况发生，所以我有一个请求。

Go 程序员需要开始少谈框架，多谈设计。我们需要停止不惜一切代价关注性能，而是不惜一切代价关注重用。

我想看到的是人们谈论如何使用我们今天拥有的语言，不管它的选择和限制，来设计解决方案和解决真正的问题。

我想听的是人们谈论如何以一种设计良好的、解耦的、可重用的、最重要的是对变化敏感的方式来设计 Go 程序。

# …还有一件事

现在，很高兴你们中的许多人今天能在这里听听众多演讲者的演讲，但现实是，无论这个会议发展到什么程度，与使用 Go 的人数相比，我们只是很小的一部分。

因此，我们需要告诉世界上的其他人，好的软件应该如何编写。好的软件，可组合的软件，可以修改的软件，并使用 Go 向他们展示如何修改。从你开始。

我希望你开始谈论设计，也许用我在这里提出的一些想法，希望你会做自己的研究，并将这些想法应用到你的项目中。然后我要你:

*   写一篇关于它的博文。
*   教一个工作坊关于你做了什么。
*   写一本关于你所学的书。
*   明年再来参加这个会议，谈谈你的成就。

因为通过做这些事情，我们可以建立一种 Go 开发者的文化，他们关心那些被设计为持久的程序。

谢谢你。