# 共享代码的危险——INNOQ

> 原文：<https://www.innoq.com/en/blog/the-perils-of-shared-code/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>



通往地狱的道路往往是由良好的意愿铺成的。我看到人们在各种软件项目中走过的一条这样的道路是通过库的方式在微服务之间共享代码。在几乎每一个组织寻求微服务架构的项目中，个人团队和开发人员都希望他们的微服务基于某个核心库。显然，尽管随之而来的问题早已为人所知，但许多人仍然没有意识到。在这篇博客文章中，我想研究为什么使用这样一个库可能听起来很有吸引力，为什么它会有问题，以及如何减轻这些问题。

我认为通过库共享代码有两个主要目的:共享领域逻辑和共享基础设施层的抽象:

1.  **共享域模型:**域模型的一个特定部分在两个或多个*有界上下文*之间是公共的，因此不用一次又一次地实现它，您消除了重复的需要和引入该域逻辑的不一致实现的可能性。通常，人们想要共享的域模型部分是核心域或一个或多个通用子域。在领域驱动设计行话中，这也被称为*共享内核*。通常，您会在这里找到类似于*会话*和认证逻辑的概念，但不限于此。一个相关的方法是*规范数据模型*。
2.  **基础设施层抽象:**您希望避免一次又一次地为基础设施层实现有用的抽象，所以您将它们放入一个库中。通常，这些库在数据库访问、消息传递和序列化等方面提供了统一的方法。

他们的动机是一样的——避免重复，也就是说，遵循 *DRY* 原则(“不要重复自己！”).实现这些东西有几个好处:

*   你不会把宝贵的时间花在已经解决的问题上。
*   采用统一的方式发送消息、访问数据库等。意味着当开发人员需要读取或修改其他开发人员最初创建的微服务中的代码时，他们可以很容易地找到自己的方式。
*   您不会有行为上略有不同的业务逻辑或基础设施关注点的不同实现。相反，有一个规范的实现做正确的事情。

理论上听起来很棒的东西不会没有自身的问题，这些问题可能比你试图用你的图书馆解决的问题更痛苦。Stefan Tilkov 已经详细解释了为什么应该避免使用规范数据模型。除此之外，让我指出几个其他问题。

通常，似乎有一个隐含的假设，将东西放入库中意味着您永远不必担心服务使用错误或过时的实现，因为它们只需要将对库的依赖更新到最新版本。

每当你依赖于通过将所有微服务更新到相同的新版本库来一致地改变一些行为时，你就在它们之间引入了强耦合。您失去了微服务的一个主要优势，即让它们独立发展和部署的能力。

我见过这样的情况，所有的服务必须一起部署才能正常工作。如果你达到了这种状态，不可否认你实际上已经建立了一个分布式的整体。

一个流行的例子是使用基于服务 API 的代码生成，以便为您的服务提供一个客户端库。比你想象的更常见的是，开发人员试图滥用它来进行突破性的改变，因为依赖的服务“仅仅”需要使用他们客户端库的新版本。这不是你如何发展一个分布式系统的方式。

库，尤其是那些旨在为基础设施问题提供通用解决方案的库，通常还有一个额外的问题:它们附带了它们所依赖的一整套额外的库。你的库的可传递依赖树越大，导致俗称依赖地狱的噩梦的概率就越高。由于您的微服务可能需要自己的额外依赖项，而这些依赖项又具有传递性依赖项，因此它们中的一些会传递性地引入某个库的冲突版本只是时间问题，并且简单地在不同版本之间进行选择是不可能的，因为它们是二进制不兼容的。

当然，你的解决方案可能是简单地提供你的微服务可能需要的所有库，作为你的核心库的依赖。这仍然意味着你的微服务不能独立发展，例如升级到他们所依赖的特定库的更高版本——它们都与你的核心库的发布周期保持一致。除此之外，当事实上他们可能只需要其中的几个服务时，你为什么要在每个服务上强加一大堆依赖呢？

我所见过的库通常是由一个或多个架构师强加给开发人员的，采用自顶向下的库设计方法。

通常，在这种情况下发生的事情是，由该库公开的 API 过于严格和不灵活，或者使用了错误的抽象级别，因为它们是由对不同真实世界用例的广泛范围不够熟悉的人设计的。这样的库经常会让不得不忍受它的开发人员感到沮丧，也会让人们试图绕过库的限制。

强制库带来的一个最明显的缺点是，这使得切换到不同的编程语言(或平台，如 JVM 或。NET)，再次失去了微服务架构的一个优势，即选择最适合给定问题的技术的能力。如果你后来意识到你终究需要这种语言或平台多样性，你必须发明各种奇怪的拐杖。例如，网飞提出了 Prana T1，这是一个与非 JVM 服务并行运行的 sidecar，为它们提供了一个到网飞技术栈的 HTTP API。

通过库共享代码会带来很多问题，最极端的解决方案就是根本没有这样的库。如果你这样做，你将不得不做一些复制粘贴或者为新的微服务提供一个模板项目，以便把你的服务从上述的锁步中解放出来。这既可以针对基础设施代码，也可以针对域模型的共享内核。事实上，在他关于领域驱动设计的经典蓝皮书中，Eric Evans 提到，通常，“团队在内核的单独副本上进行更改，每隔一段时间与另一个团队集成”。共享内核不一定是一个库。

如果你不喜欢复制粘贴的想法，那也没关系。毕竟，如上所述，通过库共享代码肯定有好处。在这种情况下，需要考虑一些重要的事情:

试着把你的大共享库分成一组非常小的、高度集中的库，每个库解决一个特定的问题。尽量让这些库成为零依赖库，只依赖语言的标准库。是的，仅仅根据你的语言的标准库来编程并不总是令人愉快的，但是对于你公司中的所有团队(或者甚至超出你公司，如果你的库是开源的)来说，巨大的好处显然超过了这个小小的不便。

当然，零依赖并不总是可能的，特别是对于基础设施问题。对于这些，最小化每个小型库所需的依赖性。此外，有时提供与另一个库的绑定或集成作为一个独立的工件是有意义的，独立于库的核心。

不要相信服务会在特定的时间点更新到共享库的最新版本。换句话说，不要强迫团队更新库，而是让他们按照自己的节奏自由更新。这可能需要您以向后和向前兼容的方式更改您的库，但是它解耦了您的服务，不仅为您提供了微服务架构的运营成本，还提供了一些好处。

如果可能的话，不仅要避免强制升级库，还要让库的使用是可选的。

最后，如果你想要共享库，我见过的成功项目都是使用自底向上的方法。不要让象牙塔架构师设计在现实世界中几乎不可用的库，而是让您的团队实现他们的微服务，当出现一些已经在多个服务的生产中证明了自己的常见模式时，将它们提取到库中。

