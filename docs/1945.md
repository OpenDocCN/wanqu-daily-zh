# 渐进式版本控制

> 原文:[http://allinthehead.com/retro/373/progressive-versioning?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://allinthehead.com/retro/373/progressive-versioning?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

当你运行一个软件即服务的 web 应用程序时，你不需要过多考虑的一件事就是软件版本号。一旦新功能和修复程序准备就绪，您就可以推出它们，因为客户不需要就更新做出有意识的决定。他们总是在最新的版本上。

对于桌面应用程序或像 [Perch](https://grabaperch.com/) 这样的本地软件，版本号有点双重用途。首先，他们是代码版本的技术符号，但其次，他们执行营销功能。为了鼓励用户更新(也许*会付钱给*来更新)，销售和市场活动自然会暂停软件版本号的计时。

多年来，大型软件公司使用了不同的策略来尝试分离版本号的这两种用法。在 90 年代，微软从使用 Windows 3.1 的版本号到使用年份(Windows 95、98、2000、Server 2003)，再到古怪的(XP)和荒谬的(Vista！)一直到版本号(Windows 7、8、10)。苹果在 Mac OS 10.0 到 10.8 中使用大猫的名字，然后改用加州地名，总是伴随着真实的版本号。

这些年来，有一件事变得很清楚；您不能取消软件版本与其版本号的链接。你就是不能。如果你的软件版本控制得很好，那么特性和版本号是密不可分的。

在过去的六年左右的时间里，我们一直在 Perch 上使用[语义版本控制](http://semver.org/),总体来说效果不错。我们目前正在进行主要版本 2，我们在 2.x 中推出了新的主要功能。我们所有的营销推广都基于 2.x 功能发布，以鼓励用户来获得免费更新。

当然，我们不会每天都发布新的次要特性，所以无论我们的主要特性是什么，每个 2.x 版本都会包含多个相关的改进。这是我们大力鼓励用户更新的机会，所以我们试图一次性捆绑许多令人兴奋的功能。

然而，这也带来了一系列的问题。让我们提醒自己语义版本化是如何工作的:

`MAJOR.MINOR.PATCH`

*补丁*发布应该只针对 bug 发布。这自然地将您的开发置于发布和细化阶段的瀑布式循环中。您花一段时间开发新特性，发布它们，然后通过修补 bug 进行改进。

## 稳定波

这可能产生的第一个问题是你可以称之为*稳定波。*新的特性会带来新的漏洞，而且漏洞也有可能出现在现有代码库的任何被变更触及的部分。你发布了新的`1.1.0`版本，它有令人兴奋的新东西，但可能会有问题。

随着连续的`1.1.1`发布，事情开始稳定，然后`1.1.2`发布，直到代码库稳定下来，产品再次变得良好和稳定。就在你到达稳定点的时候——如果你愿意的话，也可以说是顶峰——你驾驶`1.2.0`号，波浪破碎，不得不重新开始。

## 大揭秘

第二个问题源于批量变更和特性以进行大规模发布。除非你有并行处理多个特性的罕见能力，否则你不可避免地会得到一堆已经完成的工作，并等待一个大的展示。

一直以来，当这些新功能准备就绪并等待时，它们并不在客户手中。它们没有被使用，那些边缘情况的错误也没有被发现。取而代之的是，你在一个大揭露中一次全部出货，一次击中你所有的 bug，并且以一个稳定性下降结束。

## 不同类型的版本控制

那么答案是什么呢？毫无疑问，这就是我提出的一劳永逸解决问题的妙方。抱歉，但是你运气不好。但我们要尝试的是。这就是我所说的*渐进式版本控制*，它非常类似于语义版本控制，除了补丁:

`MAJOR.MINOR.PROGRESS`

关键的区别在于，不是以一个结果(一套完整的错误特性)开始一个小版本，而是以一个目标开始。这个目标可能类似于*1.2 版增加了导出功能。*最终目标可能是导出各种文档格式。

你做了一些工作——也许添加一个 PDF 导出——并发布为 1.2.0。立即，任何需要 PDF 导出的客户都有工作可做。1.2.1 可能会增加 MS Word 导出，修复 Windows 上 Acrobat 中 PDF s 的一个 bug。1.2.2 可能会添加 Excel 导出，并修补与 for Open Office 读取 Word 文件的兼容性缺陷。

重点是这个。只有当你达到 1.3 时，1.2 次版本才是完整的。在你的`x.y.0`版本中发布完整的特性集是没有压力的——那只是次要特性的*开始*的沙地上的标记。

历史告诉我们，尽早发布是一种很好的开发方式，这构建了一个版本控制结构来支持这种方法。在所有其他方面，语义版本兼容性原则仍然适用。您的次要版本需要规划接口，以便*进度*版本不会破坏向后兼容性。

至于营销方面，还是给我们一个版本挂个话。*1.2 版具有文档导出功能！*这也可能会给一些较小的功能提供更小、更频繁的营销机会，否则这些功能在发布时会被掩盖。

这会有帮助吗？老实说，到目前为止完全没有测试过。我们正在转向 Perch 和 Perch Runway 2.9 的渐进式版本控制，我们将于本月开始。这只是一个想法，我会让你知道进展如何。

不过有一件事是肯定的。编程只有三个难题。缓存失效，命名事物，以及其他一切。