# 每个计算机科学专业的学生都应该知道的

> 原文:[http://matt.might.net/articles/what-cs-majors-should-know/?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://matt.might.net/articles/what-cs-majors-should-know/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

## 投资组合与简历

从工程和数学中脱颖而出的计算机科学项目采取了一种基于简历的方式来雇佣他们的毕业生。

一份简历并不能说明一个程序员的能力。

每个计算机科学专业的学生都应该建立一个*作品集*。

文件夹可以像个人博客一样简单，每个项目或成就都有一篇文章。一个更好的组合应该包括每个项目的页面，以及可公开浏览的代码(可能托管在 github 或 Google code 上)。

对开源的贡献应该被链接和记录。

代码文件夹允许雇主直接判断能力。

GPA 和简历没有。

教授应该设计课程项目以加深对文件夹的印象，学生在每门课程结束时，应该花时间更新它们。

### 例子

## 技术交流

计算机科学中的独狼是濒危物种。

现代计算机科学家必须练习有说服力地、清晰地向非程序员传达他们的想法。

在较小的公司里，一个程序员能否把自己的想法传达给管理层可能会决定公司的成败。

不幸的是，这不是增加一门课就能解决的事情(尽管扎实的技术交流课程不会有坏处)。

更多的课程需要给学生提供机会来展示他们的作品，并通过口头报告来捍卫他们的观点。

### 具体建议

我建议学生们掌握一种演示工具，如 PowerPoint 或(我最喜欢的)Keynote。(抱歉，虽然我很喜欢它们，但是基于 LaTeX 的表示工具太静态了。)

在制作精美的数学文档方面，LaTeX 是无与伦比的。所有技术课程的书面作业都应该用 LaTeX 提交。

### 推荐阅读

## 工程核心

计算机科学不完全是工程学。

但是，已经够近了。

计算机科学家*将*发现自己与工程师一起工作。

计算机科学家和传统工程师需要说同一种语言——一种植根于实分析、线性代数、概率和物理的语言。

计算机科学家应该通过电磁学来研究物理。但是，要做到这一点，他们需要学习多元微积分，(以及微分方程)。

在构建声音模拟时，对概率和线性代数的掌握是非常宝贵的。在解释结果时，没有什么可以替代对统计学的深刻理解。

### 推荐阅读

## Unix 哲学

计算机科学家应该熟悉并实践 Unix 的计算哲学。

Unix 哲学(与 Unix 本身相反)强调语言抽象和组合，以实现计算。

实际上，这意味着熟悉命令行计算、文本文件配置和无 IDE 软件开发的概念。

### 具体建议

鉴于 Unix 系统的流行，今天的计算机科学家应该能够熟练掌握基本的 Unix，包括能够:

*   导航和操作文件系统；
*   用管道组合进程；
*   舒服地用`emacs` *和* `vim`编辑一个文件；
*   创建、修改和执行软件项目的生成文件；
*   编写简单的 shell 脚本。

学生们会拒绝 Unix 哲学，除非他们理解它的力量。因此，最好要求学生完成 Unix 具有相对优势的有用任务，例如:

*   找出给定目录中占用空间最多的五个文件夹。
*   报告计算机上重复的 MP3(按文件内容，而不是文件名)。
*   取一个名字和姓氏都是小写字母的名字列表，并适当地调整它们的大写字母。
*   查找所有以`x`为第二个字母，以`n`为倒数第二个字母的英语单词。
*   通过网络将您的麦克风输入直接发送到另一台计算机的扬声器。
*   对于给定的目录，用下划线替换文件名中的所有空格。
*   报告最近十次来自特定 IP 地址的对 web 服务器的错误访问。

### 推荐阅读

## 系统管理

一些计算机科学家嘲笑系统管理是一项“IT”任务。

人们的想法是，计算机科学家可以自学如何做技术人员能做的任何事情。

这是真的。(理论上。)

然而，这种态度是错误的:计算机科学家必须能够胜任和安全地管理他们自己的系统和网络。

软件开发中的许多任务不经过系统管理员就能最有效地执行。

### 具体建议

每个现代计算机科学家都应该能够:

*   安装和管理 Linux 发行版。
*   配置和编译 Linux 内核。
*   用`dig`、`ping`和`traceroute`排除连接故障。
*   编译和配置像 apache 这样的 web 服务器。
*   编译和配置一个类似 bind 的 DNS 守护进程。
*   用文本编辑器维护网站。
*   [切割并卷曲一根网线](http://matt.might.net/articles/how-to-make-your-own-cat-5-ethernet-cable/)。

### 推荐阅读

## 编程语言

编程语言随着太阳周期而兴衰。

程序员的职业生涯不应该。

虽然教授与雇主相关的语言很重要，但学生学会如何自学新语言也同样重要。

学习如何学习编程语言的最好方法是学习多种编程语言和编程范例。

学习第 n 种语言的难度是第( *n-1* 种语言难度的一半。

然而，要真正理解编程语言，你必须实现一种语言。理想情况下，每个计算机科学专业的学生都应该选修编译器课程。至少，每个计算机科学专业的学生都应该实现一个解释器。

### 特定语言

以下语言提供了范例和实际应用的合理组合:

*   球拍；
*   c；
*   JavaScript
*   吱吱声；
*   Java
*   标准毫升；
*   Prolog
*   Scala
*   哈斯克尔；
*   c++；和
*   组装。

#### 球拍

球拍，作为 Lisp 的一个全功能方言，语法非常简单。

对于一小部分学生来说，这种语法是一种障碍。

坦率地说，如果这些学生在接受一个陌生的句法体系方面存在根本的心理障碍，即使是暂时的，他们也缺乏在计算机科学职业生涯中生存下来的思维灵活性。

Racket 强大的宏系统和高阶编程工具彻底消除了数据和代码之间的界限。

如果教得正确，Lisp 解放。

##### 推荐阅读

#### ANSI C

c 是对硅的简洁而无情的抽象。

在嵌入式系统编程方面，c 仍然没有对手。

学习 C 语言以一种任何其他语言都无法做到的方式传授了对占主导地位的冯·诺依曼架构的深刻理解。

考虑到糟糕的 C 编程在缓冲区溢出安全漏洞的流行中扮演的重要角色，程序员学习如何正确编程是至关重要的。

##### 推荐阅读

*   克尼根和里奇的《安西 C ![](../Images/55b8d6f3cf227c3adfe37d08bf34bb54.png)》。

#### Java Script 语言

JavaScript 是 Python、Ruby 和 Perl 等动态高阶语言中流行的语义模型的一个很好的代表。

作为网络的母语，其语用优势是独特的。

##### 推荐阅读

#### 机会

Squeak 是 Smalltalk 的现代方言，是最纯粹的面向对象语言。

它赋予了“面向对象”的本质

##### 推荐阅读

#### Java 语言(一种计算机语言，尤用于创建网站)

Java 将会流行太久而不能忽视它。

##### 推荐阅读

#### 标准毫升

标准 ML 是 Hindley-Milner 系统的清晰体现。

Hindley-Milner 型系统是现代计算中最伟大的(却是最鲜为人知的)成就之一。

尽管复杂性呈指数级增长，但对于人类感兴趣的程序，Hindley-Milner 中的类型推理总是很快。

类型系统足够丰富，可以表达复杂的结构不变量。事实上，它是如此的丰富，以至于类型良好的程序通常是没有错误的。

##### 推荐阅读

#### 序言

尽管在应用中占有一席之地，但逻辑编程是计算思维的另一种范式。

对于那些程序员可能需要在另一个范例中模拟逻辑编程的情况，理解逻辑编程是值得的。

另一种值得学习的逻辑语言是 [miniKanren](http://minikanren.org/) 。miniKanren 强调纯(不允许剪切)逻辑编程。这种约束已经发展出一种称为关系编程的替代逻辑编程风格，它赋予了 Prolog 程序通常不具备的特性。

##### 推荐阅读

#### 斯卡拉

Scala 是函数式和面向对象编程语言的完美融合。Scala 是 Java 应该有的样子。

它构建在 Java 虚拟机之上，与现有的 Java 代码库兼容，因此，它是 Java 最有可能的继承者。

##### 推荐阅读

#### 哈斯克尔

Haskell 是 Hindley-Milner 语系皇冠上的宝石。

Haskell 充分利用了懒惰，是所有主流编程语言中最接近纯数学编程的。

##### 推荐阅读

#### ISO C++

C++是必要的恶。

但是，既然必须教，就必须完整地教。

特别是，计算机科学专业的学生应该掌握甚至[模板元编程](http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/)。

##### 推荐阅读

#### 装配

任何汇编语言都可以。

既然 x86 流行，那也不妨如此。

学习编译器是学习汇编的最好方法，因为它给计算机科学家一种高级代码将如何转换的直观感觉。

### 具体建议

计算机科学家要懂生成式编程(宏)；词汇(和动态)范围；关闭；延续；高阶函数；动态调度；分型；模和函子；和单子作为不同于任何特定语法的语义概念。

### 推荐阅读

## 离散数学

计算机科学家必须牢固掌握形式逻辑和证明。通过代数操作和自然演绎的证明涉及到日常编程任务中常见的推理。归纳法的证明使用了递归函数构造中的推理。

计算机科学家必须精通正式的数学符号，并对基本的离散结构进行严格的推理:集合、元组、序列、函数和幂集。

### 具体建议

对于计算机科学家来说，重要的是要涵盖以下方面的推理:

*   树木；
*   图表；
*   正式语言；和
*   自动机。

学生应该学习足够的数论来研究和实现常见的密码协议。

### 推荐阅读

## 数据结构和算法

学生当然应该看到常见的(或罕见但不合理有效的)数据结构和算法。

但是，比了解特定算法或数据结构(通常很容易查找)更重要的是，计算机科学家必须了解如何设计算法(例如，贪婪的动态策略)以及如何跨越算法在理想状态和实现细节之间的差距。

### 具体建议

寻求长期稳定工作的计算机科学家至少应该了解以下所有内容:

*   散列表
*   链接列表；
*   树木；
*   二分搜索法树；和
*   有向和无向图。

计算机科学家应该准备好实现或扩展对这些数据结构进行操作的算法，包括搜索元素、添加元素和删除元素的能力。

为了完整性，计算机科学家应该知道每个算法的命令和函数版本。

### 推荐阅读

## 理论

掌握理论是研究生院研究的先决条件。

当理论为一个问题提供了硬边界时(或者当它提供了一种绕过最初看起来是硬边界的方法时)，理论是无价的。

计算复杂性可以合理地宣称是所有计算机“科学”中为数不多的真正可预测的理论之一。

计算机科学家*必须*知道易处理性和可计算性的界限在哪里。忽视这些限制在最好的情况下会招致沮丧，在最坏的情况下会招致失败。

### 具体建议

在本科阶段，理论应该至少涵盖计算模型和计算复杂性。

计算模型应该涵盖有限状态自动机、正则语言(和正则表达式)、下推自动机、上下文无关语言、形式语法、图灵机、lambda 演算和不可判定性。

在本科阶段，学生至少应该学习足够的复杂性，以理解 P、n P、NP-Hard 和 NP-Complete 之间的区别。

为了避免留下错误的印象，学生应该通过简化为 SAT 和使用现代 SAT 求解器来解决 NP 中的几个大问题。

### 推荐阅读

## 体系结构

对计算机体系结构的深刻理解是无可替代的。

计算机科学家应该从晶体管开始理解计算机。

对架构的理解应该包括抽象的标准层次:晶体管、门、加法器、多路复用器、触发器、算术逻辑单元、控制单元、高速缓存和 RAM。

在可预见的未来，理解高性能计算的 GPU 模型将非常重要。

### 具体建议

对高速缓存、总线和硬件内存管理的良好理解对于在现代系统上实现良好的性能至关重要。

为了更好地掌握机器架构，学生应该设计并模拟一个小型 CPU。

### 推荐阅读

## 操作系统

任何足够大的程序最终都会成为操作系统。

因此，计算机科学家应该知道内核如何处理系统调用、分页、调度、上下文切换、文件系统和内部资源管理。

对操作系统的良好理解仅次于对编译器和实现性能的架构的理解。

当在没有操作系统的情况下对嵌入式系统进行编程时，理解操作系统(我可以广义地解释为包括运行时系统)变得尤其重要。

### 具体建议

对于学生来说，接触真正的操作系统是很重要的。有了 Linux 和虚拟化，这比以往任何时候都容易。

为了更好地理解内核，学生可以:

*   引导过程中打印“hello world”；
*   设计自己的调度程序；
*   修改页面处理策略；和
*   创建他们自己的文件系统。

### 推荐阅读

## 建立工作关系网

鉴于网络无处不在，计算机科学家应该对网络中的网络堆栈和路由协议有深刻的理解。

对于计算机科学家来说，在不可靠的传输协议(如 IP)之上构建高效、可靠的传输协议(如 TCP)的机制并不神奇。应该是核心知识。

计算机科学家必须了解协议设计中涉及的权衡——例如，什么时候选择 TCP，什么时候选择 UDP。(如果程序员也大规模使用 UDP，他们需要理解拥塞的更大社会含义。)

### 具体建议

鉴于现代程序员接触网络编程的频率，了解现有标准的协议很有帮助，例如:

*   802.3 和 802.11；
*   IPv4 和 IPv6 和
*   DNS，SMTP 和 HTTP。

计算机科学家应该理解包冲突解决中的指数后退和拥塞控制中涉及的加法-增加乘法-减少机制。

每个计算机科学家都应该实现以下内容:

*   HTTP 客户端和守护程序；
*   DNS 解析器和服务器；和
*   命令行 SMTP 邮件程序。

没有一个学生应该在没有嗅出老师的谷歌查询的情况下通过一门介绍网络工作的课程。

要求所有学生在 IP 之上从头实现一个可靠的传输协议可能太过分了，但我可以说，作为一名学生，这对于我个人来说是一次变革性的经历。

### 推荐阅读

## 安全性

可悲的安全事实是，大多数安全漏洞都来自草率的编程。更可悲的事实是，许多学校在培训程序员保护他们的代码方面做得很差。

计算机科学家必须意识到程序被破坏的手段。

他们需要培养一种防御性编程的意识——一种思考他们自己的代码可能如何被攻击的意识。

安全性是一种最好分布在整个课程中的培训:每个学科都应该警告学生其固有的漏洞。

### 具体建议

至少，每个计算机科学家都需要理解:

*   社会工程；
*   缓冲区溢出；
*   整数溢出；
*   代码注入漏洞；
*   比赛条件；和
*   特权混乱。

一些读者指出，计算机科学家还需要了解基本的 IT 安全措施，例如如何选择合理的密码，以及如何使用 iptables 正确配置防火墙。

### 推荐阅读

## 密码系统

密码学让我们的数字生活成为可能。

计算机科学家应该理解并能够实现以下概念，以及这样做的常见陷阱:

*   对称密钥密码系统；
*   公钥密码系统；
*   安全散列函数；
*   挑战应答认证；
*   数字签名算法；和
*   门限密码系统。

由于这是密码系统实现中的一个常见错误，每个计算机科学家都应该知道如何为手头的任务获取足够多的随机数。

至少，正如几乎每一次数据泄露所显示的那样，计算机科学家需要知道如何存储加盐和散列密码。

### 具体建议

每一个计算机科学家都应该享受到使用前现代密码系统和手工统计工具破解密文的乐趣。

RSA 很容易实现，每个人都应该去做。

每个学生都应该创建自己的数字证书，并在 apache 中设置 https。(做到这一点是出奇的费力。)

学生还应该编写一个通过 SSL 连接的控制台 web 客户端。

作为严格的实际问题，计算机科学家应该知道如何使用 GPG；如何对 ssh 使用公钥认证；以及如何加密目录或硬盘。

#### 推荐阅读

## 软件测试

软件测试必须贯穿整个课程。

软件工程的课程可以涵盖基本的测试方式，但是没有什么可以代替实践这门艺术

应该根据学生上交的测试案例给他们打分。

我用学生上交的测试案例来对抗所有其他学生。

学生们似乎不太关心开发防御性测试用例，但当涉及到用沙袋攻击他们的同学时，他们会大发雷霆。

## 用户体验设计

程序员经常为其他程序员写软件，或者更糟糕的是，为他们自己写软件。

用户界面设计(或者更广义地说，用户体验设计)可能是计算机科学中最不受重视的方面。

甚至在教授中也有一种误解，认为用户体验是一种无法教授的“软”技能。

事实上，现代用户体验设计是基于来自人因工程和工业设计的经验原则。

如果没有别的，计算机科学家应该知道界面需要使执行任何任务的容易程度与任务的频率乘以它的重要性成比例。

实际上，每个程序员都应该习惯于用 HTML、CSS 和 JavaScript 设计可用的 web 界面。

### 推荐阅读

## 形象化

良好的可视化是指以一种人类可以将其视为信息的方式呈现数据。这不是一件容易的事。

现代世界是数据的海洋，利用人类感知的局部最大值是理解它的关键。

### 推荐阅读

## 平行

平行主义又回来了，而且比以往任何时候都更加丑陋。

不幸的事实是，利用并行性需要深入的架构知识:多核、缓存、总线、GPU 等。

还有，练习。大量的练习。

### 具体建议

还不清楚并行编程的“最终”答案是什么，但是已经出现了一些特定领域的解决方案。

目前，学生应该学习 CUDA 和 OpenCL。

线程对于并行性来说是一个脆弱的抽象，尤其是当涉及到高速缓存和高速缓存一致性时。但是，线程是流行和棘手的，所以值得学习。Pthreads 是一个可移植的线程库，值得学习。

对于任何对大规模并行感兴趣的人来说，MPI 都是先决条件。

在原则方面，map-reduce 确实似乎是持久的。

## 软件工程

软件工程原理的变化和编程语言的变化一样快。

在团队软件构建的实践中，一门好的实践课程提供了在努力中固有的陷阱的工作知识。

一些读者建议学生分成三人一组，领导者的角色在三个不同的项目中轮换。

学习如何通过一个大的现有代码库进行攻击和操作是大多数程序员必须掌握的技能，最好在学校而不是在工作中学习。

### 具体建议

所有学生都需要了解像 svn 这样的集中式版本控制系统和像 git 这样的分布式版本控制系统。

当像 gdb 和 valgrind 这样的调试工具最终变得必要时，它们的工作知识会有很大帮助。

### 推荐阅读

## 形式方法

随着对安全、可靠软件需求的增加，正式方法可能有一天会成为交付软件的唯一手段。

目前，软件的正式建模和验证仍然具有挑战性，但该领域的进展是稳定的:它一年比一年容易。

在今天的计算机科学专业学生的一生中，甚至可能有一天正式的软件构建是一项预期的技能。

每个计算机科学家都应该至少适度地适应使用一个定理证明器。(我觉得哪个都无所谓。)

学习使用定理证明器会直接影响编码风格。

例如，一个人会本能地对写一个没有涵盖所有可能性的`match`或`switch`陈述感到过敏。

而且，当编写递归函数时，定理证明者的用户有强烈的消除病态的冲动。

### 推荐阅读

## 图形和模拟

没有比图形更受“聪明”支配的学科了。

这个领域被推向，甚至被定义为“足够好”

因此，没有比图形和模拟更好的方法来教授聪明的编程或对优化工作的正确评价。

我学到的一半以上的编码技巧来自于我对图形的研究。

### 具体建议

简单的光线跟踪器可以用不到 100 行代码构建。

在线框 3D 引擎中执行透视 3D 投影时，做好必要的转换是很好的心理准备。

像 BSP 树这样的数据结构和像 z-buffer 渲染这样的算法都是聪明设计的很好的例子。

在图形和模拟中，还有更多。

### 推荐阅读

## 机器人学

机器人可能是教授入门编程的最吸引人的方式之一。

此外，随着机器人成本的持续下降，阈值正在被超越，这将使个人机器人革命成为可能。

对于那些会编程的人来说，难以想象的个人物理自动化程度即将到来。

### 相关职位

## 人工智能

如果不是因为它对早期计算历史的巨大影响，计算机科学家应该研究人工智能。

虽然智能机器的最初梦想似乎很遥远，但人工智能刺激了许多实际领域，如机器学习、数据挖掘和自然语言处理。

### 推荐阅读

## 机器学习

除了其突出的技术优势，“相关性工程师”的职位空缺数量表明，每个计算机科学家都应该掌握机器学习的基础知识。

机器学习加倍强调对概率和统计的理解。

### 具体建议

在本科阶段，核心概念应该包括贝叶斯网络、聚类和决策树学习。

### 推荐阅读

## 数据库

数据库太普通了，太有用了，不容忽视。

理解驱动数据库引擎的基本数据结构和算法是很有用的，因为程序员经常在更大的软件系统中重新实现一个数据库系统。

关系代数和关系微积分在计算的亚图灵模型中是非常成功的例子。

与 UML 建模不同，ER 建模似乎是一种对软件工件的设计和约束进行可视化编码的合理机制。

### 具体建议

一个计算机科学家可以建立和操作一个灯栈是一个好主意，也是远离经营自己公司的许多艰苦工作。

### 推荐阅读

## 非特定阅读推荐

## 还有什么？

我的建议受限于自己的知识盲点。

我在这里没有列出哪些应该包括的内容？

## 相关职位

* * *