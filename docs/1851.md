# Ian Mallett -教程:不要写测试用例页面

> 原文：<http://geometrian.com/programming/tutorials/testing/test-first.php?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

## 测试驱动的开发是愚蠢的

"

*Trying to improve software quality by increasing the amount of testing is like try[ing] to lose weight by weighing yourself more often.*

"

### 伊恩·马利特

[2015 年 11 月更新:

> 在今天之前，我认为大体上只有一种 TDD。然而，通过对这些评论的重构，我推测至少有两种——而我所熟悉和攻击的那种(幸运的是)已经很少见了。
> 
> 我认为大部分。。。这篇文章引起了对这一根本区别的争论。一方面，我怀疑是那些经历过我所攻击的 TDD 的人在支持我。另一方面，我怀疑其他人对我的长篇大论感到恼火。
> <sup>(对后者来说，你所有的 hatemail 邮件的专业性已经令人肃然起敬。我向你保证，这真的让我想听。)</sup>
> 
> 因此，我想澄清:这篇文章是特别针对第一种 TDD 的。
> 
> 我后悔没有意识到其中的区别。当然，我为之工作的每个人都声称我描述的是 TDD——事实上，声音非常大。此外，他们从未说过有不同的方式。当然，在我工作过的任何一个地方，TDD 都被普遍使用，也普遍被厌恶。可悲的是，它甚至不是大多数人所说的 T1“TDD”。这些从业者是少数，这令人惊讶，但最终，对我来说，这是令人鼓舞的，因为这意味着这个世界只是稍微理智了一点。
> 
> 但是，既然我们把这篇文章的范围限制在这种更荒谬的变化上，我几乎袖手旁观了我所说的一切(甚至，尽管这篇文章很老)。你们当中那些实践 TDD 的人应该意识到你们更不理性的表亲的存在，就像我没有意识到相反的情况一样。
> 
> 终于觉得自己是个讲道理的人了。如上所述，我不介意承认错误，尤其是在有充分理由的时候。事实上，我不得不自己重建这个误解。与此同时，令我吃惊的是，我在互联网上的小角落引发了如此多的尖酸刻薄。也许，在未来，你会发现作者更倾向于自省，如果你不随意抛出种族主义的诽谤的话？
> 
> 我们现在回到我们定期安排的节目。

]

#### 引言和一个来自直觉的论证

一般来说，我反对编写单元测试，因为经验表明，它们实际上阻止了高质量的代码从开发中出现——一个更好的策略是关注能力和良好的设计。

然而，一种特殊风格的单元测试因其特殊的疯狂性而值得特别关注。测试驱动开发(TDD)是如此的愚蠢，以至于我第一次听说它的时候，我认为这是一个精心设计的恶作剧，是在项目进行了一个月之后。

我还是觉得这是一个精心制作的恶作剧，但至少现在我知道有人当真了。

令人惊讶的是，这是软件工程中最流行的方法之一(并且越来越流行！)—在你弄清楚你想做什么和你想怎么做之后，你写一套小的测试程序——每一个测试程序将会存在的一些微小的部分。然后，你写程序。

让我强调一下:*你为你的程序写测试用例，然后你写你的程序。*你正在编写代码来测试甚至还不存在的东西。我无法理解是什么样的思想混乱会引发这样一种方法。

也许想出这个主意的混蛋正在和几个朋友一起做白日梦。

> 肯特:嘿，乔，如果我们在程序被写出来之前试着运行一下*程序会怎么样？
> **乔**:哇！这使得*实际上没有任何意义。弗雷德:不，等等——这是那种愚蠢到可能行得通的想法！**

真的，这是那种只有在你喝醉的时候才有意义的事情，如果你从直觉的角度来考虑，确实如此

*completely broken*

。考虑到软件工程的全部挑战是尽可能简单地解决复杂的问题

*literally backward*

应该开始敲响警钟了。

这里有一个类比:

> 开发软件就像绘画委托。比方说，你要画某个有钱人的女儿，而不是去完成某个特定的要求。所以，你，甚至没有画一些草图，你坐下来想:我想要 X 个黑色的笔触，Y 个红色的笔触。她的下巴会正好在这个位置。然后，你可以像机器人一样精确地一笔一划。(也许你的做法略有不同:你勾画出一个基本的形状，然后从左上角开始画第一平方厘米，直到你非常确定它刚刚好。然后你继续下一个，以此类推)。这是测试驱动的开发。
> 
> 有人画这样的画吗？不要！为什么？因为是智障。第二周，女儿出现摆姿势，她不是你描述的那个苗条的青少年，而是一个胖胖的四年级学生，噘嘴，对模特的注意力不集中。
> 
> 真正的画家从泛泛而谈开始，一次完成。他们在解决细节之前就改变了事情。他们不提前计划。他们不受约束地工作。他们重构图片——如果不合适，甚至重新开始。这个过程是必要的。你猜怎么着？艺术家用这种方式创作出美丽的图画。软件工程的内在美应该从这里学习。

#### 从实用性出发的论证

最重要的论点是一个实际的论点:*测试优先不起作用*。我不在乎你听说了什么。我不管你的[套装](http://www.catb.org/jargon/html/S/suit.html)要多少钱。我不在乎你的同事们眼中闪烁着多少赞同的光芒。它。不会。工作。

很大一部分问题是很少有比较。大多数程序员在他们早期编程的时候就知道了测试优先的策略，并且在他们真正拥有实践经验之前认为它更加严格。大多数人从不回顾过去，认为其他一切都是他们未受教育的过去的无聊消遣。这并没有帮助，这就是现在孩子们被教育的方式。

这是我的悲伤故事:

> 我曾经是这些新受教育的孩子中的一员。因此，几年来，我一直致力于测试第一的策略。当它结束时，结果是不可否认的。代码——所有的代码——都很可怕。课堂项目、研究代码、合同项目、独立游戏，我在那段时间写的所有东西——都很慢，很难读懂，而且错误百出，我可能会哭出来。它通过了测试，但仅此而已。
> 
> 这也是写得最慢的代码。我很惊讶有这么多。至少是五倍。 T3】
> 
> 我们把它运走了！我写的所有可怕的东西，就像机器中的其他齿轮一样，被打包成. jar 或. exe 或. pdf 或. app，然后发送给客户。去买。
> 
> 呃。这就像如果你生活在一个疯狂的世界里，早餐麦片和便便混在一起，因为每个人都认为这是制作麦片的唯一方法——所以确切地说，当你轮班的时候，你不会感觉很糟糕，但你会有点害怕这个世界是这样的。

支持 TDD 的很大一部分理由是这种抱怨是轶事。这是一个合理的担忧。但是，作为一个局外人来看这种情况并不难:

*   你多久见过一次程序崩溃？如果它是由大型软件公司开发的，那么它很可能是使用 TDD 编写的。显然，TDD 不是一颗神奇的子弹。所以， **TDD 并没有“证明你的代码有效”**。
*   开发需要多长时间？有时，我会在一天之内独自编写中等大小、功能完整的程序。我经常在相同的时间内编写整个模块(一些数据结构和类，一些函数，各种各样的东西)。对于使用 TDD 的*工程师团队*来说，这是一个*周*或一个*月*。我会说我的代码是等价的或者更好的可靠性(实际上，我没有指名道姓，我已经编写了定制软件来替换 TDD 第三方代码，因为后者太容易出错了)。因此， **TDD 需要更长的时间来达到同样的结果**。

我邀请业内读者来验证这两个经验。

如果你想知道为什么我相信这些事实*是*，或者仍然不相信，下面是 TDD 失败的一些原因。

#### 好的设计

最大的问题是 TDD 限制了最终设计的优雅。无论你在纸上做了多少次设计，没有人能把一个完美的设计变得存在。正如行话文件[恰当地指出的那样](http://www.catb.org/jargon/html/C/creationism.html):“经验一再表明，好的设计只能产生于一个(或至多一小部分)非常能干的设计师和活跃的用户群体之间的进化、探索性的互动——对一个大的新想法的第一次尝试总是错误的。”

任何有软件经验的人都知道这是真的。从计算机编程的第一天起，这就是事实。COBOL 程序员都知道。他们在 ENIAC 上做了[迭代编程。法律就是这样制定的。工程就是这样完成的。这就是*人类建造的每一件东西*都有机会工作的原因。否则就是否认。这是对一千年经验的唾弃。设计是独角兽。你应该追求他们，了解他们。发展关系。想先设计好一切的人都在找奉子成婚来掩盖一夜情。是*错了*。](https://en.wikipedia.org/wiki/ENIAC#Programming)

所以这是 TDD 失败的第一个原因:**你试图在了解任何东西之前就做出一个设计。**

这在软件工程中是什么样子的？

如果你在一个模块的你的部分工作，你应该不断地改变你的设计，使它变得完美。即使在我“已建立”的代码库中，我仍然偶尔——不，*频繁*——进行大规模的修改，因为增加的经验证明了原始设计中的错误，或者新的知识建议了一个更好的。这是健康的，因为它将当前的代码与过去失败的设计决策分离开来。

尽管我的代码库范围相当大，但即使是影响广泛的更改也可以很快完成，因为没有一组测试需要为每个受影响的项目删除和重写。例如，当我学到新东西和旧设计的缺点变得明显时，我在多个场合对我的核心图形库进行了大规模的重构。我自己能够对如此大量的代码做到这一点的事实应该强调了这样一个事实，即使用 TDD 不可能做到这一点。我甚至无法想象如果不重组最初的设计，仍然添加新功能，我的代码库会有多糟糕。

测试优先的设计策略通过增加修改任何东西的工作量来阻止这些频繁的改变。如果你想创建一个新函数，你也必须创建三个新函数来测试它。如果你想改变一个函数做什么，你必须改变你为它写的所有测试。它变得棘手。如果你想重构一个类——更不用说一个类的层次结构，厄里斯可以帮你。这将成为一整天充满错误、艰苦的工作，而在最糟糕的情况下，这些工作本应花 15 分钟完成。

所以也许你可以以更粗的粒度来编写测试。这几乎更糟，因为这意味着您正在编写代码来测试算法。这需要更仔细的思考，奖励更少的部分成功，实际上意味着更多的改变，因为算法改变的比后端更多。

#### 灾难性的设计失败

实际上，这导致了次优的设计。人们用一种方式编写一些东西，但是害怕改变它，因为他们必须重写测试代码。这些糟糕的设计*实际上经常是 bugger*，因为它们没有以正确的方式处理问题！他们将测试和他们的算法一起添加到兼容性层中。然后循环重复，他们给*添加了另一个*样板层，并随意将其与第一个合并，添加了一套全新的测试。所以有问题的代码保持原样，变得越来越长，直到它最终需要被扔掉并重写。

使用测试驱动过程的软件工程师习惯了这种事情——以至于他们甚至没有意识到它正在发生。只有不可信的新员工才意识到，用三层语义无效的间接方式来做简单的事情是低效和愚蠢的。

作为证明，这里有一个我不幸参与的 TDD 项目的真实例子。作者要求匿名。只是在漫长而血腥的恐怖中煎熬。

*   函数 A 有 147 行长。这是程序的简单核心。

*   函数 A 在 2002 年 6 月 26 日被提交给存储库。功能 A 有四个测试用例。然而，28 日在函数 A 中发现了一个 bug，并于 7 月 6 日上传了一个补丁。它包含了两个新的测试用例。

*   这个继续一点。然而，到 2002 年 8 月，函数 A 基本上是稳定的，并且有不少于 13 个测试用例——主要是针对 fencepost 错误和任何人都可以通过堆栈跟踪找到的其他愚蠢的东西。除了 2003 年初的一个短暂现象，现在有 152 行长的函数 A 直到 2006 年中期都没有变化。

*   在 2006 年，该计划扩展到包括新的功能。这表明函数 A 并不适合——它以一种非直觉、非一般的方式处理问题。以前还好，现在不够用了。因此，在那一年的 5 月，为函数 A 添加了两个包装函数 B 和 C，并对每个函数进行了单元测试。这是教科书式的完美:他们在 SVN 提交消息中添加了一行:“WRapped [function A]。FIXME:改为重构测试”。从来没有发生过。

*   2006 年 6 月，该计划进一步扩大。显然，没有人知道 B 和 C 是如何工作的，所以有人为包装函数 B 编写了六个包装函数 D、E、F、G、H 和 I *,为函数 A 编写了 C* 。

*   在 2006 年 7 月 1 日，有人认为越来越多的混乱不是面向对象的。他没有重构一切，而是把函数 A 做成一个新类的静态方法，把 B 和 C 做成成员函数。因为 D、E、F、G、H 和 I 是包装函数(对于 B 和 C ),但是它们需要一些努力来理解，另一个程序员在 2006 年 7 月 9 日把它们放到了另一个类中。添加了一个到新集成的测试库的挂钩，以确保两个新类都可以被实例化以进行测试。该法规将持续到 2007 年。

*   在 2007 年 1 月，一个程序员扩展了的功能，但没有完全理解它上面的样板文件。她(从用户名来看，我觉得是个 She)给函数 A 增加了两个新的 helper 函数 J 和 K，并把工作委托出去。她重构 B 和 C 来修复测试用例，并在 B 和 C 及其包装函数 D、E、F、G、H 和 I 之间插入一个新的抽象层来处理差异。现在有 4131 行样板文件包装函数 A、J 和 K，它们现在是 172 行。

*   在 2009 年 7 月 1 日，也就是 2006 年同样的决定整整三年后，有人又一次认定这个越来越大的烂摊子不是面向对象的。同样，他们不会重构混乱的局面，而是将整个事情推入另一个新类的内部类(称为“_Implementation”)。函数 A 现在有两个助手，三层和两类包装函数，以及将近 50 个测试用例。该实现跨越六个文件和将近 6000 行。

*   一周后，有人意识到，为了编写测试，将所有东西包装在一个类中会破坏内部类的支持类的实例化。因此，他们编写了一个泛型(类似 C++模板，但不是图灵完整的)类，其唯一的功能是假复制构造支持类，让它们*认为*它们存在于使用接口的内部类中，然后以一种合理的方式委托它们的单元测试。

*   在 2009 年 9 月，项目的存储库由于一次错误的推送而被破坏，在恢复过程中，有人意外地提交了他们个人的模块分支，这是 2006 年版本的一个性能增强分支。第一个注意到差异的人(我假设是在 push 上)随意合并了两个模块，并注释掉了不工作的测试用例。现在有超过*万*行样板代码，包括四个测试类，一堆包装函数(抱歉；我数不清了)，以及 81 个测试用例(其中 14 个默默的失败了)。函数 A 现在存在两个版本，因为没有人意识到它们做的是同样的事情。

*   与此同时，自 2004 年以来，提交原始函数 A 和补丁的三个编码人员就没有提交过这个模块。

所有这些在 2010 年初引起了我的注意，当时我提请项目负责人注意这件事(用比上面更温和的措辞)。我质疑 TDD 的选择，他回答说这样导致代码更干净。然后我给他看了一份带注释的 SVN 日志，他对此表示异议，并说他会进行调查。我很快就停止使用这个项目，然后大多数开发人员转向了一个闭源分叉，所以我不知道这个问题是否得到了解决。

你会很难说服我，上面的例子，一个有一万行没人理解的冗余代码的怪物，比重构的函数 A 更可靠。当然，这是一个极端的例子，但是在其他 TDD 开源项目中很难看不到更小邪恶的证据。挑你最喜欢的看看。我谅你也不敢。

这里的教训是，作者和维护者害怕改变一个他们没有改变的糟糕的设计。

#### 自信和懒惰

许多拥护者声称 TDD 给了他们更多的信心，相信他们的代码是正确的。正如上一节所展示的，也许这种信心是错误的。

TDD 开发者有多自信？非常。以我的经验来看，TDD 经常会产生对测试用例非常有效的代码，而对真实数据却不能。通常，我对这类项目的 bug 报告会自动地遇到“不，我们测试过类似的东西”。我甚至*准确地指出了*漏洞在哪里，结果却被否认存在。TDD 似乎培养了一种傲慢的态度——任何 TDD 代码在某种程度上都是更高的健壮性标准——这让它的开发人员回避了一个突出的事实，即它往往是相反的。

问题是 TDD 鼓励程序员编写适合这些测试用例的程序——而不一定是其他的。理想情况下，如果测试写得“好”，那么任何通过测试的程序都是令人满意的。然而，几乎在每种情况下都不可能指定每种可能输入的期望输出。即使它是，它肯定是不实际的。

此外，这个过程本身会助长懒惰。虽然编写测试应该是 TDD 最关注的部分，但是相对来说，生成新代码是不需要动脑筋的。从个人经验来看，我知道这很累人。有一种“我们继续下一个测试吧”的态度。这种懒惰会延续到目标代码本身:在数小时的编写测试之后，只需将一些实现拼凑起来，并希望它保持不变。

#### 时间

软件开发的最后期限是如何推迟的，这已经成为软件消费者之间的一个笑话。为什么会这样？

这是因为项目的初始支出只计划了编写代码和测试的成本。它没有考虑到代码实际上不会工作的意识。这是一个来自计划会议的 12 周 TDD 项目的真实的报价时间表:

> **第一周**:设置和材料。
> **第二周**:开发设计。
> **第 3-4 周**:写测试。
> **第 5-10 周**:写代码。
> **第 11 周**:特征冻结。调试。
> **第 12 周**:解决小问题，交付产品。

实际情况是这样的:

> **第一周**:设置和材料。
> **第二周**:开发设计。
> **第三周**:开始编写测试。
> **第 3.5 周**:发现设计实际上是不可能实现的。
> **第四周**:紧急设计会议，不顾一切地试图修复测试。
> **第 5-6 周**:更好的设计。写完测试。
> **第 7-8 周**:晚两周。绝望的编码。
> **第 8-9 周**:绝望的编码与重构。调整设计来巩固我们已经在做的事情。
> **第十周**:绝望编码；关键修复。
> **第 11 周**:特征冻结；关键修复。
> **第 12 周**:【产品演示时令人尴尬的崩溃】

在一个更大的环境中，质量控制团队会发现这个错误，并命令管理层扩展这个项目。

在我放弃 TDD 之后，我开始收到关于没有 TDD 我如何可能完成任何事情的电子邮件。没有你的 TDD 我能做多少事？结果是:同样的质量，比你更好。

不过，我不认为只有我这么想。我觉得只是我不用 TDD。

我的代码是松散构建的:在过程的每个阶段，我设想设计的*关键*特征，然后向下向外构建。我仔细检查每个功能，但我不会让它分散我的注意力，让我无法想象它们是如何组合在一起的。我在设计中加入了初步的想法，但总的来说，我是随机应变的——而且我不害怕中途的激进改变。而且，我拥抱他们。如果我想出一个好的架构改变，我会立即去做。

我认为，现代程序的复杂性和动态性是如此惊人，只有通过直观的理解才能欣赏它。编写测试迫使一个人将这种复杂性形式化到这样一种程度，即假定现代程序的复杂性可以被简化为两到三个简单的情况。为程序编写测试用例通常就像试图用蜡笔描绘*蒙娜丽莎*一样。程序员心目中完美的状态和微妙的控制流的平衡并没有被测试驱动的靴子的嬉戏所帮助；这样的事情*不能简化为测试文件中的几行描述。*

即使你以某种方式成功了，TDD 通过在你得到任何真正的结果之前功能性地要求一个模块通过所有的测试来防止增量草案。测试这个，测试那个，不知不觉一周过去了，你的算法还没完成一半——当你完成时，你发现它不起作用了。我会在第一天就发现这一点，即使我以前做的实现是垃圾。

#### 结论

我在[对测试用例](unit.php)的评论中的所有批评也适用，但是对于测试驱动的开发，这些问题是特别可以预防的。真正的底线是一样的:如果做软件开发的人不称职，那么软件开发根本不会成功。没有任何单元测试或代码审查的方法，或者任何时下流行的术语*能保证一个程序能像预期的那样工作。TDD 只是一个更大问题的权宜之计:*首先写好代码*。*

能力是不可替代的。如果您的编码人员没有它，TDD 不会修复它。如果他们有，TDD 会破坏它。测试优先策略*通过以通过测试套件的形式给出错误的安全性来阻止这种想法。它会导致设计中的代码被破坏，并让人们为自己感到骄傲。*

TDD 通过代码膨胀和碎片阻碍了良好的设计。它傲慢地假定设计可以一次完成，甚至没有给出更好的结果。它不应该被使用。

### 【2015 年 11 月更新:请在评论前阅读上面的更新和文章本身。]

|  | 评论 |