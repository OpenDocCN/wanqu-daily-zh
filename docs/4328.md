# 硬件是新的软件|晨报

> 原文:[https://blog . acolyer . org/2017/06/19/hardware-is-the-new-software/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://blog.acolyer.org/2017/06/19/hardware-is-the-new-software/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

[硬件是新软件](https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/baumann-hotos17.pdf)鲍曼*霍托斯【17】T3】*

这是一篇可读性很强的短文，它揭示了最近英特尔 x86 指令集架构(is a)所发生的有趣变化。我们看到*扩展*的数量和复杂性急剧上升，这给系统研究人员(以及英特尔)带来了一些有趣的启示！).我们也看到微码的使用越来越多，模糊了 ISA 作为硬件和软件之间的界限。

> 我们认为，这些扩展现在正接近软件级别的复杂性，但同时也带来了硬件实现的所有缺点以及由此带来的缓慢部署周期。我们怀疑目前的道路可能是不可持续的，并假设一个替代的未来，最终目标是将新的 ISA 功能从底层硬件中分离出来。

(注意，作者来自微软研究院，非英特尔)。

### 旧时代:稳定而有节制的增长

386 参考手册列出了 96 条指令。随着时间的推移，新指令在浮点支持、向量扩展、加密加速器、64 位等领域稳步增加。然而至关重要的是:

> …过去的系统设计者在很大程度上可以忽略这种变化…除了 64 位模式和虚拟化扩展这一显著的例外，x86 上的操作系统开发人员偶尔会得到一些调整以提高性能或纠正明显的缺点，但在其他方面都被忽略了。即使是 64 位模式也没有显著增加体系结构的复杂性…

### 为什么要买新的 CPU？

随着摩尔定律的放缓，英特尔传统的两年制开发模式也在放缓。这提出了一个明显的问题:

> …如果微体系结构没有改进，它们[CPU]的速度不会大幅提高，能效也不会大幅提高，而且它们的内核数量和以前的 CPU 差不多，价格也一样。为什么会有人买新 CPU？

如果你站在英特尔的立场想一想，你就会明白为什么这可能会令人不安。你还能做些什么来吸引购买新的 CPU？

> 英特尔转向的一个原因似乎是功能:如果新 CPU 实现了一个重要的 ISA 扩展——比如说，一个软件所需的扩展，因为它对安全至关重要——消费者将有很强的理由升级。

换句话说，加快扩展发布的速度很可能是英特尔的一个有意策略，以保持我们的购买。结果是…

> …在过去的两年里，ISA 的复杂性急剧增加(例如，从下图的架构手册中可以看出)，更多的扩展正在进行中。

![](../Images/74a3a6b9dee139f1f932203636c2b3e1.png)

上面的图表仍然遵循摩尔定律(注意左边轴上的对数标度)，最近宣布的发布节奏放缓尚未出现。使用手册中的单词作为复杂性的代理，我们也可以看到由于 Skylake 引入的扩展，在 2015-16 年期间有一个大的跳跃。

(出于兴趣，我计算了一下，对于 200 万字，平均阅读速度为每分钟 200 字的情况，仅读一遍手册就需要一个月的全职阅读时间，每周 40 小时！).

下表总结了最近的 ISA 扩展以及它们引入的新指令的数量。

![](../Images/0b6c953e5993e9119698139aa9c863d5.png)

复杂性的增加不仅仅是因为新指令的数量，更重要的是因为与现有指令的交互:

> 这些[更新的]扩展引入了新的系统级功能，经常改变现有指令的语义，并表现出与其他扩展和先前架构特性的复杂交互。

### SGX 和 CET 例题

鲍曼引用了 SGX 和 CET 的扩展作为最好的例子。我们已经在早报上看过几次 SGX 了。

> 引人注目的功能组合，加上强大的物理安全性(内存加密)，使 SGX 对研究人员和从业人员都很有吸引力……然而，SGX 引入了大量的复杂性:由近 200 页的英语/伪代码规范描述的 26 条指令。

在这 200 页中，有近 20 页专门记录了 SGX 与先前建筑特征的互动。事实证明，其中一种互动可能会破坏 SGX 寻求提供的安全保障。这对我来说是新的，尽管我已经读过很多关于利用 SGX 的系统的论文。如果你感兴趣的话，值得在这里追着参考，深入了解“[防止页面错误说出你的秘密](https://www.comp.nus.edu.sg/~shweta24/publications/pfdefense_asiaccs16.pdf)”(CCS ' 16)。该攻击依赖于操作系统控制下的侧通道(因此在 SGX 威胁模型中被认为是在攻击者的控制下):页面错误。通过在几乎每条指令上诱发页面错误，泄漏了足够的信息，使得 OpenSSL 和 libgcrypt 中的加密密钥的平均 27%和高达 100%的秘密位可以被恢复(演示攻击)。

> 也许具有讽刺意味的是，已知的缓解措施中最好的利用了看似无意的与事务性内存扩展的交互:事务中止而不是页面错误，因此操作系统无法观察到事务性飞地内存访问。

老实说，CET(控制流执行技术)扩展听起来很酷。它通过维护影子堆栈和间接分支跟踪来抵御代码重用攻击，例如 [ROP](https://blog.acolyer.org/2015/12/01/rop/) 。*影子堆栈*只包含返回地址，普通代码无法访问。在返回时，来自常规堆栈和影子堆栈的地址被弹出并进行比较——如果它们不匹配，就有麻烦了！

> CET 承诺为不安全的 C/C++代码增加强大的防御，代价是相当大的架构复杂性…主要的复杂性来自于功能交互。x86 中的控制转移已经非常复杂，包括多种形式的调用和返回，例如对不同段或权限级别的远近调用。总共有九个指令(有些有很多变体，如 JMP)被 CET 修改。

### 我们能保持这个速度吗？

我们看到了伴随着复杂交互的系统级功能复杂性快速增长的高速变化。然而，“x86 语义的忠实实现对于 x86 兼容的处理器、虚拟机、仿真器、JIT 编译器、动态翻译器、反汇编器、调试器、分析器等等是必不可少的。”

> …我们不得不质疑核心 x86 在许多实施中无限向后兼容的承诺是否可持续。

### 当改进来自新指令时，利用收益需要更长的时间

第一个 SGX 规范。发布于 2013 年，实现它的第一个 CPU 直到 2015 年才上市，支持 SGX 的服务器级 CPU 仍将在 2017 年初出现。加上充分部署的时间，我们谈论的是从最初规格开始的十年。变得广泛可用。在这个周期的某个时候，软件开发人员将能够在合理假设 SGX 可用性的情况下开始为其开发。

> 这对软件开发人员来说是一个困难的权衡；以前的 ISA 扩展也需要很长时间来部署，但是它们通常只能加速现有的功能；有了像 SGX 这样的功能，开发人员面临着一个严峻的选择:无限期地等待安全性，或者现在就部署而不用它。

加上这种软件滞后，我们可以看到新功能的一般开发将超过十年。

### 硬件和软件之间的界限越来越模糊

仔细阅读英特尔的专利表明，SGX 指令完全是用微码实现的。如果新的 ISA 特性是新的微代码，那么就有可能在现有的 CPU 上支持它们。例如，也许(表现较差？)版本(很多？)新指令可以以这种方式实现，为新特性的采用提供了更快的途径。这方面的许可和收入模式是一个悬而未决的问题(与销售新 CPU 的愿望的互动也是如此)。

> …现在比以往任何时候都更需要重新思考指令集的概念。它不再是硬件和软件之间的界限，而是堆栈中的另一个转换层。