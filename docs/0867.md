# 堆栈构建者——微服务的隐性成本

> 原文:[http://www . stack builders . com/news/the-hidden-costs-of-micro-services？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://www.stackbuilders.com/news/the-hidden-costs-of-microservices?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)



最近有很多关于“微服务”概念的讨论。微服务通过将应用划分成更小的子单元，将面向服务的体系结构提升到了一个新的层次，通常是按照业务能力的路线<sup id="fnref:1">。微服务的支持者指出，微服务能够更容易地“扩展”他们的应用程序以响应需求，并且能够在应用程序编程接口(API)的屏障后面实现封装。</sup>

在最近对微服务的大肆宣传中，关于微服务实现的相关成本的报道相对较少。微服务是一项合理的架构投资，还是一项成本高昂、过早的优化？本文考察了微服务架构的成本，特别是考虑到其发布接口表面积的增加，以及分布式计算的现实。

## 微服务和维护

作为一名软件开发人员，你可能至少一次遇到过某种形式的“依赖地狱”。这可能涉及到您使用的库的意外接口更改，或者库的不兼容版本。帮助减轻依赖性问题的一个更流行的约定是[语义版本化](http://semver.org/)。通过把你的依赖放在服务中而不是一个单独的软件程序中，你有效地发布了你的整个界面。

一旦微服务公开了一个端点，后续的开发就必须支付支持多个服务版本或同步部署服务的成本。从这个意义上说，微服务通过增加发布的 API 端点数量来增加软件系统的维护成本。

集成测试、语义版本控制和连续交付等实践可以最小化因增加发布 API 的规模而产生的成本。这是否值得首先创建微服务的好处，将必须由软件团队的成员来评估。

## 作为分布式系统的微服务

分布式系统的特点是使用消息传递来进行通信，这与其他一些系统不同，例如使用共享内存进行锁定。因此，所有微服务(以及基于 web 的软件系统的许多其他部分)本质上都是分布式系统。作为分布式系统，微服务面临许多工程挑战。下面，我将讨论在分布式环境中，与处理事务、时间、参照完整性和查询相关的复杂性如何影响微服务。

### 分布式环境中的事务

原子事务是程序员可用的最有用的抽象之一，它们最终被用于大多数依赖于关系数据库系统的应用程序中。许多数据库系统，如 [PostgreSQL](http://www.postgresql.org/) ，提供了 [ACID 语义](http://en.wikipedia.org/wiki/ACID)，允许我们依赖事务而不用担心它们的实现。在 PostgreSQL 的例子中，一种叫做[两阶段提交](http://en.wikipedia.org/wiki/Two-phase_commit_protocol)的算法被用来为并发数据库访问提供 ACID 语义。

很容易想到这样一种场景，您会错过已经实现的两阶段提交算法。让我们想象一下，我们正在为一家实现流媒体广播系统的初创公司工作。

在我们假设的应用程序中，我们需要实现一个系统，您可以使用支付信用来购买歌曲。因为您已经很好地将您的应用程序分解为“帐户余额”和“购买的歌曲”两个独立的服务，所以您必须借记余额，这是一个 API 调用，然后购买歌曲。在统一数据库中，这可以通过事务中的几条 SQL 语句轻松完成。相比之下，在您的微服务中，您应该准备好自己实现两阶段提交，否则您可能会遇到跨服务的数据一致性问题。

在分布式系统中实现引用透明性所涉及的复杂性应该强烈警告我们，不要过于激进地将系统分成粒度微服务。一般来说，当您的应用程序分割成多个微服务时，需要一起执行两个操作(即事务性的)的可能性会增加，所以要做好准备，随着您的应用程序的发展，会再次遇到这种情况。事实上，您可能直到系统发布到生产环境之后很久才意识到您需要服务间的一致性，此时以显著的方式改变架构的成本相对较高，这应该是一个强烈的警告，不要提倡在开发早期构建微服务。

### 有时间吗？

处理分布式系统需要抛弃一些您最珍视的假设，这些假设在处理运行在共享内存系统上的软件时是有效的。例如，假设网络中机器上的时钟是相同的是不安全的。正如莱斯利·兰波特所说，“事件的时间顺序的概念渗透了我们对系统的思考。...然而，我们将会看到，当考虑分布式系统中的事件时，必须仔细地重新审视这个概念。

在大多数系统中，至少对于审计或报告目的来说，大致了解事情发生的时间是有用的。根据您的应用，可能对事件的逻辑顺序或时间同步有更精确的要求。在分布式系统中，考虑如何在集群中充分理解时间是至关重要的。你应该仔细阅读关于算法、[逻辑排序](http://en.wikipedia.org/wiki/Logical_clock)和[时间同步](http://en.wikipedia.org/wiki/Clock_synchronization)的[同步系统，以找出哪些考虑因素对你的特定应用是重要的。确保您的预算足以解决分布式系统中复杂的时间问题，无论是在微服务架构应用的初始开发还是后续扩展期间。](http://en.wikipedia.org/wiki/Synchronizer_(algorithm))

### 外键，你在哪里？

外键是数据库系统提供的另一个有用的抽象。外键很有用，因为它们允许您添加约束，以确保系统中的数据反映真实情况。不幸的是，在被设计为微服务的应用程序中，引用完整性的自动执行经常成为创建隔离业务产品的独立服务的牺牲品<sup id="fnref2:1">。</sup>

例如，在我上面介绍的流式广播应用程序中，您可能有一个与系统用户对应的歌曲购买表。让非用户购买歌曲是没有意义的，因此数据库系统允许您指定“引用完整性约束”来确保该属性成立。

对于依赖于独立数据库模式的服务，选项充其量是复杂的。常见的解决方案包括编写软件对数据进行反规范化，以及承担与数据复制相关的风险。最终，一旦放弃了对集中式数据库中外键的抽象，就很难确保数据的一致性。最后，引用完整性约束是一个简单易用的抽象，在迁移到微服务<sup id="fnref2:2">的过程中，您可能不得不放弃它。在这种情况下，您应该记住，您可能需要花费更多的时间来手动验证您的程序是否确保了引用透明性，而不是您可以从数据库系统免费获得的这种属性。</sup>

最终，数据库模式中的约束为您提供了类似于编程语言中的类型系统的置信度。具有适当约束的数据库系统的程序员通常可以读取这些类型，以发现它接受的值域。没有外键约束或依赖于 web 应用程序中的运行时检查会增加编写后续程序的成本，因为开发人员可能必须手动调查数据，以确保它们在与其他数据的关系方面是有效的。

作为一名程序员，我花了无数的时间来处理与没有适当关系的数据相关的程序中的错误，所以我认为缺乏对外键约束的轻松访问是开发微服务架构的一个重要成本。

### 即席查询的复杂性

有了统一的数据库模式，就可以轻松地进行即席查询。最后，在使用标准关系数据库和典型的建模技术时，由于数据的大小或查询的数量，您可能会遇到性能问题。在这一点上，开发人员通常会转向像数据仓库或 T2【NoSQL】这样的解决方案。

还可以考虑通过在可以独立扩展的孤立数据库服务器上部署微服务来解决性能问题。虽然这可能是面向微服务架构的第一个工具，但它有相当大的缺点。具体来说，您不是使用内置工具来聚合数据，而是编写自己的算法来合并来自不同来源的数据，或者添加另一个中间件，如 [Hive](https://hive.apache.org/) 来为您整合数据。这些解决方案在最好的情况下会显著增加基础设施的复杂性，在最坏的情况下会产生大量的工作和额外的代码，需要由应用程序开发人员来编写。

### 这还没有结束

上面，我已经给出了一些具体的案例，在这些案例中，将一个应用程序划分为微服务将增加您作为开发人员的责任。这个列表并不全面。如果你还不熟悉[分布式计算的八大谬误](http://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)，那么现在是时候去看看了，并在心里记下解决现实世界分布式计算场景的成本，在构建微服务之前，你应该知道这些成本。

## 其他问题:微服务及其不满

博客帖子和最近的会议讨论吹捧微服务的许多潜在好处。写完这篇文章的草稿后，我和 Stack Builders 的同事讨论了微服务架构的特性，哪些工作得好，哪些不好。

*   一个开发者提到了一个为政府机构划分微服务的项目。虽然单个产品开始根据它们的数据进行封装，但最终开发了一个框架，用于根据应用程序所需的共享用户数据在应用程序之间复制数据库的一部分。不过，这个系统的一个好处是，不相关的系统部件的隔离增加了容错的元素。

*   几年前，我帮助启动了一个项目，该项目最初是作为微服务构建的，但后来为了加快开发速度又重新组合在一起。在那个项目中，微服务没有允许组件的快速发展；相反，它助长了软件产品团队的反敏捷分裂，这对项目进展是有害的。我与之讨论微服务想法的其他团队成员也表达了对团队成员相互隔离的担忧。通常采取措施鼓励开发人员努力实现相同的目标是非常重要的，这在微服务环境中可能很难做到。

*   我们团队中的开发人员也注意到微服务鼓励“[预先大设计](http://en.wikipedia.org/wiki/Big_Design_Up_Front)”近年来，软件从业者强调迭代软件开发和设计如何降低成本，但微服务具有相反的效果，鼓励我们锁定特定的服务部门。

*   一些微服务的支持者吹捧他们减少耦合的好处。Sam Gibson 在最近的一篇博客文章中指出，传统面向对象语言提供的模块化不足以阻止强耦合程序。他建议依靠微服务来减少耦合。然而，我们的许多开发人员认为，更实用的方法是简单地用传统语言的良好设计实践来更好地遵守纪律，或者采用诸如 Haskell 之类的语言，这种语言鼓励通过纯函数进行解耦设计。与旨在促进模块化设计的现代语言相比，微服务是一种实现解耦的“大锤”方法。

## 结论:公平评估微服务实施的成本

微服务是 web 应用架构中最热门的趋势之一。好处包括单个应用程序组件的可伸缩性、通过产品之间的隔离实现的容错，以及在 API 墙后面封装应用程序逻辑。此外，它通常是组合不同语言的服务的最实用的方法(在我们的例子中，我们更喜欢使用它来组合 Ruby 和 Haskell 应用程序)。

虽然这些好处可能很大，但我认为仔细考虑构建微服务的成本很重要。这些成本包括由于分布式系统的现实而增加的复杂性。微服务的成本通常会急剧增加，因为最初对系统隔离的期望是错误的，或者因为微服务鼓励应该更紧密地朝着共同目标工作的团队分离。

虽然毫无疑问有微服务是最佳选择的使用案例，但我认为我们应该小心不要在任何给定的项目中过早地使用微服务。在许多情况下，一个更实际的决定可能不是决定使用微服务，而是仅仅依靠您选择的编程语言所提供的实现模块化的方法，以便在基于初始开发的经验证明微服务确实合理的情况下，为微服务开辟道路。

* * *

### 信用

我要感谢 Eric Jones、Enio Lopes、Juan Pablo Santos、Marcin Olichwirowicz、Juan Pedro Villa 和 Juanda Zapata 对这篇文章的早期版本提供了有用的评论。

