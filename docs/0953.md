# 缩放秘密:实时聊天。(这是系列文章的第一篇… |作者:David Byttow |永远要编码| Medium

> 原文：<https://medium.com/@davidbyttow/scaling-secret-real-time-chat-d8589f8f0c9b?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>



# 扩展秘密:实时聊天

(这是我打算写的一系列技术文章的第一篇，我的目标是帮助其他工程师学习构建和扩展 Secret 的经验。)

所以很多消费类应用都提供聊天功能(尤其是社交网络和约会类应用)。几乎所有的都有自己独特的方式，几乎所有的都以这样或那样的方式损坏，通常它们要么太慢(不是实时的)要么太不可靠(消息无法发送或被欺骗)，这令人惊讶，因为聊天自互联网早期就已经存在了。

我认为聊天应该是应用程序中最好的体验之一，以促进人们之间的实时对话。最起码:

*   体验应该是快速、可靠和简单的
*   用户不应该需要“拉至刷新”来获取新消息

然后，需要回答一些特定于应用的问题:

*   多少用户可以一起聊天？
*   用户可以发送照片或视频吗？
*   聊天是永久的还是短暂的？
*   用户是否应该知道收件人何时阅读了邮件(阅读回执)？
*   用户应该知道对方什么时候在输入信息吗？
*   用户是否应该知道对方正在查看聊天内容(在线状态)？



## 要求

私下里，实时聊天是一个长时间的讨论，也是我们从第一天就开始谈论的事情。出于各种原因，我们没有实施该计划:

1.  我们觉得核心体验需要强大，我们不想增加太多太快
2.  我们不希望私下谈话影响公开讨论
3.  我们没有一个强有力的案例来说明它应该如何工作，或者为什么它对整个产品很重要

当我们在 2014 年 12 月下旬进行重新设计时，我们增加了社区和陌生人联系的功能，这变得更有意义了。

Secret 的聊天要求是:

*   两个用户都应该完全匿名
*   任何用户都可以与帖子的作者或任何其他评论者聊天
*   聊天应该快速、可靠、干净(令我们的设计师懊恼的是，我反对“聊天气泡”，想要一个更线性、更简单的聊天，类似于 Snapchat、IRC、Slack)
*   聊天应该是短暂的。我们不想让人们觉得他们的私人讨论没完没了(自上次交流后持续了 24 小时)
*   用户应该能够发送(短暂的)照片
*   它应该感觉像一次对话，尽可能模仿真实世界。表明此人在场(当你说话时有人看着你)，表明此人已经阅读了你的信息(确认或点头)，表明此人正在打字(有人在说话，你应该注意)



我们知道聊天将是该产品的一个热门功能。快速粗略计算得出的结论是，假设我们有 5%的同时活动者在聊天，我们需要从第一天开始就准备好支持多达 50，000 个用户同时聊天(50，000 个持久连接)。

注意:我们还为应用内通知的每个会话建立了一个全局的每个用户的私有连接(推送通知既不可靠也不快速)。为此，我们还需要超过 100 万个连接。

所有这些不仅对于完整的产品重新设计，而且对于产品中全新的聊天功能都是一项艰巨的任务。

我们挑战自己，在不到三周的时间里，在 iOS 和 Android 上构建并发布聊天工具。我们成功了，这要归功于我们的客户团队(阿莫尔·贾恩、杰森·拜托、萨弗尔·万吉和萨拉·海德尔)和我们的设计团队(李志希、塞西莉·帕克和克里斯·巴德)。以下是我们如何构建它的(工程方面):



## 体系结构

当我们谈到实现聊天时，我们通常会谈到三个选项:

1.  使用第三方聊天服务(例如，[层](https://layer.com/)
2.  使用第三方 websocket 实现(例如， [Pusher](https://pusher.com/) )
3.  推出我们自己的基于 websocket 的协议，由运行在 AWS 或 GCE 上的服务器提供支持(当时我们几乎完全托管在 App Engine 中)

聊天需要快速，但它不足以进行轮询(用请求杀死你的服务器，用缓慢杀死你的用户)，所以我们需要持久连接(例如， [websocket](http://en.wikipedia.org/wiki/WebSocket) )。

我们很快放弃了第一个选项(层)，因为我们希望控制我们自己的用户数据，我们希望完全控制堆栈和体验(诚然，我们没有深入研究层的整个产品，但我们觉得滚动我们自己的将是最快的路径)。

虽然有些人认为第三条是最好的选择，但我相信第二条可能实际上效果最好。我用了一个周末的时间，在 Pusher 的基础上，拼凑了一个基于网络、仅供内部使用的原型。

建筑很简单。这是一个简单请求流的(粗略)图像。



Wow, I have bad handwriting.



当用户进入聊天室时，会创建一个[私人在线通道](https://pusher.com/docs/client_api_guide/client_presence_channels)，并与推送者建立连接。这使得用户在聊天室中可以收到来自 Pusher 的通知。当用户离开或后台应用程序时，它被销毁。幸运的是，有第三方 Pusher 协议库(尽管我们不得不修改它们)可用于 iOS 和 Android，这加速了开发。

在这个图像中，有两个用户(A 和 B)出现在同一个聊天室中。

1.  用户 A 按下消息上的 send，然后使用聊天 id 向秘密前端发出 POST 请求
2.  服务器检索聊天会话数据，添加消息，并将其写回
3.  服务器向推送器发出 POST 请求，并为客户端提供有效负载
4.  Pusher 通过 websocket 连接将消息路由到用户 B

打字通知和送货收据非常相似。

在这个模型中，尽管从延迟的角度来看并不完美，但它足够好且简单，因为请求只向一个方向流动:客户机->服务器->推送器->客户机

还需要注意的是，Pusher 只用于实时通知，而不用于规范数据。如果用户在任何时候回到聊天室，它将从服务器刷新最近的状态，并从那里接受任何新的通知。类似于呈现单页应用程序并通过 AJAX 或 websocket 将更改传递给客户端。

## 代码和型号

后端存储的数据模型很简单。Secret 的标准数据存储是 Google App Engine 的高复制数据存储(在其他博客文章中有更多相关内容)。本质上，它是一个基于 BigTable 和 Megastore 的无模式 NoSQL 数据存储。实体是文档结构，按给定的键存储在行中。没有连接，查询语义也非常有限，但是它允许非常高的读取吞吐量和广泛的伸缩性，这是您从 NoSQL 产品中所期望的。



当用户进入聊天室时，在服务器上创建一个幂等 id，实际上是“ <user1_id>: <user2_id>: 【T2”，也称为聊天会话 ID。重要说明:这个键中的用户 id 总是排序的(部分排序)，保证了幂等性。这样，给定一对用户和一个秘密，我们总是可以为该秘密生成一个 ID。</user2_id></user1_id>

聊天会话由简单的 id 键入，并在一行中包含上述数据。每次聊天发生变化时，服务器都会对该行执行事务性的读-修改-写操作。只要每个实体的写入吞吐量保持在< = 1 次写入/秒，事务就没有问题。

例如，当一个用户离开一个聊天，我们想提醒收件人他们已经这样做了。服务器端代码如下所示:



很简单。

对于像向用户显示他们所有正在进行的或以前的聊天这样的快速查询，我们在参与者上创建了索引并创建了时间属性，允许像“获取聊天用户 X 是按降序排序的时间中的参与者”这样的快速回答，并按最后更新时间进行本地排序。因为自上次消息交换以来，聊天只持续了 24 小时，所以我们知道聊天的数量对于在服务器上本地获取和排序来说是相当小的(例如，几乎在所有情况下都小于 100)。如果他们超过了，很有可能用户是一个糟糕的演员，我们可以把一些放在地板上。代码很简单:



这里有一个我刚刚开源的小库，用于通过 Go(在 App Engine 环境中)直接与 Pusher 对话。您可以很容易地调整这一点，整个过程中唯一棘手的部分是认证私有和存在通道的请求。[https://github . com/guitar Dave 24/pusher-go-app engine/blob/master/pusher . go](https://github.com/guitardave24/pusher-go-appengine/blob/master/pusher.go)

## 发动

当我们开始重新设计时，聊天一炮而红。它一周接一周地增长到超过 1，000，000 个并发连接(聊天+通知)。幸运的是，Pusher 工作得很好，而且相当便宜，我们的线性扩展达到了一个点，假设 Pusher 能够满足我们的需求，我们在可预见的未来不会有任何问题。

在这次经历中，我得到的主要收获和强化是:

*   从小处着手，准备构建一个抛弃型原型来帮助做出决定
*   推出自己的实现通常是不明智的，不管它可能有多有趣(显然，但我们都一直在这样做！)

如果我再次在应用程序中实现实时聊天，我会强烈考虑再次使用这样的简单模型。上述架构的缺点是速度不够快(值得注意的是，因为消息是通过秘密前端路由到 Pusher 的)，但最终结果是足够快、可靠和简单。

希望你觉得这很有趣和/或有用，如果你有任何问题，请不要犹豫给我发电子邮件到 [d@secret.ly](mailto:d@secret.ly) 或者在 Twitter 上关注我 [@davidbyttow](http://twitter.com/davidbyttow)

David Byttow





