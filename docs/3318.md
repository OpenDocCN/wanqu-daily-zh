# 现代软件过度工程化错误|由 RDX | Medium

> 原文：<https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

# 现代软件过度工程化的错误

很少有东西能保证一直增长:恒星之间的距离、可见宇宙中的熵，以及**他妈的商业需求**。许多文章说*不要过度设计*，但是没有说为什么或者如何。这里有 10 个明显的例子。

> **重要提示:**下面一些类似“不要滥用泛型”的观点被误解为“根本不要使用泛型”、“不要创建不必要的包装器”等。我只讨论过度工程化，不提倡牛仔编码。

# 1.工程比商业更聪明

工程师认为我们是最聪明的人，因为我们制造东西。这第一个错误经常使我们过度工程化。但是如果我们计划 100 件事，商业总是会想出我们从未想到的第 101 件事。如果我们解决了 1000 个问题，他们会带着 10000 个问题回来。我们认为一切都在我们的控制之下——但是我们不知道会发生什么。



We think you have everything under control — But we have no clue whats headed our way. Image courtesy [http://jamesbond.wikia.com/wiki/Casino_Royale](http://jamesbond.wikia.com/wiki/Casino_Royale) and [http://fortune.com/2015/07/06/failed-trump-businesses/](http://fortune.com/2015/07/06/failed-trump-businesses/)



在我从事编码工作的 15 年中，我从未见过任何一个企业在需求上“趋同”。他们只是分歧。这是商业的本质，不是商人的错。

> TL；DR —公司(企业)总是赢家

**提示:**如果你没有时间浏览整篇帖子，那么这一点就足够了。

T2】

# 2.可重用的业务功能

当业务抛出越来越多的功能时(正如预期的那样)，我们有时会做出这样的反应:



我们试图尽可能地对逻辑进行分组和概括。这就是为什么大多数 MVC 系统要么以胖模型告终，要么以胖控制器告终。但是正如我们已经看到的，业务需求只会分散，不会集中。

相反，我们应该如何反应:



在自然系统中，共享逻辑和抽象往往会随着时间的推移而趋于稳定。随着功能的扩展，它们要么保持不变，要么相对下降。当相反的情况发生时，它会创造出“大到不能倒”的系统(导致可怕的重写)。

**示例:**我们为以前的客户创建了一个用户档案系统。从具有共享功能的 CRUD 控制器开始，因为我们假设一切都是相似的。但最终有 13 种不同的注册流程——初始社交连接、首次登录时的长注册表单、较小的编辑页面部分、外观完全不同的个人资料页面等等——最终分享内容没有什么意义。类似地，订单视图和订单编辑流最终与实际的订购流本质上是不同的。

在水平拆分之前，先尝试垂直拆分业务功能。这适用于所有情况——隔离服务、基于主干的服务、特定于语言的模块等。也有助于轻松地从一种形式切换到另一种。否则，改变系统的某些部分会变得越来越复杂。

> TL；灾难恢复——更喜欢隔离行动，而不是组合行动

**提示:**在你的代码库中选择一个面向外部的动作(端点/页面/作业/等等)。一个人需要多少次上下文切换才能理解正在发生的事情？





T2】

# 3.一切都是通用的

(有时与前面的观点相结合，但也可以在单独的项目中单独应用)

*   想要连接到数据库吗？让我们编写一个通用适配器
*   查询数据库？通用查询
*   给它一些参数？通用参数
*   建立那些参数？通用生成器
*   映射响应？通用数据映射器
*   处理用户请求？通用请求
*   执行整件事？普通执行人
*   等等等等

有时候工程师会忘乎所以。我们没有试图解决业务问题，而是浪费时间试图找到完美的抽象。答案就是这么简单。



Whats’s the perfect abstraction? Image courtesy [https://www.pinterest.com/pin/415738609324811773/](https://www.pinterest.com/pin/415738609324811773/)



设计总是在追赶不断变化的现实世界的需求。因此，即使我们奇迹般地找到了一个完美的抽象，它也有一个截止日期，因为# 1——房子最终会赢。今天设计的最佳质量是它能被设计得多好。有一篇关于[写代码容易删除，不容易扩展](http://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to)的惊人文章。

> TL；灾难恢复——复制比错误的抽象要好

相反，对于正确的抽象来说，复制有时是必不可少的。因为只有当我们看到系统的许多部分共享“相似”的代码时，更好的共享抽象才会出现。抽象的质量是最薄弱的环节。复制暴露了许多用例，并使边界更加清晰。

**提示:**跨服务的共享抽象有时会导致[微服务最终成为分布式的整体](https://www.infoq.com/news/2016/02/services-distributed-monolith)。

T2】

# 4.浅包装纸

> 这是整篇文章中最难的一点。快速提醒一下，我们正在讨论过度工程。

在使用每个外部库之前对其进行包装的做法。不幸的是，我们写的大多数包装器都很肤浅。我们在交付功能和编写一个好的包装器之间周旋。因此，我们的包装器大多与底层库紧密绑定(在某些情况下，是 1:1 的镜像，或者以 10 倍的努力做原始库的 1/10)。如果我们以后改变底层库，这个包装器在任何地方的使用通常最终也必须改变。有时，我们还在包装器中混淆了业务逻辑，使得它既不是一个好的包装器，也不是一个好的业务解决方案，而是介于两者之间的某种粘合层。

**这是 2016 年。**外部库和客户端有了长足的进步。OSS 库棒极了。他们有由令人敬畏的人编写的高质量和经过良好测试的代码库，这些人花费了**专注的**时间来编写它。大多数都有清晰的、可测试的、可检测的 API，允许我们遵循初始化——检测——实现的标准模式。

> TL；DR-Wrappers 是一个例外，而不是标准。不要为了包装而包装好的库

**提示:**创建一个“不可知论”的包装器可不是闹着玩的。“换出库”来自于“可配置性”的思想，这将在后面的“< X > -ity”一节中详细介绍。

T2】

# 5.像使用工具一样应用质量

盲目地应用质量概念(比如将所有变量改为“私有 final”，为所有类编写一个接口，等等)不会让代码神奇地变得更好。

查看[企业 FizzBuzz](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) (或 [Hello World](https://gist.github.com/lolzballs/2152bc0f31ee0286b722) )。它有大量的代码。在微观层面，每个类都遵循坚实的原则，使用各种优秀的设计模式(工厂、构建器、策略等)和编码技术(泛型、枚举等)。它从 CQM 工具获得高代码质量评级。

但是如果我们后退一步，这个会发出嘶嘶的嗡嗡声。

> TL；DR——总是后退一步，看看宏观情况

相反，自动化 CQM 工具擅长跟踪测试覆盖率，但是不能告诉我们是否测试了正确的东西。基准测试工具可以跟踪性能，但不能判断东西是并行运行还是顺序运行。只有人类才能看到全局。

这将我们带到…

## 5.1.夹心层

让我们采取一个简洁的，紧密结合的行动，把它分成 10 或 20 个夹层，其中没有一个单独的层没有整体意义。因为我们想应用“可测试代码”的概念，或者“单一责任原则”，或者别的什么。

在过去，这是通过一系列的继承来完成的。a 扩展 B 扩展 C 扩展 D，依此类推。



Sandwich Layers in 2000



**现在** —人们做完全相同的事情，除了他们让每个类都有一个接口/实现，并将其注入下一层，因为 duh SOLID。



Sandwich layers in 2016 with SOLID



像 SOLID 这样的概念是对滥用继承和其他 OOP 概念的回应。大多数工程师不知道这些概念来自哪里/为什么，但最终只是按照备忘录行事。

> TL；灾难恢复——观念需要转变。不能像工具一样盲目应用。

学习一门不同的语言，尝试另一种做事的心态。这是一个更好的开发人员。把旧酒倒在贴有新标签的瓶子里对概念不起作用。我们永远不需要以应用一个概念的名义来撕毁一个清晰的设计。

T2】

# 6.过度热心的收养者综合症

> 发现了泛型。现在甚至一个简单的“HelloWorldPrinter”也变成了“HelloWorldPrinter <string>”。</string>

当问题显然只处理特定的数据类型时，或者当普通的类型签名足够时，不要使用泛型。

> 发现战略模式。每个“如果”条件现在都是一种策略。

为什么？

> 发现了如何编写 DSL。将在任何地方使用 DSL。

我不知道…

> 二手仿制品。会嘲笑我测试的每一件物品。

如何甚至…

> 元编程很棒，让我在任何地方都可以使用它

描述为什么…

> 枚举/扩展方法/特征/无论什么都很棒，让我到处用

这是不对的。

> TL；DR-TL；DRs 不应该在任何地方使用

T2】

# 7\. <x>–ity</x>

*   可配置性
*   安全性
*   可量测性
*   可维护性
*   展开性
*   …

含糊不清。无人质疑。很难反驳。FUD。

**示例 1:** 让我们为表单构建一个 CMS 以实现“可扩展性”。业务人员可以很容易地添加新字段。

**结果:**商务人士没用过。当他们不得不这样做的时候，他们会让一个开发人员坐在他们旁边做这件事。也许我们所需要的只是一个简单的开发者指南来在几个小时内添加一个新的字段，而不是一个点击式界面？

**例 2:** 让我们设计一个大的数据库层，以方便“配置”。我们应该能够在一个神奇的文件中切换数据库。

**结果:**10 年来，我只见过一家企业认真努力完全替换完全授权的数据库。当它发生时,“神奇文件”并没有帮助。有太多的操作工作。功能上的不兼容性和差距。客户要求我们将“一半”的模型切换到新的 NoSQL 数据库。我们把头发分开——我们的魔法开关是单点改变，但这是交叉的。

在今天的世界中，我们已经远远超过了这样一个点，即**没有办法**为现代文档/KV 存储(例如 Redis/ CouchDB/ DynamoDB/ etc)设计一个单一的可配置层。甚至像 Postgres/ HSQLDB/ SQLite 这样的 SQL 数据库也不兼容。要么你完全哑掉你的数据层(并努力交付功能)，要么承认数据库是你的解决方案的一部分(例如 postgres geo/json 特性)并抛弃可配置性的负罪感。你的栈和你的代码一样是你的解决方案的一部分。当你放下这个模糊的 X，更好的解决方案开始出现。例如，您现在可以垂直地(每个动作的小 Dao)而不是水平地(神奇的可配置层)划分数据访问，或者甚至为不同的功能[微]服务风格挑选不同的数据存储。

**例 3:** 我们为企业客户构建了一个 OAuth 系统。对于内部管理员，我们被要求使用一个辅助的 Google OAuth 系统。因为安全。如果有人入侵我们的 OAuth，企业不希望他们获得管理凭证。Google OAuth 更安全，谁能在任何一点上反驳“更安全”呢？

**结果:**如果有人真的想黑进我们的系统，他们不需要通过 OAuth 层。我们有很多弱点。例如，他们可能已经完成了权限提升。因此，与首先适当地保护我们的基础相比，在保护我们的系统方面，支持两种不同的 OAuth 用户配置文件和系统的所有努力几乎没有回报。



> TL；不要让事情不受挑战。清楚地定义和评估场景/故事/需求/用途。

**提示:**问一个简单的问题——“什么是示例故事/场景？”—然后深入挖掘这个场景。这暴露了大多数 T2 城市的缺陷。



T2】

# 8.内部“发明”

刚开始感觉很爽。但这是几年来最常见的遗产来源。一些例子:

*   内部库(HTTP、mini ORM/ODM、缓存、配置等)
*   内部框架(CMS、事件流、并发、后台作业等)
*   内部工具(构建链、部署工具等)

错过的事情:

*   这需要很多技巧和对问题领域的深刻理解。一个“服务运行者”库需要关于守护进程如何工作、进程管理、I/O 重定向、PID 文件等等的专业知识。CMS 不仅仅是呈现具有某种数据类型的字段，它还具有字段间依赖、验证、向导、通用呈现器等等。即使是简单的“重试”库也不是那么简单。
*   保持这种状态需要不断的努力。即使是一个很小的开源库也要花很多时间来维护。
*   如果你开源它，没人会在意。除了最初的启动者和付费工作的人。
*   最初的创业者最终会带着“X 的发明者”标签离开。
*   现在，对现有框架做出贡献需要花费更多的时间。但是创造一项“发明”需要花费更多的时间。

> TL；灾难恢复—重复使用。叉子。投稿。重新考虑。

最后，如果**真的被**推进去做，那就只带着内部 OSS 的心态去做。与现有竞争对手竞争。努力说服内部人员使用它。既然你是圈内人，就不要想当然。

T2】

# 9.遵循现状

一旦某样东西以某种方式实现了，每个人都会在它的基础上开始构建。没有人质疑现状。工作代码被认为是“正确的方式”。即使在从来没有打算过的情况下，人们也会想尽办法去适应现有的环境。

一个健康的系统在搅动。一个不健康的系统只是附加的。长时间看不到提交的代码区域就是气味。我们被期望保持系统的每个部分运转。[这里有一篇精彩的文章详细解释了这一点](http://ronjeffries.com/xprog/articles/refactoring-not-on-the-backlog/)。

团队每天如何迭代与他们应该如何迭代:



Image courtesy [http://ronjeffries.com/xprog/articles/refactoring-not-on-the-backlog/](http://ronjeffries.com/xprog/articles/refactoring-not-on-the-backlog/)



> TL；灾难恢复——重构是每个故事的一部分。没有代码是不可触及的

T2】

# 10.错误估计

我们经常看到真正优秀的团队/编码人员最终产生垃圾。我们看到了他们的代码库，并想知道“WTF，这真的是由那个我认为很棒的团队/个人开发的吗？”

质量需要时间，而不仅仅是技能。聪明的开发人员经常高估他们的能力。最后，他们最终采取丑陋的黑客来完成自杀时间表上的东西。

> TL；DR——糟糕的评估甚至在编写一行代码之前就破坏了质量

T2】

如果你能走到这一步，谢谢！提醒一下，我只讨论过度工程化，不提倡牛仔编码。更多链接: