# 管理技术债务- ACM 队列

> 原文：<http://queue.acm.org/detail.cfm?id=2168798>

<label>March 23, 2012
**[Volume 10, issue 3](issuedetail.cfm?issue=2168796)**</label>

[![Download PDF version of this article](img/d41c7b6eb6493a00953aa6dd3bd5eac4.png) PDF](https://dl.acm.org/ft_gateway.cfm?id=2168798&ftid=1185692&dwn=1)

# 管理技术债务

## 今天省钱省时的捷径可能会让你付出代价。

### 埃里克·奥尔曼

1992 年，沃德·坎宁安在 OOPSLA(面向对象编程、系统、语言和应用)上发表了一篇报告 <sup>2</sup> ，他在报告中提出了技术债务的概念。他用不成熟的代码来定义它:“发布第一次代码就像负债。”然而，技术债务并不局限于第一次编写的代码。承担技术债务有很多方式和理由(不全是不好的)。

技术债务通常是由工程“最佳实践”和其他因素(交付日期、工具成本和可用工程师的技能等)之间的紧张关系造成的。粗略地说，当工程师走捷径而没有达到最佳实践时，就会产生技术债务。这包括偷偷摸摸地进行抽象，因为很难(或不可能)弄清楚如何“正确地做这件事”，跳过或删减文档(包括代码和外部文档)，使用模糊或不完整的错误消息，因为很难创建更有信息量的东西，使用简单但缓慢的算法实现代码，即使他们知道在生产中需要更好的算法，在实际上应该创建适当的联合*时使用 void*， 使用不太适合当前系统的构建工具，忽略良好的安全实践，不编写单元测试，等等。 承认吧——在你职业生涯的某个时候，你都做过这些事情中的一件或多件(或者全部)。(技术债务也可能被有意当作一种节省时间或金钱的策略；稍后会详细介绍。)

并非所有债务(无论是技术债务还是金融债务)都是坏的。我们很少有人能付得起现金买房，只要我们知道如何偿还，负债买房也不是财务上的不负责任。相比之下，用信用卡支付奢侈品的费用，很清楚你的薪水不够支付这些费用，通常会导致灾难。在原型中使用简单但缓慢的算法可能正是正确的途径，只要您在代码发布之前有一个如何更新代码的计划。这意味着在时间表中留出时间，确保问题得到跟踪，这样它就不会在混乱中丢失，当你实现代码时，知道在这种情况下确实存在一个好的算法，并相信管理层会支持你。

理解、交流和管理技术债务可以对系统的短期和长期成功产生巨大的影响。(注意，尽管本文关注的是软件工程中的技术债务，但是这些原则中的许多可以应用于其他技术学科。)

### 与金融债务的比较

进入金融债务通常有三个重要的属性。首先，贷款人希望贷款最终得到偿还。第二，你通常要连本带利地还——也就是说，你还的钱比你一开始得到的钱还多。第三，如果事实证明你无法偿还，成本会非常高，无论是宣布破产、失去房子，还是(如果你向错误的人借了钱)穿着水泥鞋从一个短码头上走很长一段路。

技术债务在某些方面是相似的，但在其他方面是不同的。尽管您不必按照任何固定的时间表偿还债务(有些债务可能永远也不需要偿还)，但您通常必须偿还(即重写代码或以其他方式修复问题)对您或您的客户有重大影响的部分。“利息”是在你或任何人(支持人员、未来的程序员、客户等)每次。)由于错误、性能问题、莫名其妙的错误特性、花费时间研究什么出了问题，而系统本可以给出更明确的错误消息，等等，使用您的系统的工作被延迟了。未能修复问题可能导致系统的彻底崩溃——客户放弃并转向其他地方，系统变得如此缓慢和脆弱，以至于不得不从头重写，或者在极端情况下，公司被迫关门。

也有一些显著的差异。也许最致命的一点是，承担技术债务的人不一定是必须偿还债务的人——事实上，大多数时候，承担债务的人可以将成本转嫁给其他人，这鼓励了承担债务。太多的开发人员不维护他们自己的代码。许多公司有一个政策，软件从由他们最好的程序员组成的开发模式转移到由二流工程师组成的维护模式(他们的工资较低，但工作通常比一流团队困难得多)。有时甚至不是组织中的任何人支付利息:而是用户必须支付。比起长期的可维护性，开发人员在实现速度上得到的回报更多，并且可能在真正的成本被支付之前已经转移到不同的项目或公司。这使得最初的开发人员没有动力在第一次就把工作做好。

与金融债务不同，技术债务几乎永远不必全部还清。大多数(可能是所有)生产系统都有缺陷，这些缺陷对最终系统的可用性或长期可维护性没有重大影响。很少有系统在源代码中没有 TODO、FIXME 或 XXX 注释。请注意，偿还技术债务的成本是以重写或重构代码或修复问题所需的工程时间的形式出现的。如果你最终获得的利息低于偿还债务的成本，那么一开始就没有必要偿还。问题在于，很难事先知道哪些债务最终成本最高。

例如，当加州大学伯克利分校的 CalMail 系统在 2011 年 11 月宕机时，问题被追溯到延迟维护——特别是，即使已知系统已接近饱和，也决定推迟更新系统。RAID 中的一个磁盘损坏，紧接着第二个磁盘也损坏，重建阵列的成本大大降低了容量，足以引发危机。在决定接受多少技术债务时，需要考虑墨菲定律。在 CalMail 案例中，单个硬件故障在基本设计中是意料之中的，但是在历史高使用率高峰期间发生的多个故障造成了无法快速解决的情况。据伯克利大学负责信息技术的副校长兼首席信息官 Shelton Waggener 说:“考虑到我们迁移到新技术的计划，我决定不花费百万美元来升级仅使用 12 个月的 CalMail 软件。考虑到预算情况，我们试图保持谨慎，(但)回顾过去，投资存储升级会更好，这样我们就可以避免这场危机。”在这个案例中，技术债务是有意承担的，但结果却是一场糟糕的赌博。如果该系统在 12 个月的窗口期内存活下来，学校可能会在预算紧缩期间节省 100 万美元。

有一种说法认为工程中有三个变量:时间、功能和资源——选择两个。事实上，还有第四个变量:债务。这四个变量，你可以设置其中任意三个，但永远不能设置全部四个；有些东西必须付出，通常债务是等式中的自由变量。债务一开始看起来是“免费”的，但是技术债务往往是建立在自身之上的。如果债务的获得涉及到以增加维护和扩展系统的努力的形式的利益，那么当你承担债务时，维护和扩展就变得更加困难和耗时。这是债务下崩溃的一种形式:如果你所有的“收入”(以努力的形式)都花在了偿还利息上，没有留下任何东西来推动系统前进，那么这个系统就卡住了。如果生产率是以每天产生的代码行数来衡量的话，这一点尤其明显，这种衡量标准应该被打入地狱之火。你剩下的选择不多了:加把劲(多雇几个工程师)，抛弃体制继续前进，或者破产。从这个意义上说，技术债务的利息实际上是复利，或者换句话说:如果你不在债务之上，那么随着时间的推移，支付额会上升。

想想其他有趣的对比。Construx Software 首席执行官兼首席软件工程师史蒂夫·麦康奈尔(Steve McConnell)区分了无意债务和有意债务，后者又分为短期(战术)债务和长期(战略)债务。他还指出，当一个系统接近生命周期的尽头时，承担债务变得更有吸引力，因为当一个系统退役时，所有的债务都会被偿还。他还就如何向非技术人员传达技术债务的概念提出了一些有趣的观察，部分是通过在跟踪系统中维护“债务积压”，并以美元而不是更面向技术的东西来揭示它。

在一个稍微不同的分析中，软件设计师 Martin Fowler 在两个轴上分解技术债务:鲁莽/谨慎和故意/无意。他将不计后果的债务描述为“我们没有时间进行设计”，将不计后果的债务描述为“什么是分层？”谨慎——深思熟虑地说“我们必须立即发货并承担后果”这暴露了不容易映射到财务模型的第四类技术债务:谨慎-疏忽，他将其描述为“现在我们知道我们应该如何做。”

另一个引起一些人共鸣的对技术债务的分析是，管理技术债务是管理技术领域风险的一种方式。软件顾问史蒂夫·弗里曼(Steve Freeman)通过将技术性债务与未对冲(或“裸”)看涨期权进行比较来讨论这一问题。任何一种情况(风险或未对冲的看涨期权)都考虑到了债务可能永远不需要偿还的可能性；的确，通过承担适当的风险可以赚大钱。然而，裸看涨期权也可能失去所有价值——本质上，风险是无限的。这种情况并不经常发生(大多数情况下，当你亏损时，你只是损失了一部分钱，而不是全部)，但这种情况可能发生，就像技术债的错误选择可能导致灾难一样。

到目前为止，我们一直在谈论技术债务，就好像它是编码人员独有的一样。这远非事实。例如，运营部门会产生自己的债务。避免磁盘阵列升级是技术债务和财务成本之间的权衡。在向机房添加新的、温度更高的设备时，未能考虑电力和冷却需求是一种负担。无法自动化一个简单但乏味的手动过程是一笔债务。另一个例子是，系统管理员既没有(因为缺乏欲望、灵感或时间)记录他们支持的系统，也没有在休假前培训同事。在这些与代码无关的情况下，技术债务与风险管理的对比往往更加明显:你在打赌你不会用完磁盘空间或带宽，你不会有超热的一天，你的系统不会变得如此成功以至于手动过程成为瓶颈，或者当你在马丘比丘的时候不会出错。

某些人员问题会导致另一种形式的技术债务:部分系统只被一个人理解。有时，这种情况的发生是因为员工太分散，但也可能是因为缺乏安全感的个人认为如果他们把其他人都蒙在鼓里，那么他们就不可或缺。当然，问题是每个人最终都会向前看。

### 管理你的债务

技术债不可避免。问题不在于消除债务，而在于管理债务。当一个项目开始时，团队几乎从来没有完全掌握问题的整体。这是软件开发的瀑布模型失败的根源，瀑布模型假定所有的需求可以在设计开始之前最终确定，反过来可以在系统实现之前完成，等等。这个论点看起来不错:随着系统的发展，做出改变的成本呈指数增长，所以最好的方法是在继续前进之前把早期阶段做好。现实是需求总是变化的(“需求变动”)。拥有一个工作原型通常更好(即使它不完整或不完美)，这样您和客户就可以开始获得系统的经验。这是敏捷编程背后的哲学，它接受一些技术债务是不可避免的，但也要求一个补救过程(“变更计划”)。

尽管技术债务可能是必要的，但迅速偿还其中的战略部分也很重要。随着时间的推移，程序员跳槽到其他公司，同意各种妥协的人已经转移到其他项目，被其他不这么看的人取代。未能为初始原型编写文档(包括内部和外部)可能是一个很好的权衡，但时间越长，就越难编写——如果仅仅是因为人类的记忆是短暂的，如果你向大多数人展示他们一年前编写的代码，他们将不得不研究它以记住他们为什么这样做。旨在具有有限生命周期的代码可能不受这些问题的影响，但是许多短期的“原型”最终会交付给客户。不幸的是，弗雷德·布鲁克斯在《人月神话》中说，“计划扔掉一个；无论如何，“T2 1 似乎经常会被腐蚀，”使你的原型可以运输；无论如何，它会的。”这两种说法并不矛盾。

同样重要的是，某些形式的技术债务非常昂贵，应该尽可能完全避免。安全是一个走捷径会导致灾难的领域。除了非常早期的原型之外，除了你不会看到的，你永远不会想说，“我们今天使用的是明文密码，但我们有一天会回来，把它改成挑战-响应”。如果它被意外部署，这将是一场灾难。你也想避免在代码中隐藏“赌你的公司”的快捷方式。如果由于某种原因你别无选择(例如，因为在开发过程中，其他工程师必须编写与你的代码接口的代码，而你不能让他们等待)，那么就写一本“在发布之前必须偿还的债务”的日志令人惊讶的是，如果不把这些事情写下来，忘记它们是多么容易。

发布周期会对技术债务的获取和处理速度产生相当大的影响。“尽早发布，经常发布”的现代趋势，尤其是在基于 Web 的服务环境中，使得承担技术债务变得更加容易，但也使得解决债务变得更加容易。如果管理得当，这可能是一件好事——更早地承担债务可以让你更早地发布更多的功能，允许来自客户的即时反馈，从而产生更能响应用户需求的产品。然而，如果债务没有被及时偿还，它也会更快地复利，系统会以一个真正令人恐惧的速度陷入困境。特别是基于网络的服务的另一面是，一个正确但低效的解决方案实际上会让你的公司花费更多的钱——例如，以服务器场租赁费的形式。幸运的是，这使得债务很容易转换成美元的形式，非技术利益相关者通常会发现这比关于可维护性的断言更容易理解。

并非所有的技术债务都是程序员懒惰的结果。有些债务是由管理层或其他部门强加的，尤其是当他们不明白这种债务有多有害的时候。客户通常购买功能，而不是长期可维护性，因此营销部门通常鼓励工程人员继续下一个伟大的事情，而不是花费必要的时间来整合、清理和记录现有系统。对他们来说，采取这些步骤是一种不必要的成本——毕竟，系统在今天仍然有效，所以为什么工程需要花费时间来画蛇添足呢？

技术债务还有另一个方面需要考虑:它以多种方式出现，并且是持续的。当然，它可能来自设计或实现阶段，但也可能发生在操作阶段。例如，一个计算机系统可能已经设计并安装了 UPS(不间断电源),但是延迟维护——以未能测试这些单元并更换电池的形式——会使它们变得无用。当指定时，磁盘阵列可能就足够了，但是随着系统的增长，它们必须升级。当试图从资金紧张的管理层那里榨取美元来升级在他们看来运行良好的东西时，这可能尤其困难。

管理层经常助长和助长这个问题。如果股东有足够的耐心奖励长期价值创造，那么当前的商业口号“股东价值”就没问题。相反，趋势是每季度考虑一次，而不是每十年一次，这给组织中的每个人带来了巨大的压力，要他们尽可能快地生产尽可能多的产品，而不考虑长期成本(正如一句古老的哀叹所指出的，“永远没有时间做对，但总有时间重做”)。将成本推到未来被认为是一个好策略。这强烈鼓励承担技术债务。这方面的一个指标是，工程永远处于“紧缩模式”，而不是节俭地使用紧缩。有多少公司在其网站和公司价值观声明中宣传“家庭友好”,同时鼓励员工每周工作 60 小时，惩罚每周工作 40 小时然后回家与家人团聚的“懒鬼”?在这些环境中，不适当的技术债务几乎是不可避免的。

这并不是说管理总是错的。有适当的时间来积累债务。如果我的孩子需要紧急治疗，我不会仅仅因为这意味着负债而拒绝，即使偿还起来会很昂贵。同样，管理层对客户、员工和(是的)投资者负有责任，有时会强加一些令人不快的要求。睁大眼睛，以负责任的方式承担债务并不是一件坏事。加州大学伯克利分校的首席信息官打了一个赌，结果是错的，但这本来可能是一个赢的赌。他知道他正在努力，当屋顶坍塌时，他承担了问题的责任。困难在于，管理层不理解他们所承担的债务，或者太容易、太频繁地承担债务，却没有偿还计划。在过去的一份工作中，我认为我们需要更多的时间来建立一个系统，但当我们有很高的缺陷率时，却遭到了管理层的指责，这直接归因于违背我的更好的判断而强加的人为的短时间计划。在这种情况下，管理层不了解债务，忽视相反的警告，然后在问题出现时不承担责任。

### 从不同角度看债务成本

技术债务影响每个人，但方式不同。这是管理债务问题的一部分——即使你从自己的角度理解它，也有其他合法的方式来看待它。

**顾客。在这一事件中，顾客似乎是最终的坏人(和受害者)。毕竟，如果他们更有耐心，如果他们对产品的要求更低，给公司更多的时间在第一时间做好工作，这些都不会发生(或者可能不会发生)。的确，比起长期的可维护性、安全性和可靠性，客户有时会更关注功能(不幸的是，有时还会关注市场营销),然而他们却是最受伤的人。当移动网络中断时，当他们无法按时提交工作时，当他们的公司因为与软件斗争而失去业务时，他们会支付费用。归根结底，这一切都是为了做客户需要的事情，客户需要能够工作、他们能够理解、能够维护和扩展、能够得到支持并且(最终)他们喜欢使用的软件。如果不在整个过程的每一层管理技术债务，这就不可能发生，但是客户很少能控制如何管理债务。值得注意的是，购买定制解决方案的客户通常比购买“现成”软件的客户拥有更多的控制权，后者在很大程度上必须使用他们所得到的东西。同时，当你为特定的客户构建软件时，你可以协商“债务偿还”版本(可能不用这个术语)。**

帮助台。那些在服务台工作的人应该在天堂有一个特殊的位置——或者偶尔在地狱。客户很少打电话来说自己有多开心；他们通常有一个相当不同的议程。技术债务的几乎每个方面都困扰着服务台人员:设计糟糕的界面、糟糕的或不存在的文档、缓慢的算法等等。此外，那些看起来不会直接影响他们的事情(比如代码本身的晦涩难懂)会产生间接影响:解决问题的时间越长，客户就越不高兴。尽管帮助台是客户对内部流程的主要输入，但帮助台通常无法直接联系到能够解决问题的人员。

**操作。**在面向服务的环境中，操作人员(那些 24/7 携带呼机并必须保持一切正常工作的人)往往是前线的炮灰；他们可以花很多时间为别人没有咨询他们就做出的决定买单。有时他们会看代码，有时不会。在任何情况下，他们都可以查看文档——如果有的话。(最小的)好消息是，只要他们能提出一个可接受的变通办法，他们就可以把问题交给维护人员。DevOps 运动的兴起——运营人员需要在周期的早期与开发人员合作，以确保产品是可靠的、可维护的和可理解的——是一个积极的发展。这是减少长期技术债务的好方法，应该大力鼓励。

**工程师。工程师分为两种角色:编写代码的开发人员和必须修复、扩展或维护代码的人员(这些人可能是同一批工程师，但在许多地方他们不是)。乍一看，最初的开发人员似乎是技术债务的主要创造者，他们确实有很强的承担债务的动机，但是正如我们所看到的，它可以来自许多来源。在早期，技术债务几乎是看不见的，因为利息还没有到期。做一个快速的、高度功能化的初始实现让程序员看起来很好，代价是妨碍后来加入的工程师。在某些情况下，如果他们维护成熟代码的经验有限，这些程序员可能甚至没有意识到他们正在承担债务。出于这个原因，一个开发可维护代码的速度一般、稳定、有经验的程序员可能是一个更好的长期生产者，最终也是一个更高质量的工程师，而不是一个“超级程序员”，他可以一次跳过很高的原型，但从来没有维护过成熟的代码。**

**营销。**这些面对客户的人经常要承受客户不满的压力。他们通常是最努力缩短产品开发时间的人，因为他们受到销售和客户的压力，要尽快提供新的功能。然而，当新功能在现场不能正常工作时，他们也是错误的一方。此外，快速交付新功能的压力通常意味着后期功能将需要更长的时间来生产。伟大的营销人员明白这一点，但通常这不是一个适合营销世界模型的概念。

**管理。**有好的管理，也有不好的管理。优秀的管理人员懂得风险管理，能够平衡公司所有部门的需求。糟糕的管理往往有利于某个部门，而不利于其他部门。如果受青睐的部门是营销或销售，管理层将倾向于承担技术债务，而不了解成本。然而，管理也要付出代价。“没有所谓的负面宣传”这种说法是不正确的，尤其是当你的公司看起来快要倒闭的时候。管理层应该很容易接受管理金融债务的概念。管理技术债务也对他们有利。

### 摘要

技术债务可以被描述为所有节省资金或加快今天进展的捷径，冒着潜在的在未来(通常不清楚)花费资金或减缓进展的风险。这是不可避免的，只要管理得当，甚至可能是一件好事，但这可能很棘手:技术债务来自多种原因，通常具有难以预测的影响，并且通常涉及对未来会发生什么的赌博。管理技术债务的大部分与风险管理相同，可以应用类似的技术。如果技术债务得不到管理，那么随着时间的推移，它将会越积越多，直到危机发生。

技术债务可以从许多方面来看，并且可以由组织的所有级别引起。只有在各级的协助和理解下，才能妥善管理这一问题。尤其重要的是帮助非技术方理解债务管理不当可能带来的成本。

#### 参考

1.布鲁克斯，F. 1995。*神话人月*，周年纪念版。第十一章。艾迪森-韦斯利。

2.坎宁安，W. 1992。WyCash 投资组合管理系统。OOPSLA 经验报告；[http://c2.com/doc/oopsla92.html](http://c2.com/doc/oopsla92.html)。

3.福勒，M. 2009。技术债务象限；[http://martinfowler.com/bliki/TechnicalDebtQuadrant.html](http://martinfowler.com/bliki/TechnicalDebtQuadrant.html)。

4.弗里曼，S. 2010。糟糕的代码不是技术债务，而是未对冲的看涨期权。高阶逻辑；[http://www . higherorderlogic . com/2010/07/bad-code-not-technical-debt-it-an-un hedged-call-option/](http://www.higherorderlogic.com/2010/07/bad-code-isnt-technical-debt-its-an-unhedged-call-option/)。

5.格罗斯曼，S. 2011。Calmail 崩溃持续多日。《每日加利福尼亚人报》(12 月 1 日)；[http://www . daily cal . org/2011/12/01/calmail-crashes-last-multi-days/](http://www.dailycal.org/2011/12/01/calmail-crashes-last-multiple-days/)。

6.麦康奈尔，S. 2007。技术债。构建对话:软件最佳实践:[http://blogs . construx . com/blogs/Steve MCC/archive/2007/11/01/technical-debt-2 . aspx](http://blogs.construx.com/blogs/stevemcc/archive/2007/11/01/technical-debt-2.aspx)。

**爱它，恨它？让我们知道**

[【邮件保护】](/cdn-cgi/l/email-protection#c5a3a0a0a1a7a4a6ae85a4a6a8b4b0a0b0a0eba6aaa8)

ERIC ALLMAN 做过程序员、维护人员、帮助台幸存者、一线和执行管理人员、顾问、技术作家，有时甚至是客户。他理解所有这些角色的难度，有时甚至是愚蠢的。

2012 年 ACM 1542-7730/12/0300 10.00 美元

![acmqueue](img/4f57fce9b685ad00824bd02663d98c4d.png)

*原载于《队列》第 10 卷第 3 期*——
见本条目于 [ACM 数字图书馆](https://portal.acm.org/citation.cfm?id=2168798)

* * *

更多相关文章:

James P. Hughes，Whitfield Diffie - [**现实世界中物联网、TLS 和随机数生成器的挑战**](detail.cfm?id=3546933)
密码社区中的许多人对实现 RNGs 时所犯的错误嗤之以鼻。许多密码学家和 IETF 成员抵制让 TLS 对这类故障更有弹性的呼吁。本文讨论了 TLS 协议的历史、当前状态和脆弱性，并以一个如何改进该协议的例子作为结束。我们的目标不是提出一个解决方案，而是开始一场对话，通过证明 TLS 的安全性在没有完美随机数假设的情况下是可能的，从而使 TLS 更具弹性。

伯努瓦·鲍德里，蒂姆·多迪，马丁·蒙佩鲁斯-[T3】软件复活节彩蛋万岁！](detail.cfm?id=3534857)
这是一个动荡的时期。反叛的开发者，从持续部署的服务器发起冲击，赢得了他们的第一次胜利。在战斗中，叛军间谍成功地在 https://pro.sony 的 HTML 代码中推动了一次史诗般的提交。在阴险的代理人的追捕下，叛军藏在提交，按钮，工具提示，API，HTTP 头和配置屏幕中。

Alexandros Gazis，Eleftheria Katsiri - [**中间件 101**](detail.cfm?id=3526211)
无论是将一个复杂的软件组件分离成更小的服务，在计算机之间传输数据，还是创建一个无缝通信的通用网关，都可以依靠中间件来实现不同设备、应用程序和软件层之间的通信。随着敏捷运动的发展，技术行业已经采用了快速瀑布模型来为每个结构需求创建层堆栈，包括集成、通信、数据和安全性。考虑到这个范围，现在重点必须放在端点连接和敏捷开发上。这意味着中间件不应该仅仅作为执行简单的请求-响应命令的面向对象的解决方案。

阿尔瓦罗·维德拉-[T3】计算机程序中的含义和上下文](detail.cfm?id=3498852)
当你看一个函数程序的源代码时，你怎么知道它是什么意思？意义是在函数的返回值中找到的，还是位于函数体内部？函数名呢？回答这些问题对于理解如何使用源代码作为媒介在程序员之间共享领域知识是很重要的。该程序是程序员之间交流的媒介，以分享他们的解决方案。

* * *

* * *

[![](img/ad65ebb8b75e7581c1bc43a3736aed3c.png)](#) 
ACM 公司版权所有。