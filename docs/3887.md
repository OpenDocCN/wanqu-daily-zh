# 十大拉动式请求审核错误| Scott Nonnenberg

> 原文：<https://blog.scottnonnenberg.com/top-ten-pull-request-review-mistakes/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

我参与了很多由 GitHub 主持的项目，无论是 T2 的个人项目、T4 的开源项目还是合同项目。有时使用公共 GitHub，而其他时候 [GitHub Enterprise](https://enterprise.github.com/) 。但是有一点是相同的:提交一个拉请求很容易，但是很难很好地审查一个拉请求。

事不宜迟，**十大拉动请求复习错误**以及一些如何做得更好的想法！

## [](#1-the-mindless-1)1。无脑+1

太诱人了。拉取请求真的很大，提交者是你信任的人。他们已经在代码的这一部分工作了一段时间，并且一直工作得很好。更不用说你还有自己的最后期限要赶！

```
+1
LGTM
Ship it! 
```

振作起来！

你需要花真正的时间来回顾这些代码。每个人都会犯错——资历并不是防止犯错的魔法。作为评审者，你的角色是利用你的创造力和专业知识来减少这个拉取请求以任何方式使代码库变得更糟的机会。

这才是真正的目标，不是吗？如果每个拉取请求都使代码库变得更好，也许这个项目真的有一些长期的潜力！

## [](#2-procrastination)2。拖延

为什么现在复习？毕竟，这确实是一个很大的拉请求。而且你目前的任务太重要了。你最终会找到时间的，对吗？或者，也许你会等着别人插话…

搜索你的感觉！让原力流过你的身体！在这种抵制背后，你可能会有一些非常真实的抱怨。

现在你已经确定了你真正关心的问题，采取行动吧！

*   如果提交者没有给出足够的关于所有这些变化的指导，那就去要求吧！比如原来的要求在哪里？
*   如果变化太大而不能马上回顾，要求把它们分开！
*   有不懂的地方，突破自己的骄傲，去问！
*   如果你发现了一大堆问题/顾虑，可能是时候和提交者进行一些面对面的交流了。

## [](#3-unified-diffs)3。统一差异

你在复习胡言乱语吗？Github 和 GitHub Enterprise 的默认差异视图是“统一的”在这种模式下，为了呈现对文件的一组更改，软件会查看添加和删除的行，并尝试智能地对更改块进行分组，所有这些都是内联的。但是你知道吗？在大多数情况下，“统一的”差异很难理解。智能区块选择真的不是。

好消息是 GitHub 和 GitHub Enterprise 都支持“分割”差异。左边是旧文件，右边是新文件。如果代码被删除，您将在右边看到空的部分，如果代码被添加，您将在左边看到空的部分。无论哪种方式，您都可以清楚地看到文件之前和之后的样子，从而做出更好的审查决定。

不要满足于胡言乱语。点击 diff 右上角的“Split”。

## [](#4-style-over-substance)4。风格重于实质

在“拉”请求审查期间，应该花很少的时间(如果有的话)来讨论代码样式和格式。我以前写过[需要使用 ESLint 这样的工具来使这类事情完全自动化](/eslint-part-3-analysis/#trying-to-adapt)。为什么？因为这是浪费时间！

一个好的代码审查者会花时间通过回到最初的需求来试图理解代码变更的最终目标。是否有工作项对此进行跟踪？规格？它到底想要什么？

只有在这样的背景下，真正的复习才能发生。当最终目标被理解时，在表面的结构/风格评审中看起来合理的东西可能变得不可接受。

是的，你可能会羞于提出这样的“大”事情，因为已经在现有的改变上花费了太多的时间，但是值得谈论更好的解决方案。这是每个人学习的机会。你甚至可能错误地认为有更好的解决方案，但这需要与最初的提交者讨论才能弄清楚。

## [](#5-not-catching-incomplete-changes)5。没有捕捉到不完整的更改

差异非常有助于向你展示发生了什么变化。但事情就是这样！根据定义，它们不会向你展示*没有*改变的内容。留意那些本应被更广泛应用的变化，比如可能没有覆盖整个代码库的查找/替换。

或者只影响到它应该有的组件子集的更改。

或者完全错过测试。测试是任何变更的重要组成部分，但是如果它们根本不存在差异，那么实际上很容易忘记它们。不会提示你去想它们。

我承认，这真的很难！这是最难的一种复习。在提交者的分支或您自己的机器上的任何地方进行一些快速的健全性检查搜索可能会有所帮助。或者，您可以询问提交者，除了您可以看到的代码更改之外，他们还做了哪些全面的检查。

## [](#6-glossing-over-test-code)6。掩盖测试代码

一旦 pull 请求中有一些测试代码更新，就很容易产生一种虚假的安全感。如果他们放一些测试进去，一定是高质量的，全面的。对吗？

不对！

测试是一门艺术。它需要大量的上下文来适当地平衡风险缓解和测试成本，适合于团队的代码和文化领域。拉式请求评审是团队构建共享环境的好地方。

一些需要考虑的问题:

*   测试题目有足够的描述性吗？
*   是否捕获了关键场景？
*   为了舒适，是否覆盖了足够的边缘外壳？
*   应用程序的哪些部分由单个测试来测试？太多了？太少了？
*   测试是用好的断言编写的吗？他们会失败吗？他们会经常失败吗？
*   如果一个测试失败了，追踪错误会很容易吗？
*   如果添加了新的前端行为，它是否被添加到了[手动测试脚本](/web-application-test-strategy/#stage-0-real-usage)中？[浏览器自动化测试](/web-application-test-strategy/#stage-4-automating-a-browser)？

## [](#7-discounting-frontend-complexity)7。忽略前端复杂性

如果 CSS 和 HTML 中有变化，倾向于把它当作算法代码的变化。您会看到格式良好的更改，并想象它们在浏览器中会怎样。“似乎有道理，”你说。

但事情没这么简单。用户最终看到的东西来自于你的应用和各种渲染引擎之间复杂的交互。

别胡思乱想了，把树枝拉下来。在多种浏览器和屏幕尺寸下尝试，因为这东西真的很棘手。即使你是一个专业的前端开发人员，也不要相信自己会关注这些东西。这就是为什么 [CodePen](https://codepen.io/) 和[like](https://www.sitepoint.com/7-code-playgrounds/)存在的原因！

## [](#8-the-narrow-mindset)8。狭隘的心态

这是 diff 中格式良好的代码可以让您昏昏欲睡的另一个领域。但重要的是要考虑大规模。现在项目中有了这些新代码，会有什么变化呢？会发生什么？

让您开始的一些问题:

*   这对用户的下载量有影响吗？对性能的感知？它对用户体验的改变是否足以让它出现在发行说明或发给用户的电子邮件中？
*   它引入了一种新的代码或特性吗？它是否需要新的测试方法、新的日志或监控技术，或者部署过程的改变？你的主机或带宽成本会上升吗？
*   今天能被用户行使吗，还是在一面旗帜后面？有什么系统来验证旗帜背后的东西？
*   这个综合测试有多难？在试运行或生产中会有什么不同？
*   会很容易改变吗？还是回滚？

## [](#9-short-term-thinking)9。短期思维

在一些拉取请求中，有相当多的来回，可能是由于分歧或只是需要澄清。最终，与拉请求直接相关的一组人就前进的方向达成了一致——您已经构建了共享上下文！

但是，当下一个开发人员下周、下个月或明年来到这里，遇到这些代码时，会发生什么呢？他们不会轻易参与这次讨论。

构建未来无障碍环境的一些想法:

*   在代码注释中捕获键拉请求讨论。
*   修改评审人员难以理解的代码——将来其他人也会很难理解！
*   在项目中创建一个位置，用于存放涵盖更多复杂的、广泛适用的主题的完整概念文档。
*   确保代码中的所有`TODO`都与您的工作项数据库中的一个项配对，并提供足够的细节，使其可以被除原始报告者之外的其他人操作。

## [](#10-cursory-review-of-amendments)10。粗略审查修正案

终于！拉请求引起了一些热烈的关注，现在又回到了提交者的法庭上。您已经提供了反馈，提交者正在做出一些回应。

现在不是忘记拉请求的时候。您已经与提交者讨论了所需的更改，但这并不意味着这些更改将是正确的！或者根本没有制造！

拉式请求修改是开发人员所做的风险最高的变更，因为每个人都想继续前进。在开发中给予的关注越少，在审查中给予的关注越少。

请特别仔细地查看对原始拉取请求的任何更新，尽管，是的，您已经全面地查看了拉取请求。如果新的变更被分离到它们自己的提交中，这就更容易了。如果整个拉取请求最近被[重定基础/压缩](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History)，那么这可能有点令人沮丧。

## [](#its-not-easy)真不容易！

设计和实现软件是一项艰苦的工作。为什么复习它会更容易呢？事实上，回顾可能更难，因为你有更少的时间来建立正确的背景来提供合理的反馈。

但我们不能放弃——这极其重要！

用这篇文章作为一个开始的清单，或一个灵感。随着时间的推移，您和您的团队可以为重要但容易忘记的事项建立一个自定义提醒列表。最终，你的拉请求过程将成为一个强大的[反馈回路](/the-why-of-agile/#feedback-loops)，用于改进你的团队文化和代码质量。