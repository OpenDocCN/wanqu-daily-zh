# 铬的工作原理| Aaron Boodman | Medium

> 原文：<https://medium.com/@aboodman/in-march-2011-i-drafted-an-article-explaining-how-the-team-responsible-for-google-chrome-ships-c479ba623a1b?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

# 铬的工作原理

今天，我想告诉你铬是如何工作的。不是浏览器 [Chrome](http://www.google.com/chrome/) ，而是构建浏览器的[Chrome](http://www.chromium.org/Home)那群人。

数百名工程师致力于铬项目。我们每周一起对代码库进行大约 800 次修改。我们还依赖许多其他大型活跃项目，如 [V8](http://code.google.com/p/v8) 、 [Skia](http://code.google.com/p/skia) 和 [WebKit](http://www.webkit.org/) 。

我们按照固定的时间表，每六周向数亿用户推出一个新的稳定版本。我们还维护着其他几个更新更快的[早期访问频道](http://dev.chromium.org/getting-involved/dev-channel)。最快的是金丝雀频道，几乎每个工作日都会自动更新。

所有这些是如何保持工作的？这辆巴士上怎么还有轮子？为什么所有的开发商还没有疯掉？

在技术方面，Chromium 的速度得益于[可靠、高效和无声的自动更新](https://plus.google.com/105636695715347097518/posts/G9hbCEMC2wF)。

在人员方面，有专门的、努力工作的、聪明的 QA、发布经理和基础设施类型的团队，没有他们，整个事情将在几周内分崩离析。设计师、产品经理、作家、公关、律师、安全团队以及其他所有需要为每个稳定版本顺利合作的人。我今天将会掩饰所有这些，以便专注于工程方面的事情，并试图阻止这篇文章增长到 Yegge 的比例。

相反，我要谈的是 Chromium 的开发过程，它是专门为快速发布而设计的。它有一些有趣的特性，我认为可以改进许多项目，不管发布时间表。它也带来了一些挑战，我将在最后指出。

# 没有分支

在许多项目中，将源代码分支来处理主要的新特性是很常见的。这个想法是，新代码带来的暂时不稳定不会影响其他开发人员或用户。一旦特性完成，它的分支就被合并回主干，在集成问题被解决时，通常会有一段不稳定的时期。

这在 Chrome 中是行不通的，因为我们每天都在发布。我们不能容忍大量的新代码突然出现在主干中，因为它很有可能长时间关闭金丝雀或开发通道。此外，Chrome 的主干移动如此之快，以至于开发人员长时间孤立在一个分支上是不现实的。当它们合并时，trunk 看起来会有很大的不同，以至于集成会很困难并且容易出错。

我们确实在每个测试版发布之前创建了维护分支，但是这些都是非常短暂的。最多六周，直到下一个测试版发布。而且我们从来不直接在这些分支上开发。任何需要发布的后期修复首先在主干上进行，然后被精选到分支中。

这样做的一个令人高兴的副作用是，没有开发人员的 B 团队困在维护分支上工作。所有的开发人员总是使用最新最棒的资源。

# 运行时开关

我们不创建分支，但是我们仍然需要一些方法来对用户隐藏不完整的特性。一种自然的方法是编译时检查。这些方法的问题是它们与仅仅分支代码没有太大的不同。实际上，您仍然有两个独立的代码库，它们最终必须合并。由于默认情况下新代码没有经过编译或测试，开发人员很容易意外破坏它。

Chromium 项目使用运行时检查。开发中的每个特性从一开始就在所有配置下进行编译和测试。我们有[命令行标志](http://git.chromium.org/gitweb/?p=chromium/chromium.git;a=blob;f=chrome/common/chrome_switches.cc;hb=HEAD),我们在启动时很早就测试过。在其他地方，代码库大多不知道启用了哪些特性。这个策略意味着从一开始就尽可能地集成新的特性工作。它至少是编译过的，任何需要对核心代码进行的更改都经过测试，并照常向用户公开。我们可以通过暂时[覆盖命令行](http://git.chromium.org/gitweb/?p=chromium/chromium.git;a=blob;f=chrome/test/base/scoped_command_line_override.h;hb=HEAD)来轻松编写测试禁用特性的自动化测试。

当一个功能接近完成时，我们在 [chrome://flags](http://lifehacker.com/5667846/chromes-aboutlabs-renamed-to-aboutflags-adds-a-warning) 中引入一个选项，以便高级用户可以开始尝试并给我们反馈。最后，当我们认为该特性已经准备好发布时，我们删除命令行标志并默认启用它。到这个时候，代码已经被广泛地自动化测试，并被许多人使用。因此打开它的影响被最小化。

# 大量的自动化测试

为了每天发布，我们需要对我们的代码库始终处于良好状态有信心。这需要自动化测试。大量的自动化测试。在撰写本文时，Chrome 有大约 12k 个类级单元测试、2k 个自动化集成测试，以及一大堆性能测试、膨胀测试、线程安全测试、内存安全测试，可能还有更多我想不到的测试。而这还只是针对 Chrome 的。WebKit、V8 和我们的其他依赖项都是独立测试的。仅 WebKit 就有大约 27k 次测试，确保网页布局和功能正确。我们的一般规则是，每一个变化都必须伴随着测试。

我们运行一个公共的 [buildbot](http://build.chromium.org/) ,它根据我们的测试套件在每个配置上不断地运行新的代码变更，并且我们执行一个“绿树”策略。如果一个变更破坏了一个测试，它会被立即恢复。开发人员必须修复更改并重新着陆。我们不会在树中留下不完整的更改，因为:

1.  这很容易意外地出现更多的不完整的变化，因为没有人注意到树从*变红*到*甚至更红*
2.  它减慢了开发速度，因为每个人都必须解决出现的问题
3.  它鼓励开发人员草率地快速修复以通过测试
4.  它阻止我们释放！

为了帮助开发人员避免破坏这棵树，我们已经[尝试了机器人](http://www.chromium.org/developers/testing/try-server-usage)，这是一种在落地之前在所有测试和配置下测试变化的方法。结果通过电子邮件发送给开发人员。我们还有一个[提交队列](http://www.chromium.org/developers/testing/commit-queue)，这是一种尝试更改的方法，如果尝试成功，它会自动着陆。我喜欢在长时间的黑客攻击后使用这个。我按下按钮，上床睡觉，醒来——希望我的零钱已经到了。

有了所有这些自动化测试，我们可以让我们的开发通道进行最少的手工测试，而金丝雀却一点也没有。

# 无情的重构

因为我们有相当全面的测试覆盖，我们可以大胆地进行重构。Chrome 中总有一些重大的重构工作在进行。目前主要的有[卡尼塔斯](http://code.google.com/p/chromium/issues/list?can=1&q=label%3Acarnitas)和[光环](http://code.google.com/p/chromium/issues/detail?id=84070)。

以我们的规模和速度，保持代码库的整洁和易懂是至关重要的。我们甚至认为这比防止衰退更重要。Chrome 的工程师有权在系统的任何地方进行改进(尽管我们可能需要模块所有者的审查)。如果重构破坏了测试失败时没有暴露出来的东西，我们的观点是，这不是进行重构的工程师的错，而是这个工程师的功能没有足够的测试覆盖率。

# DEPS

WebKit 移动速度也很快。就像我们不能有突然登陆的特性分支一样，我们也不能试图一次合并一个月的 WebKit 变化。它会让树不稳定好几天。

相反，我们试图让 Chrome 编译最新版本的 WebKit。该版本几乎总是不到半天。Chrome 的根目录下有一个[文件，包含我们当前编译的 WebKit 版本。当你签出或更新 Chrome 源代码时，一个名为](http://src.chromium.org/viewvc/chrome/trunk/src/DEPS?view=markup) [gclient](http://www.chromium.org/developers/how-tos/depottools) 的工具会自动获取该文件中指示的 WebKit 版本。

一名工程师每天都会更新这个版本号几次，调查出现的任何新的集成问题，并将错误分配给相关的工程师。结果是，我们只能一次对 WebKit 进行小的修改，对我们的树的影响通常是最小的。我们还在 WebKit 的 buildbot 中添加了机器人，这样当 WebKit 工程师做出最终会破坏 Chrome 的更改时，他们会立即发现。

DEPS 系统的一个很大的好处是，我们可以很快地将变化发布到网络平台上。WebKit 中的一个功能将在几天内通过金丝雀频道提供给 Chrome 用户。这激励我们在 WebKit 的上游做出改进，在那里他们将帮助所有的 WebKit 客户端，而不是在本地他们只帮助 Chrome。事实上，我们的一般规则是，我们根本不对 WebKit(或我们所依赖的其他项目)进行任何本地更改。

# 挑战

彻底测试仍然是一个未解决的问题。特别是，易变的集成测试对我们来说是一个持续的问题。Chrome 庞大、复杂、异步、多进程和多线程。集成测试很容易出现微妙的时间问题，使它们间歇性地失败。在我们这样规模的项目中，1%的测试失败肯定会在一天中失败多次。

一旦一个测试变得古怪，团队很快就养成了忽略它的习惯，这使得它很容易错过该代码区域中其他合法的测试失败。因此，我们最终禁用了古怪的测试并丢失了覆盖率，使得向用户发布主要的回归变得更加容易。

另一个挑战是在这种速度下很难保持高抛光度。我认为让一个团队专注于为罕见的《生活大爆炸》式的发布做好每一个细节比试图无限期地保持这种专注更容易。因为经常很难测试像工具栏中按钮间距这样的小细节，所以很容易出现错误。

最后，我认为压力是一个非常现实的问题。由于所有的代码一直在变化，即使人们试图只关注他们的领域，他们也很容易受到其他地方发生的事情的影响。如果你想让你的 Chrome 继续工作，很容易让人觉得你永远不能休息。

我们正在通过对代码库进行一些主要的模块化来解决最后一个问题。Carnitas 任务组正试图在我们的一些主要组件之间绘制更清晰、更紧密的接口。到目前为止，它清理了大量代码，但现在说它对更大的图片压力水平有多大帮助还为时过早。

# 结论

那么，轮子怎么还在车上？简而言之:没有分支，运行时切换，大量的自动化测试，无情的重构，并且非常接近我们的依赖项。

这些技术对于具有快速移动的上游依赖关系的大型项目来说是最有帮助的，但是也许一些想法也适用于较小的项目。