# 我在构建大型支付系统时学到的分布式架构概念——务实的工程师

> 原文:[https://blog . pragmatic engineer . com/distributed-architecture-concepts-I-have-learn-while-building-payments-systems/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://blog.pragmaticengineer.com/distributed-architecture-concepts-i-have-learned-while-building-payments-systems/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)



当构建一个大规模、高度可用的分布式系统时，在实践中需要使用什么架构概念？在这篇文章中，我总结了一些我认为在构建优步支付系统时必须学习和应用的方法。这是一个负载高达每秒数千个请求的系统，其中关键的支付功能需要正确工作，即使系统的某些部分出现故障。

背景:两年前，我作为一名移动软件工程师加入优步，有一些后台经验。我最终在应用程序中构建了支付功能，并在这个过程中[重写了应用程序](https://eng.uber.com/new-rider-app/)。后来，我在[进入工程管理](https://blog.pragmaticengineer.com/things-ive-learned-transitioning-from-engineer-to-engineering-manager/)，领导团队。这意味着接触更多的后端，因为我的团队负责许多支持支付的后端系统。

在优步工作之前，我几乎没有分布式系统的经验。我的背景是传统的计算机科学学位和十年的全栈软件开发。然而，虽然我能够画出方框并谈论权衡，但我对一致性、可用性或幂等性等分布式概念没有太多的理解或评价。

我要检查的这份清单完整吗？大概不会。但如果我早点认识它们，这些东西会让我的生活更轻松。因此，让我们深入了解 SLA、一致性、数据持久性、消息持久性、幂等性以及其他一些我需要在工作中学习的东西。

[更新]请阅读本文的后续文章:[以可靠的方式运行大型分布式系统](https://blog.pragmaticengineer.com/operating-a-high-scale-distributed-system/)我还推荐《T2 设计数据密集型应用这本书作为更多阅读材料。

## 服务等级协议

对于每天处理数百万个事件的大型系统来说，有些事情肯定会出错。在开始规划一个系统之前，我发现最重要的事情是决定一个“健康”的系统意味着什么。“健康”应该是可以测量的。衡量“健康”的常用方法是使用[SLA](https://en.wikipedia.org/wiki/Service-level_agreement):服务水平协议。我见过的一些最常见的 SLA 有:

*   **可用性**:服务运行时间的百分比。虽然拥有 100%可用性的系统很诱人，但实现这一点可能非常困难，而且成本高昂。即使是像 VISA card network、Gmail 或互联网提供商这样的大型关键系统也没有 100%的可用性——随着时间的推移，它们会停机数秒、数分钟或数小时。对于许多系统来说，四个九的可用性(99.99%，或者每年大约 [50 分钟的停机时间](https://uptime.is/))被认为是高可用性。通常要达到这个水平是相当困难的。
*   **准确性**:系统中的一些数据不准确或者丢失可以吗？如果有，百分之几是可以接受的？对于我工作过的支付系统，准确性需要达到 100%，这意味着不允许丢失任何数据。
*   **容量**:系统应该能够支持什么样的预期负载？这通常用每秒请求数来表示。
*   **延迟**:系统应该在什么时间响应？95%的请求和 99%的请求应该在什么时候得到服务？系统通常有很多嘈杂的请求，因此 [p95 和 p99 延迟](https://www.quora.com/What-is-p99-latency)在现实世界中更实际。

***为什么 SLA 在构建大型支付系统时至关重要？我们组装了一个新系统，取代了现有的系统。为了确保我们构建正确的东西，一个比它的前身“更好”的系统，我们使用 SLA 来定义期望。可用性是我们的首要要求之一。一旦定义了目标，我们就需要考虑架构中的权衡，以便能够满足这个目标。***

## 水平与垂直缩放

假设使用新构建系统的业务增长，负载只会增加。在某些情况下，现有设置将无法支持更多负载，需要增加更多容量。两种最常见的扩展策略是垂直或水平扩展。

水平扩展是指向系统中添加更多的机器(或节点)，以增加容量。水平扩展是扩展分布式系统最流行的方式，尤其是因为向集群添加(虚拟)机器通常只需点击一个按钮。

纵向扩展基本上就是“购买更大/更强的机器”——要么是拥有更多内核、更多处理能力和更多内存的(虚拟)机器。对于分布式系统，垂直扩展通常不太受欢迎，因为它可能比水平扩展成本更高。然而，一些主要的网站，如 Stack Overflow 已经成功地纵向扩展以满足需求。

***为什么在构建大型支付系统时，扩展策略至关重要？*** 我们很早就决定要建立一个横向扩展的系统。虽然垂直扩展在某些情况下是可能的，但我们的支付系统已经达到了预期的负载，我们对一台超级昂贵的大型机能否在今天处理它感到悲观，更不用说在未来了。我们的团队中也有在大型支付提供商工作过的工程师，他们试图在当时金钱可以购买的最大机器上进行垂直扩展，但失败了。

## 一致性

任何系统的可用性都很重要。分布式系统通常建立在可用性较低的机器之上。假设我们的目标是构建一个可用性为 99.999%的系统(大约每年停机 5 分钟)。我们使用平均可用性为 99.9%的机器/节点(每年停机约 8 小时)。获得可用性数字的一个简单方法是将一堆这样的机器/节点添加到集群中。即使一些节点出现故障，其他节点也会出现故障，系统的整体可用性会高于单个组件的可用性。

在高可用性系统中，一致性是一个关键问题。如果所有节点同时看到并返回相同的数据，则系统是一致的。回到之前的模型，我们添加了一堆节点来实现更高的可用性，确保系统保持一致并不是一件小事。为了确保每个节点都有相同的信息，它们需要互相发送消息，以保持同步。然而，相互发送的消息可能无法传递，它们可能会丢失，并且一些节点可能不可用。

一致性是我花了最多时间理解和欣赏的一个概念。有几个一致性模型，在分布式系统中最常用的是[强一致性、弱一致性](https://www.cl.cam.ac.uk/teaching/0910/ConcDistS/11a-cons-tx.pdf)和[最终一致性](http://sergeiturukin.com/2017/06/29/eventual-consistency.html)。Hackernoon 关于[最终一致性与强一致性](https://hackernoon.com/eventual-vs-strong-consistency-in-distributed-databases-282fdad37cf7)的文章很好地概括了这些模型之间的权衡。通常，所需的一致性越弱，系统的速度就越快，但越有可能返回的不是最新的数据集。

在构建大型支付系统时，一致性为何如此重要？ 系统中的数据需要保持一致。但是有多一致呢？对于系统的某些部分，只有非常一致的数据才可以。例如，知道是否已经开始付款是需要以一种非常一致的方式存储的事情。对于其他任务不太关键的部分，最终的一致性被认为是一个合理的权衡。一个很好的例子是列出最近的事务:这些事务可以最终一致地实现(也就是说，最近的事务可能只在一段时间后出现在系统的一部分中——作为回报，操作将以更低的延迟或更少的资源密集度返回)。

## 数据持久性

[持久性](https://en.wikipedia.org/wiki/Durability_(database_systems))意味着一旦数据成功添加到数据存储中，它就可以继续使用。即使系统中的节点离线、崩溃或数据损坏，情况也是如此。

不同的分布式数据库具有不同的持久性级别。有些支持机器/节点级别的持久性，有些在集群级别支持，有些则不提供开箱即用。通常使用某种形式的复制来提高持久性——如果数据存储在多个节点上，如果一个或多个节点出现故障，数据仍然可用。[这里有一篇很好的文章](https://web.archive.org/web/20180422030240/https://drivescale.com/2017/03/whatever-happened-durability/),讲述了为什么在分布式系统中实现持久性具有挑战性。

![](../Images/6d5327a5abcd9d37c4b883802e82f439.png)

***为什么在构建支付系统时，数据持久性很重要？*** 对于系统的许多部分来说，没有数据会丢失，因为这是很重要的事情，比如支付。我们构建的分布式数据存储需要支持集群级别的数据持久性——因此，即使实例崩溃，完成的事务也将持续存在。如今，大多数分布式数据存储服务，如 Cassandra、MongoDB、HDFS 或 Dynamodb 都支持不同级别的持久性，并且都可以配置为提供集群级别的持久性。

## 消息持久性和持久性

分布式系统中的节点执行计算、存储数据并相互发送消息。发送消息的一个关键特征是这些消息到达的可靠性。对于任务关键型系统，通常需要零消息丢失。

对于分布式系统，消息传递通常由一些分布式消息服务完成，如 RabbitMQ、Kafka 或其他。这些消息服务可以支持(或被配置为支持)不同级别的消息传递可靠性。

消息持久性意味着当处理消息的节点发生故障时，在故障解决后，消息仍将在那里进行处理。消息持久性通常在[消息队列](https://en.wikipedia.org/wiki/Message_queue)级别使用。对于持久消息队列，如果队列(或节点)在消息发送时脱机，当它重新联机时仍将获得消息。一篇关于这个话题的好文章是[这一篇](https://developers.redhat.com/blog/2016/08/10/persistence-vs-durability-in-messaging/)。

![](../Images/37f748426b877712d7a048dea145cb02.png)

***为什么在构建大型支付系统时，消息持久性和持久性很重要？*** 我们有不能丢失的消息，比如有人已经开始为他们的旅程付费的消息。这意味着我们使用的消息传递系统需要是无损的:每条消息都需要传递一次。然而，构建一个将每条消息准确地传递一次*或至少传递一次*的系统是不同的复杂性。我们决定实现一个至少有一次交付的持久消息传递系统，并选择了一个消息传递总线，在此基础上我们将构建这个系统(我们最终选择了 Kafka，为这个案例设置了一个无损集群)。**

## 幂等性

对于分布式系统，事情可能会出错，比如连接可能会中途中断，或者请求可能会超时。客户端通常会重试这些请求。幂等系统确保无论一个特定的请求被执行多少次，这个请求的实际执行只发生一次。一个很好的例子是付款。如果客户端请求支付，请求成功，但是客户端超时，客户端可以重试相同的请求。有了幂等系统，付钱的人不会被收两次钱。在非幂等系统中，他们可以。

设计幂等的分布式系统需要某种分布式锁定策略。这就是早期分布式系统概念发挥作用的地方。假设我们打算通过使用乐观锁来实现幂等性，以避免并发更新。为了拥有乐观锁定，系统需要具有很强的一致性——以便在操作时，我们可以使用某种版本控制来检查是否已经启动了另一个操作。

根据系统的约束和操作的类型，有许多方法可以实现等幂。设计幂等方法是一个很好的挑战- [Ben Nadel 写了他使用过的不同策略](https://www.bennadel.com/blog/3390-considering-strategies-for-idempotency-without-distributed-locking-with-ben-darfler.htm)，包括分布式锁和数据库约束。在设计分布式系统时，幂等性可能是容易被忽略的部分之一。我遇到过这样的场景，我的团队因为不能确保一些关键操作的正确幂等性而焦头烂额。

为什么在构建大型支付系统时幂等性很重要？ 最重要的是:避免双重收费或双重退款。假设我们的消息传递系统至少有一次无损传递，我们需要假设所有消息可能被多次传递，并且系统需要确保幂等性。我们选择用版本控制和乐观锁定来处理这个问题，让实现幂等行为的系统使用强一致性存储作为它们的数据源。

## 分片和法定人数

分布式系统通常需要存储比单个节点所能存储的更多的数据。那么，如何在一定数量的机器上存储大量数据呢？最常见的技术是使用[分片](https://en.wikipedia.org/wiki/Shard_(database_architecture))。使用某种散列对数据进行水平分区，以分配给一个分区。虽然许多分布式数据库在幕后实现了分片，但是分片是一个值得深入了解的有趣领域，尤其是围绕[再分片](https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6)。Foursquare 在 2010 年因为遇到了一个 sharding edge 案例而停机了 17 个小时，在那里分享了一个关于根本原因的[漂亮的事后分析](http://highscalability.com/blog/2010/10/15/troubles-with-sharding-what-can-we-learn-from-the-foursquare.html)。

许多分布式系统在多个节点上复制数据或计算。为了确保以一致的方式执行操作，定义了基于投票的方法，其中为了操作成功，一定数量的节点需要得到相同的结果。这就是所谓的法定人数。

***在优步建立支付系统时，法定人数和分片为何如此重要？*** 这两个都是非常常用的基本概念。我个人在研究我们如何设置 Cassandra 复制时遇到了这个概念。Cassandra(和其他分布式系统)[使用 quorum](https://docs.datastax.com/en/archived/cassandra/3.x/cassandra/dml/dmlConfigConsistency.html#dmlConfigConsistency__about-the-quorum-level) 和本地 quorum 来确保集群间的一致性。一个有趣的副作用是，在我们的一些会议上，当足够多的人在房间里时，有人会问:“我们可以开始了吗？我们有法定人数吗？”

## 演员模型

描述编程实践的常用词汇——如变量、接口、调用方法——都假设是单机系统。当谈到分布式系统时，我们需要使用一套不同的方法。描述这些系统的一种常见方式是遵循 [actor 模型](https://en.wikipedia.org/wiki/Actor_model)，其中我们从通信的角度来考虑代码。这个模型很受欢迎，因为它符合我们会想到的心理模型，例如，当描述人们如何在组织中交流时。另一种描述分布式系统的流行方式是[CSP——通信顺序进程](https://en.wikipedia.org/wiki/Communicating_sequential_processes)。

参与者模型基于参与者相互发送消息并对其做出反应。每个参与者可以做一组有限的事情——创建其他参与者、向其他人发送消息或决定如何处理下一条消息。通过一些简单的规则，可以很好地描述复杂的分布式系统，在参与者崩溃后，这些系统还可以自我修复。简单介绍一下，我推荐由 [Brian Storti](https://twitter.com/brianstorti) 撰写的文章[10 分钟内的演员模型](https://www.brianstorti.com/the-actor-model/)。许多语言都实现了[角色库或框架](https://en.wikipedia.org/wiki/Actor_model#Actor_libraries_and_frameworks)。例如，在优步，我们使用 [Akka 工具包](https://doc.akka.io/docs/akka/2.4/intro/what-is-akka.html)用于我们的一些系统。

为什么参与者模型在构建大型支付系统时很重要？ 我们和许多工程师一起建造一个系统，他们中的许多人都有分布式经验。我们决定遵循一个标准的分布式模型，而不是自己想出分布式概念，这有可能重新发明轮子。

## 反应式建筑

当构建大型分布式系统时，目标通常是使它们具有弹性、伸缩性和可伸缩性。这可能是一个支付系统或另一个高负载系统，这样做的模式可能是相似的。业内人士已经发现并分享了在这些情况下运行良好的最佳实践——反应式架构是这个领域中流行且广泛使用的模式。

要开始接触反应式架构，我建议阅读[反应式宣言](https://www.reactivemanifesto.org/)和观看[这个关于这个主题的 12 分钟视频](https://www.lightbend.com/blog/understand-reactive-architecture-design-and-programming-in-less-than-12-minutes)。

***为什么在构建大型支付系统时，反应式架构至关重要？*** [Akka](https://akka.io/) ，我们用来构建大部分新支付系统的工具包深受反应式架构的影响。我们许多构建这个系统的工程师也熟悉反应式的最佳实践。遵循反应性原则——建立一个反应灵敏、有弹性、有弹性和消息驱动的系统，就变得非常自然了。我发现有一个模型可以依靠并检查进展是否在正确的轨道上是很有帮助的，并且我将在构建未来的系统时使用这个模型。

## 关闭

我非常幸运地参与了一个大规模、分布式、关键任务系统的重建:为优步的支付提供动力的系统。通过在这种环境中工作，我学到了许多以前不必使用的分布式概念。我总结了这些内容，希望其他人会发现这对开始或继续学习分布式系统有所帮助。

这篇文章严格地集中在这些系统的规划和架构上。关于构建、部署和在高负载系统之间迁移以及可靠地运行它们，有很多事情要说。但是所有这些都是另一篇文章的主题:[以一种可靠的方式运行一个大型的分布式系统](https://blog.pragmaticengineer.com/operating-a-high-scale-distributed-system/)。

对于那些对学习分布式系统感兴趣的人来说，我推荐《设计数据密集型应用程序:可靠、可伸缩和可维护系统背后的伟大理念》这本书。这是我迄今为止找到的最实用的书。它涵盖了不同的分布式概念——包括我已经经历过的概念和更多的概念——以及真实世界的例子。[亚马逊构建者图书馆](https://aws.amazon.com/builders-library/?cards-body.sort-by=item.additionalFields.customSort&cards-body.sort-order=asc)也有一些关于分布式系统的更具体、更深入的主题。

注:阅读本帖的[俄文翻译](https://habr.com/en/post/353734/)，以及[日文翻译](https://postd.cc/distributed-architecture-concepts-i-have-learned-while-building-payments-systems/)。

* * *

### 特色务实的工程师工作

1.  Renterra 的创始工程师。**$ 14-18 万** +股本。远程(全局)。
2.  Akamai Technologies 的高级首席软件工程师 Kubernetes 。远程(美国)。
3.  DevZero 的软件工程师。 **$150-175K** 。华盛顿西雅图。
4.  Founda Health 的高级后端开发人员。荷兰阿姆斯特丹。
5.  Vital 的高级后端工程师。**$ 7-14 万** +股本。远程。
6.  Pento 的主要后端工程。 **120-135K** 。远程。
7.  [在 Playht 创办高级 Fullstack 工程师(JavaScript)](https://pragmatic-engineer.pallet.com/jobs/290b9214-cfa0-4df6-84d6-b6a4cfd38075) 。**$ 15-20 万** +股本。旧金山或偏远地区。
8.  Qualified.com 的软件工程师。旧金山或偏远地区。
9.  Ometria 的基础设施团队负责人。 **90-150K** 。英国或葡萄牙。
10.  [BetterUp 的全栈工程师、视频&消息](https://pragmatic-engineer.pallet.com/jobs/09f54a5f-e330-4855-87d3-07b6a9e0bfa8)。远程(美国)。
11.  BetterUp 的全栈工程师。远程(美国)。

*上述工作在[实用工程师考试](https://blog.pragmaticengineer.com/pragmatic-engineer-test/)中得分至少为 10/12。浏览更多具有优秀工程文化的高级工程师和工程领导职位，或者在[务实工程师工作论坛](https://pallet.xyz/list/pragmatic-engineer/jobs)上添加您自己的职位，并申请加入[务实工程师人才集体](https://pragmatic-engineer.pallet.com/talent)。*

想从经过审查的科技公司获得有趣的机会吗？报名参加[务实的工程师人才集体](https://pragmatic-engineer.pallet.com/talent)，获得丰厚的机会——类似下面这些，没有任何义务。你可以是公开的，也可以是匿名的，我会整理公司和个人的名单。

你是在招聘高级+工程师还是工程经理？申请加入[务实工程师人才集体](https://pragmatic-engineer.pallet.com/talent)接触世界级高级及以上工程师和工程经理/总监。每月两次接受审查，来自软件工程师(全栈、后端、移动、前端、数据、ML)和目前在大型科技公司、高增长初创公司和具有强大工程文化的地方工作的经理。[申请此处](https://pragmatic-engineer.pallet.com/talent)。

