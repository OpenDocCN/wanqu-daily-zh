# 与艾伦·凯的对话——ACM 队列

> 原文:[http://queue.acm.org/detail.cfm?id=1039523&UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium =网站](http://queue.acm.org/detail.cfm?id=1039523&utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

<label>December 27, 2004
**[Volume 2, issue 9](issuedetail.cfm?issue=1039511)**</label>

[![Download PDF version of this article](../Images/d41c7b6eb6493a00953aa6dd3bd5eac4.png) PDF](https://dl.acm.org/ft_gateway.cfm?id=1039523&ftid=297449&dwn=1)

### 与艾伦·凯的对话

#### 与 Smalltalk 的创建者畅谈，以及更多内容。

当你想获得个人计算和编程语言的历史观点时，为什么不求助于这个行业的杰出先驱呢？那就是艾伦·凯，去年的图灵奖获得者，因为他领导的团队发明了 Smalltalk，以及他对个人计算的根本贡献。

Kay 是施乐帕洛阿尔托研究中心(PARC)的创始人之一，他领导的几个小组共同开发了现代工作站(以及 Macintosh 的前身)、Smalltalk、重叠窗口界面、桌面出版、以太网、激光打印和网络客户机-服务器。

在 PARC 大学工作之前，Kay 于 1969 年获得了犹他大学的博士学位，在那里他设计了一台面向图形对象的个人计算机，并且是为高级研究计划局(ARPA)开发开创性三维图形工作的研究小组的成员。凯也是阿帕网最初设计的“小参与者”，阿帕网后来成为了互联网。他拥有科罗拉多大学数学和分子生物学的本科学位。离开 PARC 施乐公司后，凯成为雅达利的首席科学家，苹果电脑公司的研究员，华特·迪士尼公司的研发副总裁。

今天，他是惠普实验室的高级研究员和视点研究所的主席，视点研究所是一个非营利组织，其目标是通过创建一个带有数学和科学教学支持媒体的样本课程来改变儿童的教育方式。本课程将使用 Squeak 作为其媒体，并将具有高度的互动性和建设性。多年来，凯对儿童和教育的浓厚兴趣一直是他许多想法的催化剂。

除了获得图灵奖，凯最近还获得了美国国家工程院颁发的德雷珀奖和稻盛基金会每四年颁发一次的京都先进技术奖。

IBM Research 的 Stuart Feldman 带领我们一起浏览个人计算的历史，他是 IBM Research 的副总裁兼按需业务转型领域策略师。自 1995 年加入 IBM 以来，Feldman 还担任互联网技术副总裁，并担任研究部门的计算机科学主管。

Feldman 还在 Bellcore 工作了 11 年，在那里他担任了软件工程和计算系统方面的几个研究管理职位，并在 Bell Labs 工作了 10 年，在那里他是一名计算机科学研究员。Feldman 是最初的 Unix 团队的成员，最著名的是 Make 配置管理系统的创建者和第一个 Fortran-77 编译器的作者。他拥有麻省理工学院的应用数学博士学位。他是排队咨询委员会的成员。

STUART FELDMAN 我们队列编辑部的一些年轻人一直在问的一个话题是编程语言的历史。队列板有双峰一代分布，那些 20 多岁或 30 多岁的成员似乎真的不知道编程语言实际上来自哪里。根据我的观察，我们每十年就有一种大语言和一种小语言——这似乎是这个领域所能承受的。闲聊是那种五年或十年一次的活动。

在 20 世纪 60 年代末，Jean Sammet 能够追踪并记录大约 3000 种现存的编程语言。当事情在某种意义上更简单时——但理论上更难，因为机器更慢，更小，大部分时间都没有硬盘，而且工具很差——人们仍然可以随时推出自己的操作系统和编程语言。所以他们的数量不计其数。

在 20 年前的一篇《科学美国人》文章中，我提出了一个滑稽的太阳黑子理论，只是指出每 101/2 年有一两种主要语言，在这两个时期之间是你可能称之为混合语言的时期。这些可以被看作是旧事物的改进或者几乎是新事物。我把 Fortran 记录为对旧事物或几乎是新事物的改进，而 Algol 和 Lisp 是新事物。

然后是 Simula，设计者认为它是 Algol 的扩展。它基本上是 Algol 的预处理器，就像 C++是 C 的预处理器一样。这是一个伟大的概念，我很幸运地看到它几乎是一个新事物。Smalltalk 和 Prolog 发生在 20 世纪 70 年代初。Prolog 的前身是卡尔·休伊特在 60 年代末做的一个很奇妙的东西叫 Planner。

也许是 20 世纪 80 年代的商业化扼杀了下一个预期的新事物。我们的计划和希望是，大约在 1984 年左右，下一代孩子会出现，做一些比 Smalltalk 更好的事情。我们都认为下一级的编程语言将更具战略性，甚至更面向政策，并且对它要做的事情有更多的了解。但是各种不同的事情凑在一起，下一代实际上没有出现。实际上，有人可能会说——就像我有时会说的那样——商业个人计算和操作系统的成功实际上已经导致了很多很多方面的相当大的倒退。

你可以认为这是对 60 年代和 70 年代的一些好想法进行了低通滤波，因为计算传播的速度比教育不成熟的人要快得多。在过去 25 年左右的时间里，我们实际上得到了一种类似于流行文化的东西，类似于当电视出现时发生的事情，它的一些发明者认为这将是一种让大众了解莎士比亚的方式。但是他们忘记了，要理解莎士比亚，你必须更老练，有更多的视角。电视所能做的就是捕捉人们的本来面目。

所以我认为今天缺乏真正的计算机科学，缺乏真正的软件工程，部分是由于这种流行文化。

所以 Smalltalk 之于莎士比亚就像 Excel 之于电视文化中的车祸？

不，如果你真的从历史的角度来看,《Smalltalk》只能算作一部小型希腊戏剧，它远远领先于大多数其他文化，但远不及莎士比亚。

如果你透过工程历史的镜头来看今天的软件，它肯定是某种工程——但它是没有拱门概念的人所做的那种工程。今天的大多数软件非常像一座埃及金字塔，数百万块砖块相互堆叠，没有结构完整性，只是由蛮力和数千奴隶完成。

这个类比甚至更好，因为有一些没人能理解的密室。

我会把我们在 70 年代做的闲聊和类似哥特式大教堂的东西进行比较。我们有两个想法，真的。其中一个是我们从 Lisp 得到的:后期绑定。另一个是对象的概念。这给了我们一个有点像拱门的东西，所以我们能够用很少的材料制造复杂的，看起来很大的结构，但我不会把我们带到 1000 年前的工程学上。

如果你看一下[Doug] Engelbart 的演示[一个 Engelbart 的小组在斯坦福研究所进行的开创性工作的现场在线超媒体演示，在 1968 年秋季联合计算机会议上展示]，那么你会看到比你在今天的商业系统中看到的更多的关于如何提高集体智商和帮助他们一起工作的想法。我认为，在多年来你可能称之为计算研究的最佳实践和能够泄露出来并适应更为权宜和有期限意识的外部世界之间，存在着非常长的滞后。

这并不是说人们完全愚蠢，但如果有一个伟大的想法，你有最后期限，你有权宜之计，你有竞争对手，很可能你会对这个想法进行低通滤波，并实施其中的一部分，而错过接下来要做的事情。这种情况一次又一次地发生。如果你像大多数人一样使用早期绑定的语言，而不是后期绑定的语言，那么你真的开始被你已经做过的事情所束缚。你不能那么容易地改变事物。

比方说，编程语言的采用往往是偶然的，重点往往是实现编程语言有多容易，而不是它的实际优点和特性。例如，Basic 永远不会出现，因为总会有一种比 Basic 更好的语言用于这个目的。那种语言是 Joss，比 Basic 早，而且很美。但是 Basic 碰巧在阿格的分时系统上，这个系统是 Dartmouth 做的，当 GE 决定特许经营它时，它开始传播 Basic 只是因为它在那里，而不是因为它有任何内在的优点。

这种情况一次又一次地发生。尼古拉斯·沃斯的语言得到了广泛传播，因为他是最认真的语言记录者之一，也是最早使用 p 代码(伪代码)编写算法语言的人之一——我们使用的就是这种代码。使用这些东西的想法有一个共同的起源，那就是 20 世纪 60 年代早期的一台叫做 Burroughs B5000 的机器的硬件，这是机构所讨厌的。

部分原因是大部分信息都没有公开。

让我恕不同意。我在那里，巴勒斯实际上雇用了大学毕业生向数据处理经理解释那台机器。有大量可用的信息。问题是 DP 经理不想学习新的计算方式，甚至不想学习如何计算。IBM 意识到了这一点，而 Burroughs 没有。

如果我没记错的话，我当时对那台机器很着迷，但我无法获得让我理解它的细节。

事实上，最初的机器有两个 CPU，在主设计师 Bob Barton 1961 年的一篇论文中描述得相当充分。其中一个伟大的文件被称为“描述符”,并详细阐述了它。问题是，这台机器中的几乎所有东西都完全不同，它试图实现的目标也完全不同。

这条线存在的原因是——尽管当权派不喜欢它——正是因为它几乎不可能崩溃，所以银行业继续购买这条线的机器，从 B5000 开始。巴顿是我大学时的一位教授，我在自己做的第一台台式机上采纳了一些想法。然后我们在 PARC 施乐公司(帕洛阿尔托研究中心)做了更好的工作。

英特尔、摩托罗拉和其他芯片公司都不明白为什么这种架构是个好主意。

顺便说一句，给你一个有趣的基准——在大致相同的系统上，以大致相同的方式优化，1979 年 PARC 施乐公司的基准运行速度只有今天的 50 倍。摩尔定律在这段时间里给了我们 40，000 到 60，000 倍的提高。因此，糟糕的 CPU 架构损失了大约 1000 倍的效率。

“不管您的处理器架构是什么，摩尔定律都会照顾您”这一神话是完全错误的。

这也和为什么有些语言在某些时候会成功有关。

是的，实际上 Lisp 和 Smalltalk 都是由 8 位微处理器完成的——这不是因为它们是 8 位微处理器，而是因为处理器架构不好，它们扼杀了动态语言。今天，这些语言运行合理，因为即使架构仍然不好，二级缓存是如此之大，一些需要工作的东西，在缓存内工作得相当好；所以 Lisp 和 Smalltalk 都可以做他们的事情，并且在今天都是可行的。当然，这两者都已经过时了。

今天流行的东西只是这些语言的“一半”。Sun Microsystems 公司有合适的人将 Java 变成一流的语言，我相信是 Sun 公司的营销人员在它本应问世之前匆忙推出了它。他们使得 Sun 软件公司的人无法做他们需要做的事情。作为一流的语言，Java 应该具备什么，而不仅仅是商业上的成功？

如我所说，这是一种流行文化。面向青少年的商业畅销唱片不一定要有什么特别的音乐价值。我认为各种编程语言的成功很大程度上是迅速填补了空白。Perl 是另一个例子，它满足了一个微小的、短期的需求，但从长期来看却是一个真正的问题。基本上，计算在过去 25 年中遇到的许多问题都来自于系统，在这些系统中，设计者试图修复一些短期的东西，而没有考虑如果这个想法被采纳，是否会扩大规模。软件应该有一个半衰期，所以旧软件会在 10 到 15 年后消失。

在 60 年代和 70 年代，这是一种不同的文化。ARPA(高级研究计划局)和 PARC 文化基本上是一种数学/科学类型的文化，对缩放感兴趣，当然，互联网是缩放的一种练习。这只是两个不同的世界，我不认为来自一个世界的人抱怨另一个世界有什么帮助——就像来自一个文学文化的人抱怨世界上大多数人没有阅读思想。这是徒劳的。

我不会花时间抱怨这些东西，因为过去 20 年发生的事情很正常，尽管这很不幸。一旦你的某些东西的增长速度超过了教育的增长速度，你总是会得到一种流行文化。众所周知，我在 70 年代末试图杀死 Smalltalk。有几年这是世界上最美妙的事情。它以一种比以往任何产品都更简洁、更美观的方式满足了人们的需求。但是时间在流逝。随着我们了解得越来越多，对我们想要做的事情越来越有雄心，我们意识到 Smalltalk 中有各种各样的事情没有按照它们应该的方式扩展——例如，我们在那里的反射材料。它是第一种真正能够看到自己的语言，但现在它知道如何更好地进行所有级别的反射——所以我们应该实现它。

几年后，我们发现这可以做得更好。几年后我们看到的对象模型可以做得更好，等等。所以问题是——我已经说过 Smalltalk 和 Lisp——它们倾向于吃掉自己的幼仔。我的意思是 Lisp 和 Smalltalk 都是非常好的工具，因为它们有一个元系统。他们有很多早期绑定语言没有的处理问题的方法，对于喜欢 Lisp 或 Smalltalk 的人来说，很难想象其他的东西。

现在只提几件关于 Java 的事情:它确实没有一个完整的元系统。出于各种原因，它一直存在两种制度而不是一种制度的问题。它有非对象的东西，也有它称之为对象的东西。它很难保持活力。它有一个垃圾收集器。那又怎样？那些已经存在很长时间了。但它并不擅长自我增值。

多年来，Java 的开发工具包都是用 C++完成的。这是一件很能说明问题的事情。

1995 年，当我们开始一组主要的实现时，我们非常仔细地研究了 Java，只是因为要做一个可行的语言内核需要做大量的工作。我们最不喜欢 Java 的是它的实现方式。它有一个从未发挥作用的旧想法，即拥有一套书面规范，必须根据书面规范实施 VM(虚拟机),然后使用基准测试来验证您刚刚实施的内容，这从未产生一个完全兼容的系统。

我们为 Smalltalk 开发的技术是编写虚拟机本身，因此有一个虚拟机的 Smalltalk 模拟器，它本质上是虚拟机的唯一规范。你可以调试，你可以通过向它提交东西来回答任何关于虚拟机将做什么的问题，并且你可以通过改变模拟器来对虚拟机做出每一个改变。当你按你想要的方式调试好所有东西后，你按下按钮，它就会生成一个数学上正确的 C 语言版本，可以在你试图进入的任何平台上运行。

结果是，今天这个名为 Squeak 的系统可以在 20 多个平台上运行。Java 不会这样做。如果你想一想互联网意味着什么，它意味着你必须在所有连接到互联网的东西上运行。因此，对我来说，Java 一直违反了互联网世界中软件工程的基本原则之一。

一旦我们意识到 Java 可能无法兼容不同的平台，我们基本上说我们将生成自己的系统，它绝对兼容不同的平台，这就是我们所做的。

任何人都能做到。如果 Sun 公司的专家有机会修复 Java，世界将会变得更加美好。这不是秘密知识。这是流行文化的秘密。

如果不说别的，Lisp 是根据 Lisp 精心定义的。

**AK** 是的，那是我读研究生时的一大启示——当我终于明白 Lisp 1.5 手册第 13 页底部的半页代码本身就是 Lisp 的时候。这些是“麦克斯韦软件方程！”这是整个编程世界，短短几行，我就能看懂。

我意识到，任何时候我想知道我在做什么，我只需要用半页纸写下这个东西的内核，它不会失去任何功能。事实上，它将通过能够更容易地重新进入自身来获得能量，这比大多数系统通过其他方式可能做到的要容易得多。

所有这些想法都可以成为软件工程和计算机科学的一部分，但是我担心——据我所知——现在大多数计算机科学的本科学位基本上都是 Java 职业培训。

我甚至听到强大的斯坦福大学以其杰出的教师抱怨说，基本上本科计算机科学项目只不过是 Java 认证。

嗯，我必须承认，我最近很惊讶地发现，在我管理的一群非常优秀的开发人员中，几乎没有一个人对 C 语言足够了解，能够写出专业的低级代码。他们都是优秀的 Java 运动员。

20 世纪 60 年代，Ted Steele 花了几年时间推广一个叫做 UNCOL(通用面向计算机语言)的想法，对我来说，通过一个奇怪而有趣的过程——主要是因为它容易实现——C 变成了 UNCOL。我认为任何人都不应该用它来写东西，但是对于任何想做多平台事情的人来说，这是一个很好的目标——特别是如果你选择了正确的子集。

Cs 的问题是，如果你曾经和他们一起详细地玩过，你可能会知道，就他们的算术而言，他们是不太符合犹太教规的。他们应该是，但他们并不完全符合 IEEE 标准。你必须选择一个 C 的子集，并且你必须有一些辅助信息来得到你的虚拟机的数学上完美的转换。

**SF** 你把 Smalltalk 的长久爱情归功于什么？我可以断言，人们似乎喜欢某些语言，而不仅仅是使用它们。我认识许多热爱 C 的人。我知道很少有人热爱 C++，尽管他们可能以此为生。

**AK** 你要成为一个与众不同的人，才能热爱 C++。这是一个非常有趣的例子，说明一个善意的想法是如何出问题的，因为[C++的创造者]比雅尼·斯特劳斯特鲁普并没有努力去做他被批评的事情。他的想法是，首先，如果你像 Simula 对 Algol 所做的那样对 C 有用，Algol 基本上是作为一种不同的编程架构模板的预处理器。它基本上是为超级优秀的程序员准备的，他们在做任何严肃的事情之前，应该继承所有的东西，包括存储分配器。当然，结果是大多数程序员没有继承太多的子类。所以我认识的喜欢 C++并在 C++里做了好事的人，都是认真的钢铁侠，基本上已经把它当回事了，这是一种宏处理器。我在 60 年代早期伴随着宏系统长大，你必须做很多工作才能让它们为你工作——否则，它们会杀了你。

**SF** 嗯，C++毕竟是作为宏处理器编程的，本质上。

是的，完全正确。但 Simula 也是。

我把 Smalltalk 归入拥有真正爱好者的这一类语言，这些人真正喜欢或热爱它，而不仅仅是欣赏和使用它。

在我为 ACM 写的 Smalltalk 的历史中，我这样描述了看待语言的一种方式:许多语言要么是特性的集合，要么是风格的结晶。像 APL、Lisp 和 Smalltalk 这样的语言是你可以称之为风格语言的语言，其中有一个真正的中心和你应该如何做每件事的估算风格。其他语言，比如 PL/I，实际上，那些试图在不整合的情况下添加的语言通常更成功。我认为风格语言吸引那些对数学有一定惰性的人。懒惰实际上会在以后得到回报，因为如果你最终花了一点额外的时间看到“哦，是的，这种语言将允许我非常非常好地做这件事，并且以一种比我在这里能做的更通用的方式，”通常这将在你一年后有了新想法时回来帮助你。另一方面，粘合性语言往往会产生粘合性，当你有了新的想法时，它们非常非常难以解开。

此外，我认为风格语言倾向于后期绑定语言。黏着语通常是早期绑定的。这使得整个方法有了很大的不同。你必须处理的错误种类，以及你必须处理它们的时间，是完全不同的。

有些人对类型系统非常虔诚，作为一名数学家，我喜欢类型系统的想法，但是从来没有人想出一个有足够范围的类型系统。如果你把 Simula 和 Lisp 结合起来——Lisp 没有数据结构，它有对象的实例——你会有一个动态类型系统，它会给你你需要的表达范围。

它会让你思考你需要思考的各种想法，而不用担心某样东西是什么类型，因为你有更广泛的东西。您所支付的是一些可以在运行时完成的检查，尤其是在过去，您支付的是一些效率。现在，我们就像巴顿在 B5000 上做的那样绕过效率问题:只需说，“去它的，我们将尽可能直接地执行这些重要的东西。”我们不会担心我们是否能把它编译成冯·诺依曼计算机，我们会让微码做我们需要做的任何事情来绕过这些低效，因为许多低效只是把东西放在过时的硬件架构上。

我认为这是两种文化的分歧。我见过很多会议，人们无法交流仅仅是因为方法上的风格差异。

我会把风格语言描述为那些有着非常严格的内核的语言。随着 Smalltalk 经历了一系列变革，相对于提高有用性的范围，这些变革在多大程度上改变了核心内核？

我们永远也不会知道你问题的确切答案，因为在系统的开发过程中，从施乐推出到今天，所有的变化都发生在施乐 PARC 公司的一条开发主线上。在外界看来，Smalltalk 几乎没有任何变化。基本上，它只是建立在越来越大的不同种类的库上。

但 Smalltalk 变化的好处是它从未被稀释，在施乐 PARC 公司期间，你可以考虑在 Smalltalk 中做的实际事情的范围急剧扩大。

基本上，这个工具变得越来越像一个程序员的工具，越来越不像一个孩子的工具——这个版本在 1980 年发布，我不认为它是由一个孩子编写的。我认为它不可能是由一个孩子编写的，因为它已经失去了一些便利设施，即使它获得了实用的能力。

所以 Smalltalk 一被真正的程序员认为是有用的东西，它就在某种程度上灭亡了；他们把它变得更像他们自己的形象，它开始失去其良好的终端用户功能。

但是没关系。我们在 1995 年开始的这个项目是让 Squeak 成为另一个面向儿童的最终用户系统的实现工具。这项工作做得非常好，全世界成千上万的儿童都在使用它。看待这个问题的另一种方式是认识到计算机是由人类来编程的。我们自己卷吧。我们不要抱怨 Java，甚至不要抱怨 Smalltalk。

事实上，我们甚至不用担心 Java。我们不要抱怨微软。让我们不要担心他们，因为我们也知道如何给计算机编程，事实上我们知道如何用元方法来做。我们可以建立另一种观点，正如你所知，我们不是唯一这样做的人。

在互联网上有无数的例子，人们通过提出自己的观点达到了一个或另一个层次。Squeak 是最全面的，因为它跨越了整个领域。它不需要任何特定的操作系统来运行，因为它是自给自足的，并且有一整套工具和应用程序等等，但是有许多有趣的函数式语言，特别是在欧洲，也很有趣。

我最喜欢的古老语言之一是 Ed Ashcroft 的 Lucid。这是一个美丽的想法。他说，“嘿，你看，我们可以把一个变量看作一个流，看作它的值和时间的某种有序的东西，用 Christopher Strachey 的观点，尾部递归和 Lisp 的一切都是美好的，除了它看起来像什么。”当他研究 Lisp 的时候，他有了一个很好的见解:尾部递归循环和 Lisp 是如此的简洁，因为你在做任何重新绑定之前生成了所有赋值语句的右边。所以你会自动被迫使用旧的值。你不能重新绑定，所以没有任何竞争条件。

你只需要写下所有这些东西，然后当你做尾部递归的时候，用这些新值重新绑定所有的变量。Strachey 说，“我可以像写顺序程序一样把它写下来，作为一串同时的赋值语句，以及一个更容易想到的循环。”这基本上就是 Lucid 所做的——没有理由你必须递归地思考基本上是迭代的事情，如果你有一个关于什么是值的更好的理论，你可以让这些迭代像函数式语言一样清晰。

顺便说一句，这个想法在[Squeak contributor] Dave Reed 关于协调对象兄弟姐妹的精彩论文中使用过，其中你有一个逻辑对象，但同一对象在不同的机器上有许多物理表现，你必须让它们通过事务来跟踪彼此。

摆脱这些东西(比如 Smalltalk)的方法是做一些更强大的计算模型，并且对试图编写程序的核心程序员来说更具表现力。在这些晚期编程语言中，你可以让老家伙消失，只留下新人。所以我们此刻正在这样做。

你认为一门编程语言应该实现什么，为谁而实现，然后这个想法的模型是什么？

即使你是为专业程序员设计，最终你的编程语言基本上是一种用户界面设计。如果你把它看作一个用户界面设计，无论你想做什么，你都会得到更好的结果。PARC 被错误地认为是发明了图形用户界面。当然，60 年代也有图形用户界面。但是我认为我们确实做了一件以前没有做过的好事，那就是意识到变化是永恒的。

你永远不会在同一条河流中行走，否则就会被称为 Strachey streams。

用户界面仍然是今天占主导地位的方法，它是访问功能的用户界面。如果这个区域很有趣，你最终会得到一个看起来像核反应堆控制面板的东西。所以这就是特征的胶合。

**SF** 对，每个像素一个按钮。

企业购买者通常根据功能集进行购买。但是在 PARC，我们的想法是，因为你不会两次踏入同一条河，你想让用户界面成为的第一件事是一个学习环境——可以用各种方式探索的东西，在用户使用这个环境的一生中会改变的东西。新事物将会出现，而这些新事物的出现意味着什么？

这不仅意味着应用程序的改进，也意味着用户界面本身的改进。其中一些想法在最初的 Macintosh 中非常明显，但在今天的 MAC 中就不那么明显了——当然也从未真正进入微软。这不是他们思考问题的方式，我认为编程语言也是如此。即使用户是一个绝对的专家，能够记住几乎所有的事情，我总是对你所谓的严格意义和可调整意义之间的区别感兴趣。

多年来，我对此做了相当多的研究，以了解拥有可以阅读的东西的影响。众所周知，我们阅读和听力的基本语言机制有一个快过程和一个慢过程。快速过程基本上具有表面短语大小的性质，然后还有一个较慢的过程。这就是为什么笑话需要停顿；这个笑话实际上是从一个语境跳到另一个语境，而反应较慢的人，也就是处理真实含义的人，必须跟上它。

对此已经有很多很多的研究。这种观点认为，无论语言是什么，它的表层形式都是可以调整的。你可能知道，最近的研究着眼于大脑的不同部分如何识别笑话并做出反应。从生理上来说，他们是截然不同的。

**AK** 是的。所有的创造力都是玩笑的延伸形式。大多数创造力是从一个环境到另一个环境的过渡，在那里事情更令人惊讶。有一种惊喜的成分，尤其是在科学领域，伴随着“啊哈”的笑声是常有的。艺术也有这个元素。我们的工作是提醒我们，除了我们所处的环境，还有更多我们认为是现实的环境。

在 60 年代，计算机科学团体的主要目标之一是达成一种可扩展语言。据我所知，只有三个曾经真正工作过，第一个 Smalltalk 就是这三个中的一个。另一个非常有趣的是 Ned Irons 做的，他发明了语法指导编译器这个术语，并在 60 年代做了第一批。他做了一个很棒的可扩展语言，叫做 Imp。

人们从这些可扩展语言中认识到的一件事是，使元系统易于使用存在不幸的困难。Smalltalk-72 其实是小孩子用的。当你创建普通的类时，你总是在没有意识到的情况下扩展语言。这样做的结果是，你不必进入一个更深奥的地方，比如编译器——Yacc 或类似的东西——来为语言添加一些扩展。

但硬币的另一面是，即使是优秀的程序员和语言设计师，在编程的热潮中也会倾向于做糟糕的扩展，因为设计是最好慢慢地、小心地完成的事情。

不支持 **SF** 和深夜可扩展编程。

**AK** 正是。所以 Smalltalk 实际上从一个完全可扩展的东西发展到我们选择一种语法，允许各种形式的固定内容，并专注于其中含义的可扩展性。

这并不完全令人满意。我认为今天应该做的一件事是建立一个你必须跳过的围栏，以此来有力地提醒你，你现在处于一个元区域——你现在正在修补货币体系本身，你不仅仅是在投机。但是一旦你跨过这道栅栏，它应该允许你在没有任何其他开销的情况下完成它，因为当你想做的时候，你就想去做。

我可以继续下去。我觉得我的回答很琐碎，因为没有人真正知道如何设计一门好的语言，包括我自己。

在 Smalltalk 时代，你希望自己在哪些方面有所不同？

我拥有世界上最伟大的组合，我也应该拥有世界上最伟大的两个组合。我没有意识到拥有真正的实现者和真正的用户有好处，每隔几个月从头开始也有好处。我雇佣整理者是因为我是一个好的开始者和一个差的整理者，但我花了很长时间才意识到我试图改善事情是在干扰他们。

我相信唯一的科学计算就像是造桥的科学。必须有人去建桥，其他人去拆除它们，创造更好的理论，而你必须继续建桥。

有时，你不得不看着一只掉进水里。

**爱它，恨它？让我们知道**

[【电子邮件保护】](/cdn-cgi/l/email-protection)或 www.acmqueue.com/forums

2004 年 4 月 1200 日

![acmqueue](../Images/4f57fce9b685ad00824bd02663d98c4d.png)

*原载于《队列》第 2 卷第 9 期*——
见本条目于 [ACM 数字图书馆](https://portal.acm.org/citation.cfm?id=1039523)

* * *

更多相关文章:

C++编译器中的优化
给编译器更多的信息是有代价的:它会使编译变慢。像链接时间优化这样的技术可以让你两全其美。编译器中的优化在继续改进，间接调用和虚函数调度中即将到来的改进可能很快会带来更快的多态性。

乌兰·德根巴耶夫，迈克尔·利波茨，汉尼斯·帕耶 - [**垃圾回收作为合资企业**](detail.cfm?id=3325132)
跨组件追踪是解决跨组件边界引用循环问题的一种方式。一旦组件可以跨越 API 边界形成具有非平凡所有权的任意对象图，这个问题就出现了。V8 和 Blink 中实现了 CCT 的增量版本，能够以安全的方式有效且高效地回收内存。

大卫·奇斯纳尔 - [**C 不是低级语言**](detail.cfm?id=3212479)
在最近的灾难和 Spectre 漏洞之后，有必要花点时间看看根本原因。这两个漏洞都涉及处理器推测性地执行通过某种访问检查的指令，并允许攻击者通过侧信道观察结果。导致这些漏洞的特性，以及其他几个特性，是为了让 C 程序员继续相信他们是在用低级语言编程，而几十年来情况并非如此。

Tobias Lauinger，Abdelberi Chaabane，Christo Wilson - [**你不应该依靠我**](detail.cfm?id=3205288)
大多数网站都使用 JavaScript 库，其中许多都容易受到攻击。理解问题的范围，以及包含库的许多意想不到的方式，只是改善这种情况的第一步。这里的目标是本文中包含的信息将有助于为社区提供更好的工具、开发实践和教育成果。

* * *

* * *

[![](../Images/ad65ebb8b75e7581c1bc43a3736aed3c.png)](#) 
ACM 公司版权所有。