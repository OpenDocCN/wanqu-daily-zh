# 微服务权衡

> 原文:[http://Martin fowler . com/articles/microservice-trade-offers . html？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://martinfowler.com/articles/microservice-trade-offs.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

…但是有成本

*   分布式系统更难编程，因为远程调用很慢，而且总是有失败的风险。
*   最终一致性 : 对于一个分布式系统来说，保持强一致性是非常困难的，这意味着每个人都必须管理最终的一致性。
*   [运营复杂性](#ops) : 您需要一个成熟的运营团队来管理大量服务，这些服务会定期重新部署。

[总结](#summary)

## 强模块边界(Pro)

微服务的第一大好处是强大的模块边界。这是一个重要的好处，但也是一个奇怪的好处，因为在理论上，微服务没有理由比整体服务有更强的模块边界。

那么我所说的强模块边界是什么意思呢？我想大多数人都会同意将软件划分成模块是好的:彼此分离的软件块。您希望您的模块能够正常工作，这样，如果我需要更改系统的一部分，大多数情况下我只需要了解系统的一小部分就可以进行更改，并且我可以很容易地找到那一小部分。好的模块化结构在任何程序中都是有用的，但是随着软件规模的增长，它变得更加重要。也许更重要的是，随着开发团队规模的扩大，它的重要性也越来越大。

微服务的倡导者很快引入了康威定律，即软件系统的结构反映了构建它的组织的通信结构。对于较大的团队，特别是如果这些团队位于不同的位置，重要的是要构建软件来识别团队间的交流比团队内的交流更少更正式。微服务允许每个团队用那种通信模式照看相对独立的单元。

正如我前面说过的，没有理由为什么一个单片系统不应该有一个好的模块化结构。但是许多人注意到这似乎很少见，因此[大泥球](http://www.laputan.org/mud/)是最常见的架构模式。事实上，这种对 monoliths 的共同命运的失望是驱使几个团队转向微服务的原因。与模块的解耦是可行的，因为模块边界是模块间引用的障碍。问题是，对于单片系统，通常很容易绕过屏障。这样做可能是快速构建特性的一个有用的战术捷径，但是做得太多会破坏模块化结构，降低团队的生产力。将这些模块放入单独的服务中使得界限更加牢固，使得找到这些恶性变通办法变得更加困难。

这种耦合的一个重要方面是持久数据。微服务的一个关键特征是[分散数据管理](/microservices.html#DecentralizedDataManagement)，即每个服务管理自己的数据库，任何其他服务都必须通过服务的 API 来获取它。这消除了[集成数据库](/bliki/IntegrationDatabase.html)，它是大型系统中令人讨厌的耦合的主要来源。

重要的是要强调，使用 monolith 完全有可能实现稳固的模块边界，但是这需要纪律。同样，你可以得到一个大的微服务泥浆球，但它需要更多的努力来做错误的事情。在我看来，使用微服务增加了你获得更好的模块化的可能性。如果你对你的团队的纪律有信心，那么这可能会消除这种优势，但是随着团队的成长，保持纪律变得越来越难，就像保持模块边界变得越来越重要一样。

如果你没有把握好自己的界限，这种优势就会变成障碍。这就是为什么 [Monolith First](/bliki/MonolithFirst.html) 策略的两个主要原因之一，也是为什么那些[更倾向于在早期](/articles/dont-start-monolith.html)运行微服务的人强调你只能在充分了解的领域中这样做。

但是在这一点上我还没有说完。只有经过一段时间后，你才能真正知道一个系统保持模块化的程度。因此，只有当我们看到已经存在了至少几年的微服务系统时，我们才能真正评估微服务是否会带来更好的模块化。此外，早期采用者往往更有才华，因此在我们评估由一般团队编写的微服务系统的模块化优势之前，还会有进一步的延迟。即使这样，我们也不得不接受普通团队编写普通软件的事实，因此与其将结果与顶级团队进行比较，我们还得将最终的软件与单一架构下的软件进行比较——这是一个很难评估的反事实。

目前我能做的只是从我认识的使用这种风格的人那里得到的早期证据。他们的判断是维护他们的模块要容易得多。

一个案例研究特别有趣。该团队做出了错误的选择，在一个不够复杂的系统上使用微服务来覆盖[微服务溢价](/bliki/MicroservicePremium.html)。这个项目陷入了困境，需要被拯救，所以更多的人被投入到这个项目中。在这一点上，微服务架构变得很有帮助，因为系统能够吸收快速涌入的开发人员，团队能够比一般的 monolith 更容易地利用更大的团队人数。结果，项目加速到了比预期的更高的生产率，使得团队能够赶上。结果仍然是负面的，因为软件花费了更多的工作人员时间，如果他们用一个整体的话，但是微服务架构确实支持 ramp up。

## 分配(续)

所以微服务用分布式系统来提高模块化。但是分布式软件有一个很大的缺点，那就是它是分布式的。一旦你打出分发牌，你就会招致一大堆复杂的事情。我不认为微服务社区像分布式对象运动那样天真地看待这些成本，但复杂性仍然存在。

首先是性能。你必须在一个非常不寻常的地方才能看到进程内函数调用变成了性能热点，但是远程调用很慢。如果您的服务调用六个远程服务，而每个远程服务又调用另外六个远程服务，那么这些响应时间就会累积成一些可怕的延迟特征。

当然，你可以做很多事情来缓解这个问题。首先，你可以增加你的通话粒度，这样你就可以减少通话次数。这使您的编程模型变得复杂，您现在必须考虑如何批量处理您的服务间交互。这也只能做到这一步，因为您必须至少调用每个协作服务一次。

第二个缓解措施是使用异步。如果并行进行六次异步调用，你现在的速度只是最慢的调用的速度，而不是它们的总延迟。这可能是一个很大的性能提升，但也带来了另一个认知成本。异步编程很难:很难做好，调试更难。但是我听到的大多数微服务故事都需要异步来获得可接受的性能。

紧随速度之后的是可靠性。您希望进程内函数调用能够工作，但是远程调用随时都可能失败。有了大量微服务，潜在的故障点就更多了。明智的开发人员知道这一点，并且[为失败而设计](/articles/microservices.html#DesignForFailure)。幸运的是，异步协作所需的各种策略也非常适合处理故障，其结果可以提高弹性。这并不是很大的补偿，但是，您仍然有额外的复杂性来计算每个远程调用失败的后果。

这还只是分布式计算的两大谬误。

这个问题有一些注意事项。首先，随着它的成长，这些问题中的许多会突然出现。很少有独石是真正独立的，通常会有其他系统，通常是遗留系统，一起工作。与他们互动包括通过网络，遇到同样的问题。这就是为什么许多人倾向于更快地转移到微服务来处理与远程系统的交互。在这个问题上，经验也是有帮助的，一个更有技巧的团队将能够更好地处理分配的问题。

但是分销总是有成本的。我总是不愿意打分配牌，认为太多人分配得太快，因为他们低估了问题。

## 最终一致性(Con)

我相信你知道需要一点耐心的网站。你更新了一些东西，它刷新了你的屏幕，但是更新不见了。你等一两分钟，点击刷新，它就在那里。

这是一个非常恼人的可用性问题，几乎可以肯定是由于最终一致性的危险。粉色节点接收到了您的更新，但是绿色节点处理了您的 get 请求。在绿色节点从粉色节点获得更新之前，您将一直停留在不一致窗口中。最终它会保持一致，但在此之前，你会怀疑是否出了什么问题。

像这样的不一致已经够令人恼火的了，但它们可能会严重得多。业务逻辑最终可能会对不一致的信息做出决策，当这种情况发生时，很难诊断出哪里出了问题，因为任何调查都将在不一致窗口关闭后很久才进行。

微服务引入了最终的一致性问题，因为它们值得称赞地坚持分散的数据管理。使用 monolith，您可以在单个事务中一起更新一堆东西。微服务需要多个资源来更新，分布式事务是不被允许的(理由很充分)。所以现在，开发人员需要意识到一致性问题，并在做任何代码会后悔的事情之前，想出如何检测出什么时候事情不同步。

单一的世界也不能摆脱这些问题。随着系统的增长，越来越需要使用缓存来提高性能，缓存失效是另一个难题。大多数应用程序需要[离线锁](/eaaCatalog/optimisticOfflineLock.html)来避免长期的数据库事务。外部系统需要无法与事务管理器协调的更新。业务流程通常比你想象的更能容忍不一致，因为业务通常更看重可用性(业务流程长期以来一直对[上限定理](http://ksat.me/a-plain-english-introduction-to-cap-theorem/)有着本能的理解)。

所以像其他分布式问题一样，monoliths 并不能完全避免不一致的问题，但是它们确实更少受到这些问题的困扰，特别是当它们更小的时候。

## 独立部署(Pro)

在我的整个职业生涯中，模块化边界和分布式系统的复杂性之间的权衡一直存在。但是在过去的十年中，有一件事发生了显著的变化，那就是发布到生产的角色。在 20 世纪，产品发布几乎普遍是一件痛苦而罕见的事情，人们在周末日夜轮班，把一些笨拙的软件拿到可以做有用的事情的地方。但是现在，熟练的团队频繁地发布产品，许多组织实践[连续交付](/bliki/ContinuousDelivery.html)，允许他们一天多次进行产品发布。

> 微服务是 DevOps 革命后的第一个架构
> 
> 尼尔·福特

这种转变对软件行业产生了深远的影响，它与微服务运动紧密交织在一起。部署大型整体结构的困难引发了一些微服务工作，其中整体结构的一个小的变化可能导致整个部署失败。微服务的一个关键原则是[服务是组件](/articles/microservices.html#ComponentizationViaServices)，因此可以独立部署。所以现在当你做出改变时，你只需要测试和部署一个小的服务。如果你搞砸了，你不会拖垮整个系统。毕竟，由于需要为失败而设计，即使组件完全失败也不应该阻止系统的其他部分工作，尽管会有某种形式的适度降级。

这种关系是双向的。由于许多微服务需要频繁部署，因此您的部署行动必须协调一致。这就是为什么快速应用部署和基础设施快速供应是[微服务的先决条件](/bliki/MicroservicePrerequisites.html)。对于任何超出基础的东西，你需要做持续的交付。

持续交付的最大好处是减少了一个想法和运行软件之间的周期时间。这样做的组织可以快速响应市场变化，并比竞争对手更快地引入新功能。

尽管许多人认为连续交付是使用微服务的一个原因，但有必要提及的是，即使是大型整体也可以连续交付。脸书和 Etsy 是两个最著名的案例。也有很多尝试微服务架构在独立部署时失败的情况，其中多个服务需要仔细协调它们的发布。虽然我确实听到很多人认为使用微服务进行连续交付要容易得多，但我不太相信这一点，因为模块化的实际重要性——尽管模块化自然与交付速度密切相关。

## 运营复杂性(Con)

能够快速部署小型独立单元对开发来说是一大福音，但这会给运营带来额外的压力，因为六个应用程序现在会变成数百个小型微服务。许多组织会发现处理这样一大群快速变化的工具的难度令人望而却步。

这强化了持续交付的重要作用。虽然持续交付对于 monoliths 来说是一项有价值的技能，一项几乎总是值得努力去获得的技能，但它对于一个严肃的微服务设置来说是必不可少的。没有持续交付培养的自动化和协作，就没有办法处理大量的服务。由于对管理这些服务和监控的需求增加，运营复杂性也增加了。同样，如果混合了微服务，那么对单片应用有用的成熟度级别就变得必要了。

微服务的支持者喜欢指出，因为每个服务都更小，所以更容易理解。但是危险在于复杂性并没有被消除，它只是转移到了服务之间的互连上。这可能会增加操作的复杂性，例如跨服务调试行为的困难。服务边界的良好选择将减少这个问题，但是错误位置的边界会使它变得更糟。

处理这种操作复杂性需要大量新的技能和工具——最重要的是技能。工具仍然不成熟，但我的直觉告诉我，即使有更好的工具，在微服务环境中，技能的低门槛也更高。

然而，对更好的技能和工具的需求并不是处理这些操作复杂性的最困难的部分。为了有效地完成这一切，你还需要引入一种 [devops 文化](/bliki/DevOpsCulture.html):在开发人员、运营人员和参与软件交付的其他所有人之间进行更好的协作。文化变革是困难的，尤其是在较大和较老的组织中。如果您不进行这种技能提升和文化变革，您的单片应用程序将受到阻碍，但您的微服务应用程序将受到创伤。

## 技术多样性(Pro)

由于每个微服务都是一个可独立部署的单元，因此您在技术选择上有相当大的自由度。微服务可以用不同的语言编写，使用不同的库，使用不同的数据存储。这允许团队为工作选择合适的工具，一些语言和库更适合某些类型的问题。

关于技术多样性的讨论通常集中在工作的最佳工具上，但微服务的最大好处通常是版本控制这一更普通的问题。在 monolith 中，你只能使用一个版本的库，这种情况经常会导致升级出现问题。系统的一部分可能需要升级才能使用其新功能，但由于升级破坏了系统的另一部分，所以不能升级。随着代码库变得越来越大，处理库版本问题是其中之一。

这里有一个危险，技术多样性如此之多，以至于开发组织可能会不知所措。我所知道的大多数组织确实鼓励有限的技术。这种鼓励是通过为诸如监控之类的事情提供公共工具来支持的，这使得服务更容易坚持公共环境的小组合。

不要低估支持实验的价值。对于一个单一的系统，早期关于语言和框架的决定很难逆转。大约十年后，这样的决定会将团队锁定在笨拙的技术上。微服务允许团队试验新的工具，并且如果有更好的技术变得相关，也可以一次一个服务地逐步迁移系统。



## 次要因素

我认为上述项目是要考虑的主要权衡因素。这里还有一些我认为不太重要的事情。

微服务的支持者经常说服务更容易扩展，因为如果一个服务有很多负载，你可以只扩展它，而不是整个应用。然而，我很难回忆起一份像样的体验报告，它让我相信，与通过复制整个应用程序来进行[千篇一律的缩放](http://paulhammant.com/2011/11/29/cookie-cutter-scaling/)相比，进行这种选择性缩放实际上更有效。

微服务允许您分离敏感数据，并为这些数据添加更仔细的安全性。此外，通过确保微服务之间的所有流量都是安全的，微服务方法可以使利用入侵变得更加困难。随着安全问题变得越来越重要，这可能会成为使用微服务的主要考虑因素。即使没有这一点，主要是单体系统创建单独的服务来处理敏感数据也并不罕见。

微服务的批评者谈到测试微服务应用比测试整体应用更困难。虽然这是一个真正的困难——分布式应用程序更大复杂性的一部分——但是有好的方法来测试微服务。这里最重要的是要有严肃对待测试的纪律，相比之下，测试单片和测试微服务之间的差异是次要的。





## 总结

任何关于任何建筑风格的通用帖子都会受到一般建议的限制。因此，阅读这样的帖子不能为你做出决定，但这样的文章可以帮助你考虑你应该考虑的各种因素。这里的每个成本和收益对于不同的系统有不同的权重，甚至在成本和收益之间交换(强模块边界在更复杂的系统中是好的，但对于简单的系统是一个障碍)您做出的任何决定都取决于将这样的标准应用到您的环境中，评估哪些因素对您的系统最重要，以及它们如何影响您的特定环境。此外，我们对微服务架构的经验相对有限。您通常只能在系统已经成熟，并且您已经了解了在开发开始多年后如何工作之后，才能判断架构决策。我们还没有很多关于长寿微服务架构的轶事。

单片和微服务不是简单的二元选择。两者都是模糊的定义，这意味着许多系统将位于模糊的边界区域。还有其他系统不属于这两类。包括我自己在内的大多数人都将微服务与 monoliths 进行对比，因为将它们与更常见的风格进行对比是有意义的，但我们必须记住，有些系统并不适合这两种类型。我认为独石和微服务器是建筑空间中的两个区域。它们值得命名，因为它们具有有趣的特征，有助于讨论，但没有明智的建筑师将它们视为建筑空间的综合分区。

也就是说，一个似乎被广泛接受的概括要点是存在一个[微服务溢价](/bliki/MicroservicePremium.html):微服务对生产力造成的成本只能在更复杂的系统中弥补。因此，如果您可以使用单片架构来管理系统的复杂性，那么您就不应该使用微服务。

但是微服务对话的数量不应该让我们忘记驱动软件项目成功和失败的更重要的问题。团队中人的素质、相互协作的程度、与领域专家的沟通程度等软因素，会比是否使用微服务产生更大的影响。在纯技术层面上，更重要的是关注干净的代码、良好的测试和对进化架构的关注。



* * *