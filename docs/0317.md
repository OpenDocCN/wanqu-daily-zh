# Thorsten 球-为什么螺纹不能分叉

> 原文:[http://Thorsten ball . com/blog/2014/10/13/why-threads-cant-fork/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://thorstenball.com/blog/2014/10/13/why-threads-cant-fork/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

# 为什么线程不能分叉

2014 年 10 月 13 日

Go issue tracker 上有一个[有趣的帖子](https://code.google.com/p/go/issues/detail?id=227)是关于 daemonizing 流程的。尽管大多数线程都不是关于进程的 daemonizing，而是关于为什么 Go 没有可以在代码中直接调用的`Fork()`函数。当我第一次通读它的时候，我想知道并对自己说:“是啊，为什么没有`Fork()`？实现起来肯定不会那么难。”毕竟你已经可以用 [syscall](http://golang.org/pkg/syscall/) 包调用系统调用了。随着我读得越来越多，我意识到问题不在于实现`Fork()`本身，而在于实现`Fork()`以便在多线程环境中安全工作，大多数 Go 程序都是如此。所以我试图找出原因。

事实证明，问题源于`fork(2)`本身的行为。每当用`fork(2)`创建一个新的子进程时，这个新进程就会获得一个新的内存地址空间，但是内存中的所有内容都是从旧进程中复制过来的(写时复制并不是 100%正确，但是语义是相同的)。

如果我们在多线程环境中调用`fork(2)`,执行调用的线程现在是新进程中的主线程，而在父进程中运行的所有其他线程都死了。他们所做的一切都和呼叫`fork(2)`前一模一样。

现在想象一下，在调用`fork(2)`之前，这些线程正在愉快地工作，几毫秒后它们就死了。如果这些现在已经死了的线程所做的事情不应该保持原样呢？

我给你举个例子。假设我们的主线程(将要调用`fork(2)`的那个)正在睡觉，而我们有许多其他线程在愉快地做着一些工作。分配内存、写入内存、从中复制、写入文件、写入数据库等等。他们可能用类似于`malloc(3)`的东西来分配内存。嗯，事实证明`malloc(3)`在内部使用了一个互斥体来保证线程安全。这正是问题所在。

如果这些线程中的一个正在使用`malloc(3)`，并且在主线程调用`fork(2)`的同时获得了互斥锁，那会怎么样呢？在新的子进程中，锁仍然被一个现在已经死了的线程持有，这个线程永远不会归还它。

新的子进程不知道使用`malloc(3)`是否安全。在最坏的情况下，它将调用`malloc(3)`并阻塞，直到它获得锁，这将永远不会发生，因为应该返回它的线程已经死了。而这仅仅是`malloc(3)`。想想数据库驱动程序、文件处理库、网络库等等中所有其他可能的互斥体和锁。

为了以安全的方式调用`fork(2)`,调用线程需要绝对确定所有其他线程也要分叉。这很难，尤其是如果你打算在一个库中实现一个围绕`fork(2)`的包装器，并且不知道你周围会发生什么。

如果新的子进程将被转换成另一个不同的进程，问题并不大，因为堆、栈和数据将被替换。这就是为什么有一个[操作系统。Go 中的 StartProcess()](http://golang.org/pkg/os/#StartProcess) ，它使用了头罩下的`fork(2)`(见第 65 行[此处](https://golang.org/src/pkg/syscall/exec_bsd.go))。仍然存在打开文件描述符的问题，新的子进程将继承这些文件描述符，但是这些文件描述符只打算被一个现在已经死了的线程使用。但是仍然有可能关闭它们，因为新的子进程可以直接访问它们。

现在你可能意识到这篇文章的标题是一个谎言，因为线程**可以**分叉。但在实践中，这真的很难实现，这也解释了为什么开始提到的围棋问题已经存在了近 5 年。

当然，有几种尝试来提供解决方案。[`pthread_atfork(3)`][http://Linux . die . net/man/3/pthread _ at fork]允许用户在 fork 前后的线程中注册要调用的处理程序。但是你可以想象，这也很麻烦。Solaris 有`forkall(2)`，它不会杀死非分叉线程，而是让它们保持活动状态，做它们之前做的事情。这种行为伴随着 T2 自身的问题:

> 如果一个线程调用`forkall()`，执行文件 I/O 的父线程将被复制到子进程中。线程的两个副本将继续对同一文件执行 I/O 操作，一个在父级，一个在子级，从而导致故障或文件损坏。

总结一下:是的，这个标题是骗人的，是的，你可以在多线程环境中`fork(2)`，但是安全地完成它真的真的很难。这么说吧，线程不能分叉，就这样吧。