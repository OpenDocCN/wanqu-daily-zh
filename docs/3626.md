# 发挥极限:构建可靠系统的考虑——勇敢的新极客

> 原文：<http://bravenewgeek.com/take-it-to-the-limit-considerations-for-building-reliable-systems/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

复杂系统通常以故障模式运行。这是因为一个复杂的系统通常由许多不连续的部分组成，其中的每一部分都可能单独(或同时)发生故障。在微服务架构中，给定的功能可能包含几个独立的服务调用，*高*可用性取决于部分*可用的能力。这是弹性工程背后的核心原则。如果一项功能依赖于三种服务，每种服务的可靠性分别为 90%、95%和 99%，则部分可用性可能是 99.995%可靠性和 84%可靠性之间的差值(假设故障是独立的)。弹性工程意味着以失败为常态的设计。*

预见失败是恢复禅宗的第一步，但第二步是 [*拥抱* it](https://bravenewgeek.com/designed-to-fail/) 。告诉客户“不”,然后故意失败，总比以不可预测或意想不到的方式失败要好。背压是另一个重要的弹性工程模式。从根本上说，这是关于执行限制。这表现在队列长度、带宽限制、流量整形、消息速率限制、最大有效载荷大小等方面。规定这些限制使得原本隐含的限制变得显而易见(*最终*你的服务器将耗尽它的内存，但是因为限制是隐含的，所以不清楚确切的*何时*或*会有什么样的*后果)。依赖无界队列和其他隐式限制就像有人说他们知道什么时候该停止喝酒，因为他们最终会晕过去。

速率限制很重要，不仅仅是为了防止不良因素影响你的系统，也是为了你自己。队列限制和消息大小限制特别有趣，因为它们似乎让开发人员感到困惑和沮丧，他们还没有完全理解其背后的动机。但实际上，这只是另一种形式的速率限制，或者更一般地说，背压。让我们将最大邮件大小作为一个案例来研究。

想象一下，我们有一个分布式参与者系统。一个参与者可以向其他参与者发送消息，其他参与者依次处理消息，也可以选择自己发送消息。现在，任何优秀的软件工程师都知道，分布式计算的第八个谬误是“网络是同质的”这意味着并非所有参与者都使用相同的硬件、软件或网络配置。我们有运行 Ubuntu 的 128GB 内存的服务器，运行 macOS 的 16GB 内存的笔记本电脑，运行 Android 的 2GB 内存的移动客户端，512MB 内存的物联网边缘设备，以及介于两者之间的一切，都运行着软件和网络接口的大杂烩。

当我们选择*而不是*来设定消息大小的上限时，我们是在做一个隐式的假设(回想一下前面关于隐式/显式限制的讨论)。换句话说，你和每一个与你互动的人(可能是在不知不觉中)达成了一个心照不宣的契约，双方都不能退出。这是因为任何参与者都可以发送任意大小的消息。这意味着该消息的任何下游消费者，无论是直接的还是间接的，都必须支持任意大的消息。

我们如何测试任意的东西？我们不能。我们有两个选择:要么明确限制，要么保持这种隐含的、任意约束的契约。前者允许我们定义我们的操作边界，并给我们一些东西来测试。后者要求我们在某种未定义的生产级规模上进行测试。第二种选择实际上是为了方便而赌可靠性。极限还在，只是藏起来了。当我们不使它明确，我们很容易在生产中做自己。由于云基础设施的多租户性质，在处理云基础设施时，限制变得更加重要。它们防止坏人(或您自己)破坏服务或控制基础设施和系统资源。

在我们的异构 actor 系统中，我们有绑定到移动设备和 web 浏览器的消息，这些设备和浏览器通常是单线程或内存受限的消费者。如果没有对消息大小的明确限制，客户端很容易因为请求太多数据或只是接收超出其控制范围的数据而自取灭亡——这就是为什么该契约是心照不宣但具有约束力的。

让我们从不同的工程角度来看这个问题。考虑另一种类型的系统:美国国家公路系统。美国交通部使用[联邦桥梁总重公式](https://en.wikipedia.org/wiki/Federal_Bridge_Gross_Weight_Formula)作为防止重型车辆损坏道路和桥梁的手段。这实际上是同样的工程问题，只是不同的学科和不同类型的基础设施。

> 2007 年 8 月，明尼阿波利斯州际公路 35W 密西西比河大桥倒塌，重新引起了人们对卡车重量及其与桥梁应力关系的关注。2008 年 11 月，美国国家运输安全委员会(National Transportation Safety Board)认定，大桥坍塌有几个原因，包括(但不限于):角撑板有缺陷、检查不充分、重型建筑设备的额外重量加上高峰时段的交通流量。

交通部依靠[称重站](https://en.wikipedia.org/wiki/Weigh_station)来确保卡车符合联邦重量法规，对那些没有超重许可却超过限制的卡车进行罚款。

> 联邦规定的最大重量是 80，000 磅。超过联邦重量限制的卡车仍然可以凭借超重许可在该国的高速公路上行驶，但这种许可仅在预定行程之前发放，并在行程结束时到期。超重许可证只发放给不能分解成低于联邦重量限制的较小货物的货物，并且如果除了用卡车运输货物没有其他选择的话。

需要实施重量限制，以便土木工程师对他们建造的道路、桥梁和其他基础设施有一个明确的操作范围。电脑也不例外。这就是许多系统强制执行这些类型的限制的原因。例如，亚马逊明确公布了其简单队列服务的[限制——标准队列的最大传输中消息为 120，000 条，FIFO 队列为 20，000 条。邮件大小限制在 256KB 以内。](http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-limits.html)[亚马逊 Kinesis](http://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html) 、[阿帕奇卡夫卡](https://kafka.apache.org/documentation/)、 [NATS](https://nats.io/documentation/faq/#msgsize) 和[谷歌应用引擎拉队列](https://cloud.google.com/appengine/docs/quotas#Task_Queue)都将消息大小限制在 1MB。这些限制允许系统设计者优化他们的基础设施并改善多租户的一些风险，更不用说它使容量规划变得更加容易。

无限制的*任何东西*——无论是队列、消息大小、查询还是流量——都是弹性工程的反模式。没有明确的限制，事情会以意想不到和不可预测的方式失败。记住，极限是存在的，它们只是被隐藏了。通过使它们显式化，我们限制了故障域，使我们获得了更多的可预测性、更长的平均故障间隔时间和更短的平均恢复时间，但代价是更多的前期工作或稍微多一点的复杂性。

最好是明确地预先处理这些限制，而不是回避问题，让系统以意想不到的方式失败。后者起初看起来工作量较少，但从长远来看会导致更多的问题。通过要求开发人员直接处理这些限制，他们将更彻底地考虑他们的 API 和业务逻辑，并在稳定性、可伸缩性和性能方面设计更好的交互。

### *相关*