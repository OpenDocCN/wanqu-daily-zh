# 内部应用程序:当语义版本没有意义时

> 原文：<https://davehall.com.au/blog/dave/2016/01/19/internal-applications-when-semantic-versioning-doesnt-make-sense?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

语义版本管理(或 SemVer) 对于图书馆和开源应用程序来说是非常棒的。它允许开发团队向用户和下游开发人员传达一个版本中的变更范围。版本控制中最重要的指标之一是向后兼容性(BC)。SemVer 使任何 BC 打破明确。Web 服务和公共 API 是 SemVer 的另一个优秀用例。

尽管我很喜欢公共项目的语义版本化，但我并不确信在内部项目中使用它。

库，无论是内部的还是公开发布的，都应该遵循语义版本规范。这不仅鼓励了库的重用和共享，也显示了对开发人员的良好态度。内部 API 端点也应该符合 SemVer，但是版本端点应该只在版本字符串中公开 major.minor。同样，这将有助于保持与其他开发者的良好关系。

您的应用程序的最终用户可能不会在意您是否放弃 jQuery 而选择直接的 JS，是否将 Apache 换成 nginx，甚至是否升级到 PHP 7/Python 3.x。有些用户会在意您是否移动了一个按钮。他们不会在意底层数据模型和类保持不变，所以这只是一个补丁版本。在这些用户的心目中，按钮移动是一个 BC 中断，因为你改变了他们的 UI。说到底，用户并不关心版本号，他们关心的是特性和 bug 修复。

不管使用什么版本系统，变更都应该记录在变更日志中。changelog 不应该只是一个流入文本文件的 git 提交列表。这个变更日志应该是非技术用户能够理解的。这使得所有的利益相关者可以清楚地看到系统的增量改进。

在我看来，当涉及到这些类型的(网络)应用时，SemVer 就崩溃了。毫无疑问，应用程序的任何外部集成点都应该使用语义版本控制。然而，实际的应用版本应该只是增加。我建议使用基于日期的版本编号，例如 2015 年 12 月 1 日的第一个版本为 201512010。如果需要，同一天的下一个版本将是 201512011，依此类推。如果你每天释放很多次，那么你可能要考虑一个 2 或 3 位数的计数器组件。

组成应用程序的组件，比如库、docker 基本映像、ansible 剧本等等，应该使用 SemVer。如果您引用特定的版本或依赖项，您的构建和测试基础架构应该能够创建完整堆栈的可再现构建。

与其让最终用户理解语义版本，不如把精力花在教用户理解连续交付和部署上。应用程序将会成长和发展，标记发布应该是一个脚本可以做的事情。它不应该需要 5 个人在茶室里试图解决一个功能是否可以进入，因为它可能会被认为是一个 BC 休息。

构建应用程序时，编写代码并让人们使用它。如果他们不满意，继续迭代。