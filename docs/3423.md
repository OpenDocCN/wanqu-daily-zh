# (重写的)错误报告宣言

> 原文：<http://www.drmaciver.com/2013/03/a-rewritten-manifesto-for-error-reporting/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

所以我写了[一份错误报告宣言](https://www.drmaciver.com/2013/03/a-manifesto-for-error-reporting/)。我把它完全袖手旁观化了，但它最终更像是一篇谩骂而不是宣言，它把实现细节和最终结果混在了一起。这篇文章包含了大部分相同的信息，但是少了一些愤怒，希望表达更清晰。

### 宣言

这是一份关于软件应该如何向负责使用该软件的技术人员报告错误的宣言——它主要关注程序员需要的信息，但它也将对运营人员有很大帮助。无论您是在编写一个库还是一个应用程序，这里描述的原则都同样适用。它们不适用于您应该如何向非技术最终用户报告错误。那是一个完全不同的问题。

这主要是关于错误以文本格式表示时是如何出现的——通过某种警报机制或日志。它没有涵盖更高级的工具，如调试器和现场环境。错误的文本报告是跨多种语言的最小公分母，即使您有更好的工具，也很重要。

#### 想想人们会如何调试你的代码

您应该遵循的指导原则是，您报告错误的方式很重要，您应该像在非失败情况下一样仔细考虑如何传达信息。在这一点上，适度的仔细的预先考虑可以防止以后大量的努力和挫折。

特别是，在制作软件时，你应该考虑试图调试问题的人需要什么信息。这些信息主要有三种形式:

1.  具体来说，发生了什么问题？
2.  是什么引发了这个问题？
3.  这个问题发生在代码的什么地方？

如果你牢记这三个问题，并确保提供足够的信息来回答它们，你将大有裨益。以下是一些帮助人们回答这些问题的具体建议。

#### 在你的错误信息中尽可能具体

你的错误信息不应该太长——一句话就足够了。然而，它们应该是描述性的，告诉你发生了什么。

错误消息的一个不好的例子是:

```
Invalid state

```

更好的是:

```
Transaction aborted

```

更好的是:

```
Cannot commit an aborted transaction

```

错误消息不仅仅告诉您状态无效，还会告诉您处于哪种无效状态，以及它阻止您执行什么操作。

#### 错误消息应该包含产生它们的值的相关信息

这不是一个好的错误消息:

```
Index out of range

```

这是:

```
Index 8 is out of range for array of length 7

```

你也可以

```
Index 8 is out of range for array [1,2,3,4,5,6,7]

```

这样做的问题是，如果数组变得非常大，那么错误消息也会变得非常大。因此，虽然错误消息应该包含关于生成它们的值的信息，但它们不需要包含整个值:只需要足够的信息来说明为什么触发了这个错误。

另一个不应该从精确值生成的错误消息是:

```
Failure to process credit card number XXXX XXX XXX XXX

```

即使忽略处理信用卡号码的特定法律，您也不应该像这样记录用户的机密或秘密信息。

因此，错误消息不能总是包含触发它们的完整值是有原因的。也就是说，如果您可以重新创建准确的值，那么重新创建问题会容易得多，因此包含更多而不是更少是一个好的默认设置，您当然应该包含一些。

#### 错误消息应该位于代码中出现错误的位置

在理想的情况下，每个错误消息都会附带一个完整的堆栈跟踪，它准确地描述了到达那里所经历的调用链。如果绝对有必要，并且如果您正在生成好的、有表现力的错误消息，只包含错误发生的文件和行号就足够了，但是这并不完美，并且提供给您的关于问题是如何触发的信息要少得多。

这一点如此重要的原因是，确定问题出现在代码中的什么地方是任何调试过程的首要步骤之一，因此您可以在错误发生时为调试人员节省大量时间和精力。

在大多数语言中，如果您使用异常，默认情况下您会非常接近这一点。在 C 或 C++的 POSIX 系统上，显然也可以用 backtrace 函数来做这件事。

此外，当通过 RPC 机制跨越进程边界时，您应该尽最大努力包括堆栈跟踪:如果远程过程可以合理地报告堆栈跟踪，它应该报告堆栈跟踪，并且您应该将它包括在您的错误报告中。

#### 你不应该掩盖低级错误

将低级错误包装在高级错误中是很常见的。在你调用的代码中改变错误的显示也是很常见的——例如在测试框架中。

当你做这些事情的时候，你必须遵循的黄金法则是你不应该从低级错误中删除信息，因为它们可能是调试问题的开发人员所拥有的关于实际错误的最有用的信息。

特别是，如果您再次抛出异常，您需要采取措施确保包含原始的堆栈跟踪和错误消息(在许多语言中，可以改变您抛出的异常的堆栈跟踪，并且您可以使用它将堆栈跟踪链接在一起)。

此外，您不应该删除堆栈跟踪元素进行显示(例如，可以使用计数器将相邻的行压缩成一行进行重复)。改变显示是可以的，但不能删除信息)。

#### 错误情况不应被掩盖

人们往往倾向于认为，试图掩盖错误并不管不顾地继续工作是代码的责任。有时候这甚至是可行的，也是真实的。然而，有时错误更可能是开发人员错误的迹象，应该尽早解决，即使这不是明显的开发人员错误，也可能是真正出错的征兆。

因此，除非错误情况真的是例行公事(粗略的经验法则是“可以合理地预期一天会发生多次，我们不会对此做任何事情”，否则应该报告。代码可以从错误中恢复并尝试继续运行，但是需要记录错误。即使这不是一个需要解决的问题，它也可能是其他问题的症状。

#### 当您进入无效状态时，应该报告错误，而不仅仅是当您试图在无效状态下操作时

Java 应用程序中最常见的错误之一是 NullPointerException。在 Ruby 中，看到 NameError 或 NoMethodError 同样很常见。

不可避免地，这是因为一个值被允许进入某个不应该被允许的地方。

其他形式的无效状态也是可能的，但它们基本上都归结为同一件事:你的错误不是由你当前正在做的事情引起的，而是由之前发生的事情引起的。您的调试现在必须回溯以找到对象被置于无效状态的点，因为错误出现的位置对您没有任何帮助。

这个问题的解决方案是在状态改变时验证它:如果数据只允许在某个值的范围内，那么在设置或改变它时，检查它是否属于那个值的范围。这意味着问题将在它发生的地方被捕获，而不是在它引起问题的地方被捕获。

#### 概述

总而言之:

1.  想想人们会如何调试你的代码
2.  在你的错误信息中尽可能具体
3.  错误消息应该包含产生它们的值的相关信息
4.  错误消息应该位于代码中出现错误的位置
5.  你不应该掩盖低级错误
6.  错误情况不应被掩盖
7.  当您进入无效状态时，应该报告错误，而不仅仅是当您试图在无效状态下操作时

如果你做了所有这些事情，你的应用程序和库将会更容易调试和维护，那些必须这样做的人将会感谢你。