# 缓存反模式

> 原文：<https://www.hidefsoftware.co.uk/2016/12/25/the-caching-antipattern/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

TL；灾难恢复缓存做得不好会产生不良影响。尽最大努力不缓存数据；但如果你真的必须这么做，确保你做得对。

* * *

> 计算机科学只有两个硬东西:缓存失效和事物命名。
> 
> 菲尔·卡尔顿

## 缓存？

为了确保我们在同一页上，当我说*缓存*时，我指的是通过记住以前的响应并使用它们来屏蔽缓慢的依赖关系，而不是对依赖关系进行另一次缓慢的调用，从而加速您自己的应用程序的实践。

正如 Phil Karlton 在他著名的声音字节中简要提到的，缓存是一个棘手的问题。这些年来，我看到了一些常见的错误，导致了不必要的混乱和延误。

## 常见错误

以下是我看到的一些错误，以及我们应该采取的不同做法。

### 启动时缓存

当你确实知道你的依赖是如此之慢以至于无法使用时，你甚至不会在运行时尝试。在应用程序启动时预先填充一个缓存，而不是查询您的依赖服务，这就是承认您的依赖不符合目的。如果是第三方服务，那么你可能对此无能为力，但这种技术经常被用来避免让你的服务实际上符合目的。

这种缓存的问题在于，它延长了应用程序的启动时间，使得扩展和故障恢复变得困难甚至不可行。

即使您可以接受启动或重启缓慢的服务(这是不应该的),它也会导致与数据性质或服务使用模式无关的缓存。简单的缓存过期策略在这里没有意义，因为这种模式的存在是为了避免再次影响依赖关系。

### 过早缓存

我不是说在请求生命周期中太早，我是说在开发周期中太早。很多次我看到开发者写代码，觉得太慢，把 cache 贴在前面。

从这一点上，他们的服务是缓慢的事实是隐藏的。没有理由优化或改进解决方案，因为缓存将确保第二次请求更快；所以为什么要担心，对吗？

### 集成缓存

SOLID 中的 S 是什么？单一责任。如果您的缓存功能直接集成到您的服务层中，没有它您就无法运行，那么您肯定违反了这个原则。我无权在此宣扬这一原则的优点。

### 缓存所有内容

盲目地将缓存应用于每个外部调用以确保响应，而没有考虑其含义。更糟糕的是，这种方法可能导致开发人员和操作人员甚至不知道缓存正在发生，并对底层服务的可靠性做出根本不真实的假设。

### 到达

缓存所有内容，甚至缓存大量内容，都会导致缓存缓存缓存缓存缓存缓存。

一方面，这可能会导致所有内部缓存在最前端缓存之前不久过期，从而浪费大量时间和资源来操作从不使用的缓存层。

另一方面，它可以有效地合计所有相关缓存的缓存过期时间，因此 10 层 30 分钟的缓存可以导致系统提供 5 小时前的数据。*那个*反直觉怎么样？

### 不可刷新的缓存

偶尔，缓存实现可能会回到 Redis 这样的数据存储上，Redis 有管理工具，可用于按需刷新缓存。

其他实现，比如内存缓存中的手摇曲柄，甚至主流框架提供的缓存都不会公开任何缓存管理工具。这给 ops 留下了唯一的选择，即重新启动服务来刷新内存。(或者更糟，对缓存实现有足够的了解，以便找到它在文件系统中的位置，并手动清除它。)

我曾经看到过这样的情况，当团队的不同成员试图跟踪一个又一个缓存、重启刷新缓存或者等待缓存到期后再进入下一层时，发布会花费的时间超过了必要的时间。因为系统不能说是独立存在的。

## 暗示

缓存数据具有这些错误会加重的含义，以及我们以前没有想到的新问题。

当您等待缓存过期或不得不破坏您能找到的每个缓存时，部署到大量缓存的系统会非常耗时。即使在我工作过的一些 cdn 这样的系统中，它们为互联网的百分之十提供流量，并被认为是内容交付的领导者，在全球范围内刷新内容和配置缓存可能需要长达两个小时。事实并非如此([很快](https://www.fastly.com/products/instant-purging)可以在 150 毫秒内清空缓存)，这导致了混乱(新数据已经提供了吗？).

自然的反应是想出一个变通办法，通常是一些缓存破坏。让我们好好想想。解决您刚刚实现的功能的方法。考虑一下时间、精力和认知负荷，以补偿你刚花在缓存上的时间、精力和认知负荷。

调试一个缓存的系统也成为一个挑战，因为在一个棘手的调试会话中陷入困境将会导致不相关的事情被错过或忘记。三个小时的困惑之后，你意识到你实际上并没有测试你所做的任何改变。

## 我们应该做什么

### 不要缓存！

好吧，有时候缓存是你唯一的选择。你在网上，不管你喜不喜欢，它都在发生。但即使在这种情况下，除了简单地拍打`Cache-Control: max-age=xxx`还有其他选择。

### 了解您的数据

你至少应该知道你的数据最后一次被修改是什么时候。现在你可以使用`If-Modified-Since`标题了。如果数据没有改变，返回 304-未修改。现在，您可以智能地利用客户端的缓存功能，而不会牺牲可见性和控制力。使用这个标题可以让你立即提供新的内容，也可以无限期地缓存。两全其美。更进一步，如果您能够对您的数据进行版本化(或者只是生成您的响应的散列)，您可以利用 [etags](https://en.wikipedia.org/wiki/HTTP_ETag) ，并且仍然与客户端进行交互并应用适当的逻辑，而没有与数据传输相关的延迟。

### 优化性能，不要隐藏糟糕的性能

投资于分析器工具。找出你的应用程序运行缓慢的原因并解决它。减少重复的执行路径。整理出不好的查询执行计划。正确使用索引。如果您使用 S3 或 blob 存储您的数据，您总是可以使用 Redis 或类似工具构建自己的索引。Redis 不仅仅是一个缓存。您可以明智地使用它，并获得许多好处，而没有缓存带来的问题。

## 结局

缓存是一种有用的工具，但是很容易被滥用，而且不会留下任何滥用的迹象。

不到最后一刻，不要参与缓存；先找到其他方法。在使用笨拙的缓存工具之前，优化您的应用程序。

如果您遇到了任何由缓存和不良纪律引起的基本问题，请告诉我，我可以将它们添加到列表中。