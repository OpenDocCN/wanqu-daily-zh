# Python 3 存在的原因

> 原文:[http://www.snarky.ca/why-python-3-exists?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://www.snarky.ca/why-python-3-exists?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

这个月我邀请了 PuPPy 的 [Q & A(普吉特湾 Python 用户组)，这最终让我解释了为什么 Python 3 会出现以及整个字符串/字节交易。我的解释最终得到了称赞，这让我有些吃惊，因为我天真地以为人们已经知道为什么 Python 3 会被创造出来。事后看来，我很愚蠢地认为大多数人，不管是新的还是老的，都会被告知或者被好奇心驱使去寻找并找到一个解释。所以这篇博客文章旨在简单地解释为什么 Python 3 存在，特别是为什么我们选择进行整个向后不兼容的`unicode` / `str` / `bytes`改变，因为这是将代码移植到 Python 3 中真正棘手的部分。](https://youtu.be/2XviXtxWKO8?list=PL4S0lvhXvdhIV2C28Ia_DeIeloBrsQBOW)

# Python 2 中的文本和二进制数据乱七八糟

快，下面的文字在语义上代表什么？

```
'abcd' 
```

如果您是 Python 3 用户，您会说它是由字母“a”、“b”、“c”和“d”按顺序组成的字符串。

如果您是 Python 2 用户，您可能会说同样的话。你可能也说过它是代表 97、98、99 和 100 的字节。事实上，对于`str`对象所代表的内容，Python 2 中有两个正确答案，这导致了语言的改变，因此 Python 3 中的一个答案是唯一的答案。

Python 的[禅说“应该有一种——最好只有一种——显而易见的方式去做”。语言中的文字可以表示文本数据或二进制数据，这是一个问题。例如，如果你从网络上读取某个东西，你必须非常小心，要么说你返回的`str`对象是二进制数据，要么说是文本数据，因为一旦对象脱离了你的控制，就没有办法知道了。或者您的代码中可能有一个 bug，您本打算将那个`str`对象转换成文本数据——或者其他完全不同的东西——但是您搞砸了，意外地跳过了这一步。由于`str`对象可能代表两种不同的语义类型，所以很难注意到这种错误是何时发生的。](https://www.python.org/dev/peps/pep-0020/)

现在，您可能会试图争辩说，如果您避免使用`str`类型的文本数据，而是依赖于`unicode`类型的文本数据，那么这些问题在 Python 2 中都是可以解决的。虽然这是绝对正确的，但人们在实践中并不这样做。要么人们变得懒惰，不想麻烦解码成 Unicode，因为这是额外的工作，要么人们渴望性能，并试图避免解码的成本。不管是哪种方式，都是假设你会写得足够好，不会出错，我们都知道我们是会犯错的人，事实上并不完美。如果人们希望在 Python 2 中编写无 bug 代码的愿望真的实现了，那么我就不会一直听到几乎每个将项目移植到 Python 3 的人说他们在代码中发现了关于文本和二进制数据编码和解码的潜在 bug。

这一点避免 bug 是人们忘记的一件大事。语言的简化和对一个`str`对象可能代表的含义的去除使得代码更不容易出错。Python 的禅宗指出“显式比隐式好”是有原因的:不容易沟通的代码的歧义和隐式知识容易出错，导致 bug。通过迫使开发人员明确地将他们的二进制数据和文本数据分开，可以产生更好的代码，减少出现某类错误的机会。

# 世界上的其他地方已经全押在 Unicode 上了(理由很充分)

人们有时会忘记 Python 有多老；Guido 于 1989 年 12 月开始编写 Python 代码，并于 1991 年 2 月首次作为开源代码发布。这意味着 Python 本身早于 1991 年 10 月发布的第一卷 Unicode 标准。在此期间，Unicode 标准化后创建的语言选择基于支持 Unicode 的编码来实现字符串。这使 Python 2 陷入了一个不幸的境地，在 2004 年(Python 3 计划开始时)它获得了巨大的支持，但它对 Unicode 文本的支持可以说是最弱的，因为`unicode`类型完全是可选的，人们并没有将它用于所有的文本数据。

支持 Unicode 和任何书面语言的文本都很重要。Python 是面向全世界的语言，而不仅仅是那些支持 ASCII 所涵盖的罗马字母表的语言。这就是为什么 Python 3 在处理文本时会让它变成“Unicode 或 bust”；它保证所有的 Python 3 代码将支持世界上的每个人，无论编写代码的开发人员是否明确表示支持。在 Python 2 中，花时间正确支持文本数据的`unicode`类型的项目和没有花时间支持文本数据的项目之间存在分歧；在 Python 3 中没有这样的分裂，支持所有语言都是免费的。

# 我们认为 Python 会越来越受欢迎

2004 年，我们启动了 [PEP 3100](https://www.python.org/dev/peps/pep-3100/) ，并由此开始设计 Python 3(旁白:PEP 最初编号为 3000，但我们将其重新编号为 3100，因此编号为 3000 的 [PEP 将成为我们如何处理 Python 3 开发的 PEP)。我们知道 Python 的受欢迎程度呈上升趋势，我们希望它能继续增长(幸好有☺).但这也意味着，如果我们要修复任何设计错误，并帮助语言继续流行，我们需要现在就做，而不是以后。我们假设在足够长的时间内，用 Python 3 编写的代码会比用 Python 2 编写的多，假设我们没有搞坏 Python 3，因为它会比 Python 2 持续更长时间，而且一旦 Python 2.7 只用于遗留项目而不是新项目，它会被更多地使用。所以我们决定承受 Python 2/3 过渡的痛苦，在这个假设下创造了 Python 3。显然，要看世界上的 Python 3 代码在代码行数方面是否超过 Python 2 代码，还需要几十年的时间。](https://www.python.org/dev/peps/pep-3000/)

# 我们再也不会做这种向后不兼容的改变了

我们作为一个团队已经决定，像`unicode` / `str` / `bytes`这样大的变化再也不会如此突然地发生了。当我们开始开发 Python 3 时，我们认为/希望社区会像 Python 那样做，做最后一个支持 Python 2 的功能发布，然后切换到 Python 3 开发进行功能开发，同时只为 Python 2 版本做错误修复发布。这显然没有发生，我们已经吸取了教训。此外，我们看不出这种语言的基础设计有任何不足之处，可以证明有必要做出如此重大的改变。因此，除了从标准库中删除可能被否决的模块，Python 4 不会做任何更极端的事情。

# 结论

这就是为什么 Python 3 是这样的。我们意识到，由于在 Python 2 中对`str`类型的过度使用，人们一直存在一些错误，因此我们在 Python 3 中通过明确地将文本数据与二进制数据分开来修复这些错误。通过使所有文本数据自动支持 Unicode，项目突然变得更容易使用多种语言，这也很有帮助。我们做了改变，因为我们觉得越快越好。我们构建了这个过渡，认为社区将会和我们一起留下 Python 2，但事实证明并非如此，相反我们花费了更多的时间，并使用 Python 2/3 兼容的语言子集来管理这个过渡。