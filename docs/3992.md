# 模块与微服务–O ' Reilly

> 原文：<https://www.oreilly.com/ideas/modules-vs-microservices?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

关于从单片服务器转向微服务，已经说了很多。除了很好地滚动舌头之外，将一个整体分割成微服务似乎也是一件很容易的事情。但是这种方法真的是您的组织的最佳选择吗？维护一个混乱的整体应用程序确实有很多缺点。但是有一个引人注目的替代方案经常被忽视:模块化应用程序开发。在本文中，我们将探索这种替代方案需要什么，并展示它与构建微服务的关系。

## 模块化的微服务

“有了微服务，我们终于可以让团队独立工作了”，或者“我们的整体太复杂了，这减慢了我们的速度。”这些表述只是导致开发团队走上微服务道路的众多原因中的一部分。另一个是对可伸缩性和弹性的需求。开发人员共同渴望的是系统设计和开发的模块化方法。软件开发中的模块化可以归结为三个指导原则:

## 学得更快。深入挖掘。看得更远。

*   **强封装**:将实现细节隐藏在组件内部，导致不同部分之间低耦合。团队可以在系统的分离部分独立工作。
*   **定义良好的接口**:你不能隐藏一切(否则你的系统不会做任何有意义的事情)，所以组件之间定义良好且稳定的 API 是必须的。组件可以被任何符合接口规范的实现所替代。
*   **显式依赖**:拥有模块化系统意味着不同的组件必须协同工作。你最好有一个好的方式来表达(和验证)他们的关系。

这些原则很多都可以用微服务来实现。微服务可以以任何方式实现，只要它为其他服务公开一个定义良好的接口(通常是 REST API)。其实现细节是服务内部的，可以在没有系统范围影响或协调的情况下更改。微服务之间的依赖关系在开发时通常不太明确，这可能导致运行时服务编排失败。我们只能说，这最后一个模块化原则可以在大多数微服务架构中使用一些爱。

因此，微服务实现了重要的模块化原则，带来了切实的好处:

*   团队可以独立工作和扩展。
*   微服务小而专注，降低了复杂性。
*   服务可以在内部更改或替换，而不会产生全局影响。

不喜欢什么？嗯，在这个过程中，你已经从一个单一的(虽然有点胖)应用程序发展到一个分布式的微服务系统。这给桌面带来了巨大的操作复杂性。突然，您需要不断地部署许多不同的(可能是容器化的)服务。新的问题出现了:服务发现、分布式日志记录、跟踪等等。你现在更容易陷入分布式计算的谬误。界面的版本控制和配置管理成为主要关注点。这个清单还在继续。

事实证明，微服务之间的连接与所有单个微服务的组合业务逻辑一样复杂。要到达这里，你不能只是拿起你的巨石，把它切碎。整体代码库中的“意大利面条式代码”是有问题的，而在两者之间放置一个网络边界会将这些纠缠问题升级为彻头彻尾的痛苦。

## 模块化备选方案

这是否意味着我们要么被归入凌乱的整体，要么必须淹没在微服务疯狂的复杂性中？模块化也可以通过其他方式实现。重要的是，我们可以在开发过程中有效地划定和执行边界。但是我们也可以通过制造一个结构良好的整体来达到这个目的。当然，这意味着接受我们可以从编程语言和开发工具中获得的任何帮助，以执行模块化原则。

例如，在 Java 中，有几个模块系统可以帮助构建应用程序。OSGi 是最著名的一个，但是随着 Java 9 的发布，Java 平台本身增加了一个本地模块系统。模块现在是语言和平台的一部分，是一级构造。Java 模块可以表达对其他模块的依赖，并在强烈封装实现类的同时公开导出接口。甚至 Java 平台本身(一个巨大的代码库)也使用新的 Java 模块系统进行了模块化。你可以在我即将出版的新书《Java 9 模块化中了解更多关于 Java 9 模块化开发的知识，这本书现在已经有了早期版本。

其他语言也提供了类似的机制。例如，JavaScript 从 ES2015 开始有了一个[模块系统](http://exploringjs.com/es6/ch_modules.html)。在此之前，Node.js 已经为 JavaScript 后端提供了一个非标准的模块系统。然而，作为一种动态语言，JavaScript 对模块间强制接口(类型)和封装的支持较弱。您可以考虑在 JavaScript 之上使用 TypeScript 来再次获得这一优势。微软的。Net Framework 确实像 Java 一样具有强类型，但在强封装和程序集之间的显式依赖方面，它没有 Java 即将推出的模块系统的直接等价物。然而，一个好的模块化架构可以通过使用[中标准化的控制反转模式来实现。Net Core](https://msdn.microsoft.com/en-us/magazine/mt707534.aspx) 并通过创建逻辑上相关的程序集。甚至 C++也在[考虑在未来的版本中增加模块系统](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4610.pdf)。许多语言越来越喜欢模块化，这本身就是一个惊人的发展。

当您有意识地努力使用您的开发平台的模块化特性时，您可以获得我们之前归因于微服务的相同的模块化优势。本质上，模块系统越好，你在开发过程中得到的帮助就越多。不同的团队可以处理不同的部分，其中只有定义良好的接口才是团队之间的接触点。尽管如此，在部署时，这些模块聚集在一个部署单元中。通过这种方式，您可以避免与迁移到微服务开发和管理相关的大量复杂性和成本。没错，这意味着你不能在不同的技术堆栈上构建每个模块。但是你的组织真的准备好了吗？

## 设计模块

创建好的模块需要与创建好的微服务相同的设计严谨性。一个模块应该建模(部分)一个单一的有界域上下文。选择微服务边界是一个在架构上非常重要的决策，如果做错了，将会产生昂贵的后果。模块化应用程序中的模块边界更容易改变。跨模块重构通常由类型系统和编译器支持。重新划分微服务边界涉及到大量的人际交流，以避免在运行时发生意外。老实说，你第一次，甚至第二次，有多少次把你的界限划对了？

在许多方面，静态类型语言中的模块为定义良好的接口提供了更好的结构。与在另一个微服务上调用 REST 端点相比，通过由另一个模块公开的类型化接口调用一个方法更能抵御变化。REST+JSON 无处不在，但是在缺乏(编译器检查的)模式的情况下，它不是良好类型互操作性的标志。此外，遍历网络(包括序列化的解序列化)仍然不是免费的，这种情况变得更加暗淡。更重要的是，许多模块系统允许你表达你对其他模块的依赖。当违反这些依赖关系时，模块系统不会允许。微服务之间的依赖关系只有在运行时才会具体化，导致系统难以调试。

模块也是代码所有权的自然单位。团队可以负责系统中的一个或多个模块。唯一和其他团队共享的就是他们模块的公共 API。在运行时，与微服务相比，模块之间的隔离更少。毕竟，一切仍在相同的过程中运行。

没有理由为什么 monolith 中的一个模块不能像一个好的微服务那样拥有自己的数据。然后，模块化应用程序内的共享通过模块间定义良好的接口或消息发生，而不是通过共享的数据存储。微服务的最大区别在于，一切都在过程中进行。不应该低估最终的一致性问题。对于模块，最终的一致性可能是一个深思熟虑的战略选择。或者，您可以只是“逻辑地”分离数据，同时将它们存储在同一个数据存储中，并且仍然暂时使用跨域事务。对于微服务，没有选择:最终的一致性是已知的，您需要适应。

## 微服务何时适合您的组织？

那么什么时候应该转向微服务呢？到目前为止，我们主要关注通过模块化来解决复杂性。为此，微服务和模块化应用都可以。但是，除了目前已经解决的挑战之外，还有不同的挑战。

当您的组织处于谷歌或网飞的规模时，采用微服务是完全有意义的。您有能力构建自己的平台和工具包，而工程师的数量限制了任何合理的单一方法。但是大部分组织都没有这种规模的运营。即使你认为你的组织有一天会成为十亿美元的独角兽，从模块化的整体开始也不会有太大的伤害。

另一个提升独立微服务的好理由是，如果不同的服务天生更适合不同的技术堆栈。此外，您必须有足够的规模来吸引这些不同平台的人才，并保持这些平台的正常运行。

微服务还支持系统不同部分的独立部署，这在大多数模块化平台中是比较困难的(甚至是不可能的)。隔离部署增加了系统的弹性和容错能力。此外，每个微服务的扩展特性可能不同。不同的微服务可以部署到匹配的硬件上。模块化的整体也可以水平扩展，但是你可以一起扩展所有的模块。这可能并不总是最好的结果，尽管在实践中，你可以用这种方法走得很远。

## 结论

一如既往，最好的选择是找到一个中间地带。这两种方法都有用武之地，哪种方法更好取决于环境、组织和应用程序本身。为什么不从模块化应用开始呢？您可以随时选择以后迁移到微服务。然后，你已经有了合理的模块边界，而不是像外科手术一样解开你的整体。这甚至不是唯一的选择:您还可以使用模块在内部构建微服务。那么问题就变成了，为什么微服务一定要‘微’呢？

即使您确实脱离了单一的模块化应用程序，您的服务也不必为了可维护性而变得很小。同样，在服务中应用模块化原则允许它们在复杂性上扩展，超出您通常认为的微服务。在这幅图中，模块和微服务都有一席之地。通过减少架构中的服务数量，可以实现真正的成本节约。模块可以帮助构建和扩展服务，就像它们可以帮助构建单个整体应用程序一样。

如果你追求模块化的好处，请确保不要欺骗自己进入只提供微服务的思维模式。探索您最喜欢的技术堆栈的进程内模块化特性或框架。您将获得支持来实施模块化设计，而不是仅仅依靠惯例来避免杂乱无章的代码。然后，慎重选择是否要招致微服务的复杂度惩罚。有时你不得不这样做，但通常，你可以找到更好的前进方式。

<aside class="post-note post-note-end">

阅读“[微服务:快速简单的定义](https://www.oreilly.com/ideas/a-quick-and-simple-definition-of-microservices)”了解微服务和推荐资源的基本概述。

</aside>