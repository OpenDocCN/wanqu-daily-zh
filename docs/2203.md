# 我们如何如此频繁地发布-天空博彩和游戏技术

> 原文:[http://engineering . skybettingandgaming . com/2016/02/02/how-we-release-so-frequency/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://engineering.skybettingandgaming.com/2016/02/02/how-we-release-so-frequently/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

在 Sky Betting & Gaming，我们每天发布几次新版本的代码，没有计划内停机。我们的生产环境是巨大的和多样的，但是我想把重点放在我们如何把软件发布到我们的灯状堆栈上。我之所以说“LAMP-like ”,是因为尽管几年前我们还在使用传统的 LAMP 堆栈，但随着需求的增加，我们已经添加了其他技术:比如 Redis、Node.js 和 MongoDB。尽管在其核心，仍然有运行 Apache 和`mod_php`的服务器，与各种数据存储和 API 对话。

我们的发布过程看起来有点像这样:

*   构建一个发布包，并对其进行测试
*   该包被复制到 NFS 共享
*   数据库迁移正在运行
*   Apache docroot 自动切换到新的包

所有这一切只需点击 Jenkins UI 中的一个按钮，耗时约 10 分钟:其中大部分时间用于运行测试。我们有很多测试:单元测试、集成测试和全栈测试都以他们自己的方式提供价值，所以我们有很多。如果按顺序运行，它们将需要一个多小时才能运行，因此我们将它们分成更小的块，并在十几个左右的 Jenkins slaves 上并行运行。

如果这听起来不令人印象深刻，那是因为它不是。速度方面还有很大的提升空间(你真的有足够多的詹金斯奴隶吗？)，当然，拥有一个合理快速的构建过程可以大大有助于更频繁的发布，但这不是全部。

我们经常发布的主要原因是惯例。

## 仅向前迁移

我们不回滚数据库迁移。永远不会。从技术上来说，我们可以做到，但至少四年来，我们没有必要这样做。这是因为我们做的每一次数据库迁移都会产生一个与新版本代码*和旧版本代码*兼容的模式。如果我们不得不回滚一个代码发布(有时*会发生*)，那么之前的版本完全可以使用新版本的模式。

我们如何实现这一点，不是靠什么神奇的技术解决方案，而是纯粹靠惯例。以删除一列为例；你如何释放这种变化？简单:

*   发布不使用该列的代码版本；确保它是稳定的/不会回滚。
*   进行第二次发布，进行迁移以删除该列。

真的就这么简单。删除表的工作方式相同:在一个版本中停止使用它，在下一个版本中删除它。

然而，并不是所有的改变都那么简单。如果我们想要重命名一个列，我们很可能需要:

*   一个以新名称添加新列的版本，更改代码以写入两列，但仍从旧列中读取
*   将数据从旧列复制到新列的批处理作业，一次一行，以避免过多的锁定
*   只对新列进行读写的释放
*   删除旧列的发布

三个独立的版本和一个重命名列的批处理工作听起来工作量很大，但这不是我们必须经常做的事情，而且它让我们对回滚每个版本更有信心。

## 新代码！=新功能

客户永远不会注意到代码的发布，除非性能有显著的提高。对于客户来说，看到一个新特性出现，开始使用它，然后几分钟后随着一个版本的回滚它就消失了——可能是出于不相关的原因，这是一个非常糟糕的体验。

每一个新特性都是以隐藏状态发布的，随时可以通过“特性切换”打开。可以在每个会话中启用功能切换，从而在客户看到新功能之前，就可以在真实环境中对其进行全面测试。这种方法有一些真正强大的优点:

*   我们不需要仅仅因为一个新特性不工作就回滚整个版本(可能包含几个变更)
*   我们可以在拥有所需硬件、软件和数据的环境中全面测试新功能
*   我们可以逐渐向客户发布新功能

最后一点非常重要。如果我们不确定一个新特性是否能承受所有客户的压力，我们可以先向一小部分客户发布，然后监控它的性能。

我们为每个新会话分配一个 1 到 100 之间的随机数，并将其存储在一个长期 cookie 中；使用该号码将会话分成组。例如，如果我们有:

*   `1-10: risky-new-feature`
*   `11-100: control`

那么大约 10%的会话会得到`risky-new-feature`，其余的不会有变化。如果一切正常，我们可能会改变分级，使 50%的会话改为获得`risky-new-feature`；稍后——当我们*真的*确信一切都好的时候——把它转换到 100%。

不过，让一个新特性在现有会话中中途出现仍然会很不和谐，所以我们使用另一个技巧来使事情变得平稳。除了存储随机数的长期 cookie 之外，我们还使用会话 cookie 将人们“粘”到他们的会话开始时定义的组中。

如果会话是全新的，那么我们:

*   给它分配一个随机数，并将其存储在一个长期 cookie 中
*   看看有哪些组符合这个数字
*   将这些组存储在会话 cookie 中

对于该会话中的所有后续请求，我们将继续尊重这些相同的组，即使我们更改了分级，使随机数不再属于该组。一旦用户的会话过期，会话 cookie 就会消失；因此，只有随机数 cookie 将出现在任何未来的请求中。那些只有随机数 cookie 的请求遵循和以前一样的过程，除了我们没有分配一个新的随机数。

所有这一切的结果是，客户在一次会话中不会看到不和谐的功能变化，他们很可能会在下次会话时看到相同的功能。

## 小规模释放

随着快速的构建、大量的测试、风险更低的数据库迁移，以及从代码发布中分离出来的特性变化:我们经常发布代码并没有太大的障碍，但是这里有一个反馈环可以进一步帮助我们:我们发布得越频繁，发布的版本就越小。较小的版本风险更小，让我们可以更频繁地发布。频繁的发布并不一定意味着小规模的发布——它仍然需要一点惯例。

我们的开发发生在 git 特性分支中，从技术上来说，没有什么可以阻止我们拥有非常长寿的特性分支，从而导致非常大的——因此也是有风险的——发布。我们需要的是发布代码的纪律，不是在*完成*的时候，而是在*不会破坏任何东西*的时候。一开始可能会觉得不自然，但它可以大大减少许多人感到的“释放焦虑”。

当你开始更频繁地释放时，发生的另一件事是，你开始更多地感受到释放过程中的任何小痛点。一个月只执行一次的手工过程是大多数人只会苦笑和忍受的；但是当一天几次的时候:就没那么多了。所有那些你此刻刚刚忍受的琐碎的小问题将开始变成大问题——这是一件好事:大问题得到优先处理和解决。

这听起来是显而易见的，但是更经常地做一些事情是一个更好的方法。