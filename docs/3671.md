# 高效存储:我们如何从 50 PB 降至 32 PB -高可扩展性-

> 原文：<http://highscalability.com/blog/2017/1/2/efficient-storage-how-we-went-down-from-50-pb-to-32-pb.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

# ![](img/16d73e2bc29d60cb0e1a909ce87101e4.png)

两年前，俄罗斯卢布汇率暴跌，促使我们考虑削减邮件的硬件和托管成本。Ru 电子邮件服务。为了找到省钱的方法，让我们先来看看电子邮件由什么组成。

索引和主体只占存储大小的 15%，而文件占了 85%。因此，文件(即附件)在优化方面值得更深入地研究。当时，我们还没有文件重复数据消除，但我们估计它可以将总存储大小缩减 36%，因为许多用户会收到相同的消息，例如来自在线商店的价目表或来自社交网络的包含图像的时事通讯等。在本文中，我将描述我们如何在 [Albert Galimov](https://medium.com/u/35d63790111) 的监督下实施重复数据删除系统。

### 元数据存储

我们正在处理一个文件流，我们需要快速识别一个副本。一个简单的解决方案是根据文件的内容来命名文件。为此，我们使用了 SHA-1。文件的初始名称存储在电子邮件本身中，因此我们不需要担心它。

一旦新邮件到达，我们检索文件，计算它们的散列值，并将结果添加到邮件中。这是一个必要的步骤，以便能够在我们将来发送电子邮件时，轻松地找到属于特定电子邮件的文件。

现在，让我们将一个文件上传到我们的存储器，并检查是否已经存在另一个具有相同散列的文件。这意味着我们需要在内存中存储所有的哈希值。让我们把这个散列存储称为 FileDB 。

同一个文件可以附加到不同的电子邮件，所以我们需要一个计数器来跟踪所有包含这个文件的电子邮件。

计数器随着每个新上传的文件而递增。大约 40%的文件被删除，因此如果用户删除了包含上传到云的文件的电子邮件，计数器必须递减。如果它达到零，文件可以被删除。

这里我们面临第一个问题:关于电子邮件的信息(索引)存储在一个系统中，而关于文件的信息存储在另一个系统中。这可能会导致错误，例如，考虑以下工作流:

1.  系统收到删除电子邮件的请求。
2.  系统检查电子邮件索引。
3.  系统可以看到有一个附件(SHA-1)。
4.  系统发送删除文件的请求。
5.  发生崩溃，所以电子邮件不会被删除。

在这种情况下，电子邮件会保留在系统中，但计数器会减一。当系统收到第二个删除此电子邮件的请求时，计数器再次递减，我们可能会遇到以下情况:文件仍然附加到电子邮件，但计数器已经为零。

不丢失数据至关重要。我们不能有这样的情况，用户打开电子邮件，发现没有附件。也就是说，在磁盘上存储一些冗余文件没什么大不了的。我们所需要的是一种机制，它明确地决定计数器是否被正确地设置为零。这就是为什么我们多了一个领域——*魔法*。

算法很简单。除了文件的哈希，我们还在电子邮件中存储了一个随机生成的数字。所有上传或删除文件的请求都考虑这个随机数:在上传请求的情况下，这个数被加到幻数的当前值上；如果是删除请求，这个随机数将从幻数的当前值中减去。

因此，如果所有电子邮件都将计数器递增和递减了正确的次数，则幻数也将等于零。否则，不得删除该文件。

让我们考虑一个例子。我们有一个名为 sha1 的文件。上传一次，邮件为其生成一个随机(魔)数，等于 345。

然后一封新的电子邮件带着同样的文件到达。它生成自己的幻数(123)并上传文件。新的幻数被加到幻数的当前值上(345)，并且计数器增加 1。因此，我们现在在 FileDB 中拥有的是值为 468 且计数器设置为 2 的幻数。

在用户删除第二封电子邮件之后，从幻数的当前值中减去为该电子邮件生成的幻数(468)，并且计数器减 1。

我们先来看看事情的正常发展过程。用户删除了第一封邮件，幻数和计数器都变为零。表示数据一致，文件可以删除。

现在，假设出现了问题:第二封电子邮件发送了两个删除请求。计数器等于零意味着不再有指向该文件的链接，但是这个幻数(等于 222)表明了一个问题:在数据一致之前，不能删除该文件。

让我们把情况再发展一点。假设第一封邮件也被删除了。在这种情况下，幻数(-123)仍然表示不一致。

作为一种安全措施，一旦计数器变为零，但幻数不变(在我们的例子中，幻数是 222，计数器为零)，文件被赋予*不要删除*标志。这样，即使在一系列删除和上传之后，幻数和计数器不知何故都变为零，我们仍然知道这个文件有问题，不能删除。

现在回到 FileDB。每个实体都有一组标志。无论您是否打算使用它们，您都将需要它们(例如，如果一个文件需要被标记为不可删除)。

我们有所有的文件属性，除了它的物理位置。这个地方由一个服务器(IP)和一个磁盘来标识。应该有两个这样的服务器和两个这样的磁盘。

但是一个磁盘存储大量文件(在我们的例子中，大约有 1，000，000 个)，这意味着这些记录将由 FileDB 中的同一个磁盘对来标识，因此将这些信息存储在 FileDB 中是一种浪费。让我们将它放入一个单独的表中， *PairDB* ，通过一个磁盘对 ID 链接到 FileDB。

不言而喻，除了磁盘对 ID，我们还需要一个*标志*字段。我将向前跳一点，提到这个字段表示磁盘是否被锁定(比如，一个磁盘崩溃，另一个正在被复制，因此没有新数据可以写入其中任何一个)。

此外，我们需要知道每个磁盘有多少空闲空间——因此需要相应的字段。

为了确保一切快速运行，FileDB 和 PairDB 都必须驻留在 RAM 中。我们使用的是 Tarantool 1.5，但现在应该使用最新版本。FileDB 有五个字段(20、4、4、4 和 4 字节长)，总计 36 个字节。此外，每条记录都有一个 16 字节的头，每个字段还有一个 1 字节长的指针，这使得总记录大小达到 57 字节。

Tarantool 允许指定最小分配大小，因此与内存相关的开销可以保持接近于零。我们将分配一条记录所需的精确内存量。我们有 120 亿份文件。

(57 * 12 * 10°)= 637 GB

但这还不是全部，我们还需要 sha1 字段上的索引，这为总记录大小增加了 12 个字节。

(12 * 12 * 10°)= 179 GB

总而言之，需要 800 GB 的内存。但是我们不要忘记复制，它需要双倍的内存。

如果我们购买 256 GB 内存的机器，我们将需要 8 个。

我们可以评估 PairDB 的大小。平均文件大小为 1 MB，磁盘容量为 1 TB，这允许在单个磁盘上存储大约 1，000，000 个文件，因此我们需要大约 28，000 个磁盘。一条 PairDB 记录描述两个磁盘。因此，PairDB 包含 14，000 条记录—与 FileDB 相比可以忽略不计。

### 文件上传

现在我们已经了解了数据库结构，让我们转向与系统交互的 API。乍一看，我们需要*上传*和*删除*方法。但是不要忘记重复数据删除:我们尝试上传的文件很可能已经在存储中，再次上传没有意义。所以，以下方法是必要的:

*   inc(sha1，magic) —递增计数器。如果文件不存在，则返回错误。让我们回想一下，我们还需要一个幻数来帮助防止不正确的文件删除。
*   upload(sha1，magic) —如果 inc 返回一个错误，则应调用该函数，这意味着该文件不存在，必须上传。
*   dec(sha1，magic) —当用户删除一封邮件时调用。计数器首先递减。
*   GET /sha1 —通过 HTTP 下载文件。

让我们仔细看看上传过程中发生了什么。对于实现这个接口的守护进程，我们选择了 IProto 协议。守护进程必须能够很好地扩展到任意数量的机器，所以它们不存储状态。假设我们通过套接字接收到一个请求:

命令名告诉我们头的长度，所以我们先读取头。现在，我们需要知道 origin-len 文件的长度。需要选择几个服务器来上传。我们只需从 PairDB 中检索所有记录(几千条),并使用标准算法来查找所需的对:取一个长度等于所有对上的空闲空间之和的段，在该段上随机选取一个点，并选择该点所属的任何对。

但是，这样选择一对是有风险的。假设我们所有的磁盘都是 90%满的，然后我们添加一个新的空磁盘。很有可能所有的新文件都会上传到这个磁盘上。为了避免这个问题，我们不应该对一个磁盘对的自由空间求和，而应该对这个自由空间的 n 次方根求和。

因此，我们选择了一对，但我们的守护程序是一个流守护程序，如果我们开始将文件上传到存储，就没有回头路了。也就是说，在上传真实文件之前，我们先上传一个小的测试文件。如果测试上传成功，我们从 socket 读取 filecontent 并上传到存储；否则，选择另一对。SHA-1 哈希可以动态读取，因此在上传过程中也会进行检查。

现在让我们检查从加载器到所选磁盘对的文件上传。在包含磁盘的机器上，我们设置 Nginx 并使用 WebDAV 协议。一封邮件到了。FileDB 还没有这个文件，所以需要通过加载器上传到磁盘对。

但是没有什么可以阻止另一个用户接收相同的电子邮件:假设指定了两个收件人。请记住，FileDB 还没有这个文件，所以还有一个加载程序将会上传这个文件，并且可能会选择相同的磁盘对进行上传。

Nginx 可能会正确解决这种情况，但是我们需要控制整个过程，所以我们用一个复杂的名称保存文件。

名称中红色的部分是每个加载程序放入一个随机数的地方。因此，这两个 PUT 方法不会重叠并上传两个不同的文件。一旦 Nginx 以 201 (OK)响应，第一个加载器就执行原子移动操作，这指定了文件的最终名称。

当第二个加载程序完成文件的上传并执行 MOVE 时，文件将被覆盖，但这没什么大不了的，因为文件是同一个文件。一旦文件在磁盘上，需要向 FileDB 添加一条新记录。我们这个版本的 Tarantool 分为两个空间。到目前为止，我们只使用了 *space0* 。

然而，我们不是简单地向 FileDB 添加一条新记录，而是使用一个存储过程来增加文件计数器或者向 FileDB 添加一条新记录。为什么这样在这段时间里，加载程序确保文件在 FileDB 中不存在，上传它并继续向 FileDB 添加新记录，其他人可能已经上传了该文件并添加了相应的记录。我们已经考虑了上面的这种情况:一封邮件指定了两个收件人，所以两个加载器开始上传文件；一旦第二个加载器完成了上传，它还会继续向 FileDB 添加一条新记录。

在这种情况下，第二个加载程序只是增加文件计数器。

现在让我们看一下 dec 方法。我们的系统有两个高优先级的任务:可靠地将文件写入磁盘，并从这个磁盘快速地将其交还给客户机。物理删除文件会产生一定的工作负载，并降低这两项任务的速度。这就是我们离线执行删除的原因。dec 方法本身会递减计数器。如果后者变为零，就像这个神奇的数字一样，这意味着没有人需要这个文件了，所以我们将相应的记录从 Tarantool 中的 *space0* 移动到 *space1* 。

```
decrement (sha1, magic){
 counter--
 current_magic –= magic

 if (counter == 0 && current_magic == 0){
   move(sha1, space1)
 }
}
```

### 瓦尔基里

每个存储都有一个监控数据完整性和一致性的瓦尔基里守护程序，它与 *space1* 协同工作。每个磁盘都有一个守护进程实例。守护程序遍历磁盘上的所有文件，并检查*空间 1* 是否包含对应于特定文件的记录，这意味着该文件应该被删除。

但是在调用 dec 方法并将一个文件移动到 *space1* 之后，瓦尔基里可能需要一段时间才能找到这个文件。这意味着在这两个事件之间的时间跨度内，文件可能被重新上传，从而再次移动到*空间 0* 。

这就是为什么瓦尔基里还会检查文件是否存在于*空间*中。如果是这种情况，并且相应记录的 *pair_id* 指向运行该瓦尔基里实例的一对磁盘，则从 *space1* 中删除该记录。

如果在*空间 0* 中没有找到记录，那么文件是删除的潜在候选。然而，在对 *space0* 的请求和文件的物理删除之间，仍然有一定的时间窗口，在该时间窗口中，对应于该文件的新记录可能出现在 *space0* 中。为了处理它，我们把文件放在隔离区。

我们没有删除文件，而是在它的名字后面添加了被删除的文件和时间戳。这意味着我们将在*时间戳* +配置文件中指定的某个时间物理删除文件。如果发生崩溃，文件被误删除，用户将来回收它。我们将能够恢复它并解决问题，而不会丢失任何数据。

现在，回想一下有两个磁盘，每个磁盘上运行一个瓦尔基里实例。这两个实例不同步。因此问题来了:什么时候应该从 *space1* 中删除记录？

我们会做两件事。首先，对于有问题的文件，让我们将其中一个瓦尔基里实例作为主实例。使用文件名的第一位很容易做到:如果等于零， *disk0* 为主；否则， *disk1* 就是主人。

现在，让我们引入一个处理延迟。回想一下，当一个记录位于 *space0* 时，它包含用于检查一致性的 *magic* 字段。当记录被移动到 *space1* 时，该字段不被使用，因此我们将在那里放置一个时间戳，该时间戳对应于该记录出现在 *space1* 中的时间。这样，主瓦尔基里实例将立即处理 *space1* 中的记录，而从实例将向时间戳添加一些延迟，并在稍后处理和删除 *space1* 中的记录。

这种方法还有一个好处。如果某个文件被错误地放在主服务器上的隔离区，一旦我们查询主服务器，就会从日志中发现这一点。同时，请求文件的客户机将退回到从属服务器，用户将收到所需的文件。

因此，我们考虑了这样一种情况，即瓦尔基里守护进程找到了一个名为 sha1 的文件，并且这个文件(可能会被删除)在 *space1* 中有一个相应的记录。其他可能的变体有哪些？

假设一个文件在磁盘上，但是 FileDB 没有任何相应的记录。在上面考虑的情况下，如果主瓦尔基里实例由于某种原因在一段时间内没有工作，这将意味着从实例有足够的时间将文件隔离并从*空间 1* 中删除相应的记录。在这种情况下，我们还使用 sha1.deleted.timestamp 将文件隔离。

另一种情况:记录存在，但指向不同的磁盘对。如果为一封电子邮件指定了两个收件人，上传期间可能会发生这种情况。回忆一下这个计划。

如果第二个加载器将文件上传到不同于第一个加载器的另一对加载器，会发生什么情况？它将增加 *space0* 中的计数器，但是文件被上传到的磁盘对将包含一些垃圾文件。我们需要做的是确保这些文件可以被读取，并且它们与 sha1 匹配。如果一切正常，这样的文件可以马上删除。

此外，瓦尔基里可能会遇到一个已被隔离的文件。如果隔离结束，该文件将被删除。

现在，想象一下瓦尔基里遇到了一个好文件。它需要从磁盘中读取，检查完整性并与 sha1 进行比较。然后，瓦尔基里需要查询第二个磁盘，看看它是否有相同的文件。这里有一个简单的 HEAD 方法就足够了:在第二个磁盘上运行的守护进程将自己检查文件的完整性。如果文件在第一个磁盘上损坏，它会立即从第二个磁盘复制过来。如果第二个磁盘没有该文件，则会从第一个磁盘上传其副本。

我们只剩下最后一种情况，它与磁盘问题有关。如果在系统监控过程中发现磁盘有任何问题，有问题的磁盘将被置于服务(只读)模式，而在第二个磁盘上，将运行卸载操作。它有效地将第二个磁盘上的所有文件分配给其他磁盘对。

### 结果

让我们回到开始的地方。我们的电子邮件存储过去是这样的:

在实施新系统后，我们设法将总大小减少了 18 PB:

电子邮件现在占据 32 PB (25% —索引，75% —文件)。多亏了 18pb 的内存削减，我们在相当长一段时间内都不必购买新硬件。

### 关于 SHA-1 的附言

到目前为止，还没有已知的 SHA-1 碰撞的例子。尽管它的内部压缩功能存在碰撞的例子(SHA-1 自由启动碰撞)。给定 120 亿个文件，哈希冲突的概率小于 10^-38.

但是让我们假设这是可能的。在这种情况下，当根据文件的哈希值请求文件时，我们会检查它是否具有正确的大小和 CRC32 校验和，这些值在上传期间保存在相应电子邮件的索引中。也就是说，当且仅当所请求的文件随此电子邮件一起上传时，才会提供该文件。