# 组件化 Web - ACM 队列

> 原文:[http://queue.acm.org/detail.cfm?id=2844732&UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium =网站](http://queue.acm.org/detail.cfm?id=2844732&utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

<label>November 9, 2015
**[Volume 13, issue 8](issuedetail.cfm?issue=2838344)**</label>

[![Download PDF version of this article](../Images/d41c7b6eb6493a00953aa6dd3bd5eac4.png) PDF](https://dl.acm.org/ft_gateway.cfm?id=2844732&ftid=1644258&dwn=1)

# 网络组件化

## 我们可能正处于网络开发新革命的风口浪尖。

### 泰勒·萨维奇

在当今的软件工程中，没有比 web 开发更艰巨的任务了。

一个 web 应用程序的典型规范可能是这样的:应用程序必须能在各种各样的浏览器上运行。它必须以 60 fps 的速度运行动画。它必须对触摸立即做出反应。它必须符合一套特定的设计原则和规范。它必须适用于几乎所有可以想象的屏幕尺寸，从电视和 30 英寸显示器到手机和手表面部。从长远来看，它必须是精心设计和可维护的。

随着最新的网络技术的发展，这个列表越来越长:网络应用程序必须离线工作。它必须能够发送推送通知。它必须在后台同步。

当然，并非所有新的 web 项目都必须满足这一整套要求——有些可能是更成熟的单页应用程序，有些则更侧重于出版或电子商务——但应用程序的多样性使得 web 开发人员的工作更加困难。

当 web 应用程序的期望满足 web 平台的现实时，真正的挑战就出现了。可用于构建 web 应用程序的原材料远远没有跟上。HTML 的构建模块，如“

、“

、“

# ”和“

结果，web 开发社区发展了大量的框架来解决从平台提供的基本元素中构建合理界面的问题。可用 web 框架的范围和多样性是巨大的——一个蓬勃发展的生态系统，只有像 web 这样强大而灵活的平台才能支持它。在撰写本文时，TodoMVC 上列出了 60 多个框架(图 1)， <sup>12</sup> 展示了框架的使用。这种蓬勃发展的框架生态系统确实令人惊叹。

![Componentizing the Web: Partial list of frameworks showcased in TodoMVC](../Images/a4d9e1293c016bfb2af072d327b51950.png)

或者是？

尽管许多 web 框架是令人难以置信的工程壮举，非常受欢迎，并且有自己的大型生态系统，但是多框架模型存在一些限制 web 开发人员生产力的关键问题。

#### 框架是广泛的、硬依赖的。

HTML、CSS 和 JavaScript 固有的全球性是促使框架成为无所不包的工厂，而不是随用随付的工具包的众多因素之一。选择一个 web 框架通常是一个新的 web 项目中的第一个重大技术决策。因为框架往往是包罗万象的，所以几乎每一行代码或每一项标记都必须牢记框架。例如，Angular 提供了复杂的视图管理和路由、依赖注入、国际化和可访问性特性、低级动画支持等等。Meteor 提供了完整的前端和后端堆栈，从 UI 库到数据库驱动程序。这些都是难以置信的全功能应用平台，但它们从第一天起就导致了锁定，并且迁移起来极具挑战性。如果你选择转换框架，你可能会从零开始。

时尚性。 Web 框架像季节一样来来去去。根据 Google Trends，图 2 显示了五个 JavaScript 库受欢迎程度的上升和下降。web 开发社区一直渴望下一个新事物，这是正确的——web 应用程序需求、设备和浏览器功能发展如此之快，以至于工具必须快速发展才能跟上。不幸的是，这意味着昨天的热门新框架可能会成为今天的旧闻，公司在技术上的大量投资可能会很快过时。为了在就业市场上保持相关性，web 开发人员必须跟上最新的技术，在不断加速的黑客新闻框架公告、教程和初学者工具包的跑步机上运行。

![Componentizing the Web: Changing interest in various frameworks over time](../Images/cfa4666cdf33c3f311ffd2000a8c19b1.png)

**缺乏互操作性。一个合理的组件模型对于可扩展的界面开发至关重要。框架通常定义自己的组件模型来组织和呈现界面。Angular 有指令，React 和 Ember 都有自己的“组件”概念然而，在一个框架的模型中构建的组件在该框架之外没有任何意义——除非包含多个重叠和冗余的依赖项，否则不能在 Ember 应用程序中使用 Angular 组件。再加上框架经常需要的限制，互操作性的缺乏使得在 web 上编写通用的可重用的封装组件几乎是不可能的。**

圣杯，即“金发女孩”解决方案，将是如果 web 开发人员可以选择最适合他们试图解决的问题的应用程序架构，并且可以跨项目重用接口组件。web 开发社区可以为每一个框架和组织理念拥有繁荣的生态系统，以及一个共享的、通用的组件生态系统，这些组件可以在任何 web 应用程序中使用，而不考虑框架。大型组织可以共享符合一致风格的全局维护的组件集，但是所有团队都可以使用，而不管他们的堆栈如何。

这个 web 开发乌托邦似乎不可能实现，或者至少在技术上是不可行的，因为它需要不同框架之间就组件的一致处理达成广泛的一致。然而，web 已经有了这些通用组件的先例——HTML 元素本身。

#### 考虑一下<select>元素。</select>

元素提供了一个简单的下拉菜单。所有的框架都理解并能够利用<select>——它已经融入了平台。它可以在所有的浏览器上工作，有一个可预测的界面。它做一件事，而且做得很好。</select>

此外，<select>有一个 API 表面积，这使得它特别容易使用和有价值的使用，如图 3a-f 所示。</select>

它是*可组合的*(图 3a)。<选择>，菜单项由<选项>组成，生成一个完整的下拉菜单。

![Componentizing the Web: a Composable select element](../Images/9c990bdddb94d3872bc82a8bc85aa74d.png)

完全是*宣示性* (3b)。使用标记中的属性可以应用各种不同的功能。

![Componentizing the Web: Declarative attributes](../Images/dc1aff71f7f28d922b9a34f94dbda39d.png)

就是*灵活* (3c)。根据其子元素和属性，它可以提供不同的接口和功能。

![Componentizing the Web: Flexible interface](../Images/1dba70b7e03b8ae1a530d7d544f6e313.png)

就是*原谅* (3d)。不正确的子进程不会使应用程序崩溃，只是被忽略了。

![Componentizing the Web: Forgiving syntax](../Images/e6987c17a445b90f48ef69a55025f48b.png)

它可以在内部*访问* (3e)。一旦聚焦，它提供所有必要的句柄以便可访问。

![Componentizing the Web: Accessibility to styles](../Images/6105fb0552804c8752ff2b8198408dbf.png)

除了声明性地提供之外，<select>还可以被编写成 (3f)。它发出可以被监听和操作的事件，并且它有一个可以利用的命令式 API。</select>

![Componentizing the Web: Scriptable events](../Images/dd3bafd4555efb9ea1e7cf6c5134297a.png)

最后，<select>使用起来非常简单，几乎可以在任何上下文中使用。通过最少的声明性标记，开发人员获得了这种极其强大的行为。不管是什么框架，这个简单的标记和 DOM API 都很容易理解和使用。</select>

“<select>”元素当然很有用，但是平台只提供了有限的一组这样的元素，而且那组元素已经过时了。有两种潜在的方法来扩展这种能力:增加平台定义的元素的数量，或者为开发人员提供原语来创建他们自己的元素，并拥有原生元素的所有能力。</select>

有了可扩展 web 宣言， <sup>13</sup> 浏览器厂商果断地采用了后一种方法，他们更喜欢提供扩展 Web 平台功能所需的原语，而不是直接在平台中提供更高级别的抽象。

构建这样一个元素需要什么？为了构建像<select>这样非常可重用的元素，开发人员可能需要什么样的平台原语和特性？</select>

<select>的几个关键部分使它变得有用。它有一个属性形式的声明性 API，一个 DOM 节点的命令性 API，一个支持子元素的组合模型，以及一个标准的可视化界面。</select>

因此，要创建类似的定制元素，开发人员需要:

**定义它的 API** :给元素起一个名字，给它命令性的方法以及可以用来影响它的行为的声明性属性。

**定义它的模板:**如果元素需要任何本地 UI，为它提供一些基本的视觉布局。

从文档中封装它:元素的内部应该在文档中不可见。也就是说，向文档中添加元素不应该有意想不到的副作用。

**定义其组成模型:**指定元素可以接受什么样的子元素，以及如何管理子元素。

**管理它的依赖关系:**定制元素应该能够在它的本地 UI 中使用其他元素，因此应该能够指定和加载它所依赖的任何元素的定义。

当然，您可以在框架级别构建这样的封装和模板特性，许多框架都是这样做的。但是要实现广泛互操作组件的梦想，需要在平台级别提供这些特性，这样用它们构建的组件就可以重用，就像<select>一样。</select>

### 输入 WEB 组件

Web Components 是一些新的 W3C 规范的总称，这些规范为开发人员提供了构建这种可互操作的平台级特性所需的原语。组成 Web 组件的各个规范几乎直接映射到创建真正可互操作的元素所需的特定特性。

定义它的 API:定制元素规范 <sup>2</sup> 描述了如何给一个元素命名，定义一个 API 表面区域，并在其生命周期中响应不同的事件。定制元素的注册归结为一个简单的调用:

`var MyElement = document.registerElement(‘my-element’, {
  prototype: Object.create(HTMLElement.prototype)
});`

这允许开发人员为元素指定一个标签，并为元素的所有实例传入一个原型。此时，文档中“<my-element>”的所有实例都从 HTMLUnknownElement 升级到传入的元素的原型。请注意，具体的语法可能会在写作时略有变化——最新的规范，请参见[http://w3c.github.io/webcomponents/spec/custom/.](https://w3c.github.io/webcomponents/spec/custom/)</my-element>

定制元素规范中定义的生命周期回调让元素作者在元素生命周期的特定阶段对元素进行更细粒度的控制。这些回调包括“createdCallback”，当元素被创建和注册时调用；“attachedCallback”，在元素插入文档时调用；“detachedCallback”，当从文档中移除元素时调用；和“attributeChangedCallback”，当设置、更改或删除元素的属性时调用。

在第二个 document.registerElement 参数和 attributeChangedCallback 之间，元素作者可以指定元素的命令式和声明式 API。

**定义它的模板:**很多元素都有一些包含的 UI，比如按钮、输入、选择、标题、列表。要构建真正的平台级元素，元素作者应该能够为自己的元素指定 UI。web 开发人员应该能够使用 web 本身的语言——HTML 和 CSS——来定义元素的模板，而不是定义新的 DSL 或公开 C++挂钩。

真正的模板有几个关键属性。模板的存在不应该对文档产生副作用，模板应该被明确地选择以便使用，因此应该从主文档中封装出来，并且它应该是惰性的，直到它被真正地克隆和使用。

web 上的模板化问题是所有 UI 框架都面临的问题。已经发展了许多变通方法来提供这种行为，但是没有一种方法满足真正模板的所有标准。一些模板化的尝试在主文档中使用带有“display:none；以隐藏它，直到它被克隆和使用，但这可能会对布局和性能产生副作用。将 HTML 粘贴在

HTML5<template></template>

**从文档中封装:**模板为元素作者提供了一种将标记与元素相关联的方法，但是一旦元素及其相关联的标记被插入到页面中，就需要有一种方法将它们与文档本身隔离开来。例如，一个 HTML5 < video >标签有一个与之关联的 play 按钮，但是标签的用户不必担心在使用 CSS 或“文档”时意外地设计或选择了 play 按钮。querySelector”。

Shadow DOM spec <sup>9</sup> 为这个关键的封装提供了机制。它引入了“影子根”的概念——一个独立的、有作用域的树，它存在于 DOM 中，但受到 CSS 选择器或 DOM 操作方法的保护，不会受到意外干扰。Shadow DOM 是一种封装原语，它允许使用元素而不用担心副作用——要么元素意外地将样式泄露给其宿主文档，要么宿主文档意外地将效果或样式泄露给元素。

阴影 DOM 是一种微妙而复杂但极其重要的原语。撰写本文时，Shadow DOM 作用域机制的细节仍在浏览器供应商之间解决，但对这种作用域原语的普遍需求已被广泛接受。

**定义其组合模型:**要像原生 HTML 元素一样工作，自定义元素必须能够接受和操作子元素。影子 DOM 规范引入了“分布”的概念<sup>10</sup>——在影子根中指定插入点的能力，在这里特定的子元素可以被“分布”到主文档中。

这允许自定义元素作者定义元素接受什么样的子元素以及如何与它们交互。作者可以使用它来指定“select”元素如何寻找和投影它的“option”子元素。分发本质上是以元素接受的子元素的形式为元素提供了另一个 API 表面区域。

**管理它的依赖关系:**由于能够通过模板和影子根定义自己的内部标记，人们可以想象一个定制元素依赖其他定制元素作为它的内部 UI。由于多个元素可能依赖于同一个定制元素，因此需要有某种方法让元素声明它们的依赖关系，并让浏览器加载和删除这些共享的依赖关系。

HTML Imports 规范 <sup>3</sup> 提供了这种机制——一种元素作者或 web 开发人员在 HTML 中加载基于 HTML 的依赖项的方式。在撰写本文时，规范作者正在努力将这种 HTML 加载和去杜平机制与即将到来的 ES6 模块加载和去杜平机制相协调。

有了这四个重要的新特性——定制元素、模板、Shadow DOM 和 HTML 导入——web 开发人员终于拥有了创建真正可重用的定制元素所需的平台级原语，并拥有了原生 HTML 元素的所有功能。

#### 如何利用 web 组件—构建基于组件的用户界面

问题仍然是，个人和组织如何从 Web 组件提供的功能中获益？

Web 组件最直接的用例是构建用户界面。软件工程中的一般最佳实践要求系统被隔离和组件化。这个指导方针现在可以直接应用于构建平台级的 web UI，使用定制元素作为组件。

构建一个使用 web 组件作为界面元素的新的基于 web 的产品的第一步自然是构建整个产品共享的定制元素集。因为自定义元素可以封装它们自己的外观，所以这个元素创建步骤可能包括构建一组视觉上一致的按钮、数据表、菜单、布局模板和其他 UI 组件，作为在应用程序或应用程序套件中使用的元素。

将前端工程团队的工作单元视为一个组件，而不是将工作单元定义为一个屏幕或流程，开始释放 Web 组件的组织能力。通过让每个人一次专注于单个定制元素，团队可以最大限度地减少视觉不一致和重复工作。界面中元素的所有外观(例如，应用程序中使用的所有按钮)都是对单个自定义元素的重用，并且在外观上保持一致。

个人工程师也可以从最小化在构建应用程序逻辑和 UI 之间切换上下文的成本中受益。通过预先花时间确保独立于应用程序如何工作的完美元素设计，像素完美从最后一刻的润色变成了应用程序开发中的一个必要阶段。这个组件创建阶段之后的应用程序创建阶段也更加简化。从编写的第一行 app 逻辑代码开始，应用程序看起来和感觉上都是完整的。在整个开发过程中获得最终应用的感觉变得更加容易，有助于捕捉用户体验缺陷，并在开发周期的早期开始有用的 QA 过程。

在团队的第二个项目中，基于定制元素的界面模型的功效更加明显。因为他们已经花了时间来构建一组像素完美的界面元素，所以构建第二个界面的成本大大降低了。这使得团队可以专注于新特性和整体性能，而不是重新发明 UI。第二个项目对元素的任何改进都可以无缝地整合到第一个项目中。每个产品都是一项资本投资，在定制元素集的整个生命周期内都有回报。

重用元素的工程实践与将前端布局从一个旧项目复制并粘贴到一个新项目中有着本质的不同。定制元素从一开始就被孤立地设计，特别是为了灵活地重用。旧项目中的原始布局代码或标记很少被设计成在不同的上下文中使用，它可能充满了错误和怪癖。总体样式表缺乏封装性，会很快造成混乱，变得难以维护。如果一个元素需要更新以适应一个新的用例，这就变成了对定制元素的资本投资，使所有未来的用户受益。如果原始布局代码需要更新，它通常会成为一个额外的黑客，而非系统化的编辑很快就会变成意大利面条式的代码。

一组一致的 UI 元素也有助于确保设计和工程团队之间的协同作用和效率。重复使用的元素确保了品牌的一致性，保证在任何地方都有完全相同的外观和感觉。因此，视觉品牌将不仅在设计层面，而且在实施层面得到加强。一组元素提供了一个活生生的风格指南，并使工程与设计的结合变得更加容易:设计不再发生在真空中，因为每个视觉作品和调整都可以快速地融入到组件中，并在原位进行测试。视觉设计改革也更容易实现。自定义元素只需重新设计一次，新的样式可以在任何地方快速实现，通常只需直接升级元素定义。

将自定义元素的创建与元素的使用分离开来，也有利于组织。一些工程师更适合实现元素的像素级完美设计，因为他们有动画的眼光，了解平台的古怪之处，并对视觉细节充满热情。通过让这些工程师专注于创建在许多应用程序中使用的定制元素，他们的技能可以在整个公司范围内得到利用。

好的 UI 设计和性能通常既是科学也是艺术，需要艺术家的润色才能恰到好处。自定义 UI 元素允许这一艺术成就被广泛共享和利用。自定义元素有助于让简单的事情变得简单，让困难的事情变得容易重复。拥有一组统一的 UI 元素的广泛而长期的优势使它成为工程组织的一项明显的早期投资。

也许最重要的是，因为基于 Web 组件规范的定制元素是用平台而不是特定的框架构建的，所以不管下一个项目是用什么结构框架构建的，它们都可以被重用。对一组视觉上一致的元素的资本投资比为一种特定的框架技术构建的一组组件要持久得多。

当然，权力越大，责任越大。由浏览器供应商构建的原生 HTML 元素内置了辅助功能。使自定义元素可访问的责任落在了元素作者身上。正如原生 HTML 元素如果不能自然地访问就不完整一样，自定义元素必须尽可能地融入可访问性特性。在某种程度上，生态系统动力学应该奖励自然可访问的元素，但元素作者社区有责任从第一天起就明确地优先考虑可访问性。定制元素不是可访问性魔杖——高质量的元素将是内部可访问的，但是应用程序作者也必须在应用程序级别获得可访问性。

#### web 组件生态系统

除了对单个团队或组织的好处之外，人们可以想象完全可互操作的 web 组件的生态系统可能带来的网络效应。

可以创建定制元素套件，以便更容易地在 web 上构建成熟的应用程序:为不同类型的 web 应用程序创建不同的“UIKits”。可以为特定的用例构建定制元素，例如使博客更容易创建、使电子商务网站更有效、更容易使用、使数据可视化更容易实现的元素。定制元素可以为真正的语义网注入新的活力，让形式和功能交织成一个元素成为可能。目录可以帮助组织一个蓬勃发展的元素生态系统，众包元素评级和评论。

这样一个基于平台级互操作性的生态系统需要广泛采用平台级 API，让 web 开发人员能够创建定制元素。Web 组件规范是一项艰巨的任务。自 2011 年推出以来，它们引发了热烈的讨论，并根据反馈不断发展。尽管对 web 组件的价值有普遍的共识，但实施者正在制定两个重要的有争议的规范——将 HTML 导入与即将到来的 ES6 模块系统相协调，以及消除影子 DOM 行为的细节。您可以在 public-webapps 邮件列表上关注并加入对话。 <sup>8</sup>

目前，模板元素是动态 HTML 规范的一部分，并被现代浏览器广泛支持。HTML 导入、Shadow DOM 和自定义元素一直受到越来越多的跨浏览器关注，特别是在最近解决更有争议的问题的会议之后。从 Chrome 36 开始，它们已经完整地发货了。微软 Edge 最近宣布 <sup>4</sup> 它正在开始开发 HTML 模板元素，并对其余规范的最新进展发表了积极的看法。Firefox 在一个旗帜下发布实现，最近发表了一篇关于 web 组件历史的深度文章 <sup>5</sup> ，有希望的结论是，我们正在接近广泛的跨浏览器支持。

6 这些 JavaScript 实现支持从 IE10、Safari 7 以及 Chrome 和 Firefox 开始的主流浏览器的最后两个版本中的自定义元素、HTML 导入和影子 DOM。基于 Web 组件的库，如 X-Tag、 <sup>14</sup> Polymer、 <sup>7</sup> 和 Bosonic <sup>1</sup> 依赖于一些 poly fill 来获得广泛的浏览器支持，并包括围绕 poly fill 的较重部分的优化，以实现生产就绪的性能。

今天的网络开发者日子不好过。但是，随着一个理智的、平台级的组件模型的一致性，再加上 web 生态系统的巨大威力，我们可能正处于 web 开发革命的尖端。组件化快乐！

#### 参考

1.[http://bosonic.github.io/.](https://bosonic.github.io/)

2.[http://w3c.github.io/webcomponents/spec/custom/.](https://w3c.github.io/webcomponents/spec/custom/)

3.[http://w3c.github.io/webcomponents/spec/imports/.](https://w3c.github.io/webcomponents/spec/imports/)

4.Leithead 和 and Eicholz，2015 年。微软边缘和网络组件。[https://blogs . windows . com/msedgedev/2015/07/15/Microsoft-edge-and-we b-components/](https://blogs.windows.com/msedgedev/2015/07/15/microsoft-edge-and-web-components/)。

5.第页，W. 2015。Web 组件的状态。[https://hacks . Mozilla . org/2015/06/the-state-of-web-components/](https://hacks.mozilla.org/2015/06/the-state-of-web-components/)

6.[https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)。

7.[https://www.polymer-project.org/1.0/](https://www.polymer-project.org/1.0/)。

8.[https://lists.w3.org/Archives/Public/public-webapps/](https://lists.w3.org/Archives/Public/public-webapps/)。

9.[https://w3c.github.io/webcomponents/spec/shadow/](https://w3c.github.io/webcomponents/spec/shadow/)。

10.[https://W3C . github . io/web components/spec/shadow/# distributions](https://w3c.github.io/webcomponents/spec/shadow/#distributions)

11.[http://www . w3 . org/TR/html 5/scripting-1 . html # the-template-element](https://www.w3.org/TR/html5/scripting-1.html#the-)。

12.[https://github.com/tastejs/todomvc](https://github.com/tastejs/todomvc)。

13.W3C 可扩展网络社区组织。2013.可扩展网络宣言:[https://extensiblewebmanifesto.org/](https://extensiblewebmanifesto.org/)。

14.[http://x-tags.org/](http://x-tags.org/)。

Taylor Savage 是开放网络平台团队的产品经理，也是谷歌聚合物项目的首席项目经理。在加入 Polymer 之前，Taylor 是谷歌搜索新功能的项目经理。他毕业于斯坦福大学，获得了计算机科学学位。

![acmqueue](../Images/4f57fce9b685ad00824bd02663d98c4d.png)

*原载于《队列》第 13 卷第 8 期*——
见本条目于 [ACM 数字图书馆](https://portal.acm.org/citation.cfm?id=2844732)

* * *

更多相关文章:

Shylaja Nukala，Vivek Rau - [**为什么 SRE 文档很重要**](detail.cfm?id=3283589)
SRE(站点可靠性工程)是一种工作职能，一种思维模式，以及一套使 web 产品和服务可靠运行的工程方法。sre 在软件开发和系统工程的交叉领域运作，以解决运营问题和工程解决方案，从而设计、构建和运行可扩展、可靠和高效的大规模分布式系统。一个成熟的 SRE 团队可能拥有与许多 SRE 功能相关的定义良好的文档体。

超越页面对象:使用状态对象测试 Web 应用程序
Web 应用程序的端到端测试通常涉及到通过 Selenium WebDriver 之类的框架与 Web 页面进行复杂的交互。隐藏这种 Web 页面复杂性的推荐方法是使用页面对象，但是首先要回答一些问题:在测试 Web 应用程序时应该创建哪些页面对象？您应该在页面对象中包含哪些操作？给定页面对象，您应该指定哪些测试场景？

Rich Harris - [**拆除进入壁垒**](detail.cfm?id=2790378)
一场战争正在 web 开发的世界里展开。一方是工具制造者和工具使用者的先锋，他们靠破坏糟糕的旧思想(在这种环境下，“旧”是指一个多月前在黑客新闻上首次出现的任何东西)和关于 transpilers 之类的喧闹辩论而繁荣。

JavaScript 和用户界面自问世以来的二十年间，JavaScript 已经成为事实上的网络官方语言。当谈到大量的运行时环境时，JavaScript 胜过其他任何语言。如今市场上几乎所有的消费类硬件设备都以某种方式支持这种语言。虽然这通常是通过集成 Web 浏览器应用程序来实现的，但许多设备现在也支持 Web 视图作为操作系统 UI(用户界面)的一部分。

* * *

* * *

[![](../Images/ad65ebb8b75e7581c1bc43a3736aed3c.png)](#) 
ACM 公司版权所有。