# 2018 年微服务疯狂之死

> 原文:[http://www . dwmkerr . com/the-death-of-microservice-madness-in-2018/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](http://www.dwmkerr.com/the-death-of-microservice-madness-in-2018/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)



[西班牙语](https://www.campusmvp.es/recursos/post/la-muerte-de-la-locura-de-los-microservicios-en-2018.aspx) | [Reddit 线程](https://www.reddit.com/r/programming/comments/7pxriw/the_death_of_microservice_madness_in_2018/) | [黑客新闻线程](https://news.ycombinator.com/item?id=16200007)

在过去的几年里，微服务成为了一个非常热门的话题。“微服务疯狂”是这样的:

> 网飞在德文郡很棒。网飞做微服务。因此:如果我做微服务，我在 devops 很棒。

在许多情况下，人们已经付出了巨大的努力来采用微服务模式，但不一定了解成本和收益如何应用于手头问题的细节。

我将详细描述什么是微服务，为什么这种模式如此吸引人，以及它们带来的一些关键挑战。

我将以一组简单的问题结束，当您考虑微服务是否是适合您的模式*时，这些问题可能很有价值。问题在文末。*

*![Letterbox sample of diagram](../Images/d7c5d72776c2a864227553e2606dc5c8.png)*

## *什么是微服务，为什么这么受欢迎？*

*让我们从基础开始。下面是一个假想的视频分享平台是如何实现的，首先是以一个整体(单个大单元)的形式，然后是以微服务的形式:*

*![Diagram: Comparison of a Video Sharing Platform, Monolith vs Microservice](../Images/f30fcea37d14dbb15b6dfb4afe60c62d.png)*

*这两个系统的区别在于，第一个是单一的大单位；一块巨石。第二个是一组小的、特定的服务。每个服务都有特定的角色。*

*当图表以这种详细程度绘制*时，很容易看出吸引力。有很多潜在的好处:**

***独立开发**:独立的小组件可以由独立的小团队来构建。一个小组可以在不干扰“代码转换”服务，甚至不知道它的情况下对“上传”服务进行修改。学习一个组件所需的时间大大减少了，而且开发新功能也更容易了。*

***独立部署**:每个单独的组件都可以独立部署。这允许以更快的速度和更低的风险发布新特性。可以部署“流”组件的修复或功能，而不需要部署其他组件。*

***独立可伸缩性**:每个组件都可以独立伸缩。在发布新节目的繁忙时期，可以扩展“下载”组件来处理增加的负载，而不必扩展每个组件，这使得弹性扩展更加可行并降低了成本。*

*可重用性:组件完成一个小的、特定的功能。这意味着它们可以更容易地适用于其他系统、服务或产品。“代码转换”组件可以被其他业务部门使用，甚至可以变成一项新的业务，可能为其他部门提供代码转换服务。*

*在这个细节层次上，微服务模型相对于整体模型的优势似乎是显而易见的。那么如果是这样的话——为什么这种模式只是最近才流行起来呢？我一生都在哪里？*

## *如果这很棒，为什么以前没人做过？*

*这个问题有两个答案。一个是它已经尽了我们最大的技术能力，另一个是最近的技术进步已经让我们把它提升到了一个新的水平。*

*当我开始写这个问题的答案时，它变成了一个*长*的描述，所以我实际上打算把它分成另一篇文章，稍后再发表<sup id="fnref:2">。在这个阶段，我将跳过从单个程序到多个程序的旅程，忽略 ESB 和面向服务的架构、组件设计和有界上下文等等。</sup>*

*有兴趣的可以单独阅读更多关于旅程的内容。相反，我要说的是，在许多方面，我们已经这样做了一段时间，但是随着最近容器技术(特别是 Docker)和编排技术(如 Kubernetes、Mesos、Consul 等)的流行，从技术角度来看，这种模式变得更加可行。*

*因此，如果我们认为我们*可以*实现微服务安排是理所当然的，我们需要仔细考虑一下*应该*。我们已经看到了理论上的好处，但是挑战呢？*

## *微服务有什么问题？*

*如果微服务这么伟大，有什么了不起的？以下是我见过的一些最大的问题。*

***增加了开发人员的复杂性***

*对于开发者来说，事情会变得更加困难。如果一个开发人员想要进行一次*之旅*，或者开发一个可能跨越许多服务的特性，这个开发人员必须在他们的机器上运行它们，或者连接到它们。这通常比简单地运行一个程序更复杂。*

*这个挑战可以通过工具<sup id="fnref:3">得到部分缓解，但是随着组成系统的服务数量的增加，开发人员在整体运行系统时将面临更多的挑战。</sup>*

***增加操作员的复杂性***

*对于不开发服务，而是维护服务的团队来说，潜在的复杂性会激增。他们可能不是管理几个正在运行的服务，而是管理几十个、几百个或几千个正在运行的服务。有更多的服务、更多的通信路径和更多的潜在故障区域。*

***开发运维的复杂性增加***

*阅读上面的两点，运营和开发被分开处理可能会令人不快，特别是考虑到 devops 作为一种实践的流行(这是我的大力支持者)。devops 没有减轻这种情况吗？*

*面临的挑战是，许多组织仍然以独立的开发和运营团队运行——这样的组织更有可能难以采用微服务。*

*对于采用 devops 的组织来说，这仍然很难。既是开发人员又是操作人员已经很难了(但是对于构建好的软件来说是至关重要的)，但是还必须理解容器编排系统的细微差别，尤其是快速发展的系统，这是非常困难的。这就引出了下一点。*

***这需要专业知识***

*如果由专家来做，结果可能会很棒。但是想象一下，在一个组织中，单一的整体系统可能无法顺利运行。增加系统数量会使事情变得更好，这增加了操作的复杂性，这可能是什么原因呢？*

*是的，通过有效的自动化、监控、协调等等，这一切都是可能的。但挑战很少是技术——挑战是找到能有效使用它的人。这些技能目前需求量很大，可能很难找到。*

***现实世界的系统通常没有清晰的边界***

*在我们用来描述微服务优势的所有例子中，我们谈到了独立于*的*组件。然而，在许多情况下，组件根本不是独立的。在理论上，某些领域可能看起来是有界限的，但是当您深入到这些模糊的细节时，您可能会发现它们比您预期的更难建模。*

*这就是事情变得极其复杂的地方。如果您的边界实际上没有很好地定义，那么会发生的情况是，即使理论上*的*服务可以独立部署，您会发现由于服务之间的相互依赖性，您必须将*的服务集*作为一个组进行部署。*

*这意味着您需要管理服务的一致版本，这些版本在一起工作时经过了验证和测试，您实际上没有一个可独立部署的系统，因为要部署一个新功能，您需要仔细协调许多服务的同时部署。*

***状态的复杂性经常被忽略***

*在前面的例子中，我提到了一个特性部署可能需要同时部署许多服务的许多版本。人们很容易认为明智的部署技术可以缓解这种情况，例如蓝/绿部署(大多数服务编排平台都可以轻松处理)，或者并行运行多个版本的服务，由消费渠道决定使用哪个版本。*

*如果服务是无状态的，这些技术减轻了大量的挑战*。但是坦率地说，无状态服务很容易处理。事实上，如果你有无状态服务，那么我倾向于考虑完全跳过微服务，考虑使用无服务器模型。**

*实际上，许多服务都需要状态。我们的视频分享平台的一个例子可能是订阅服务。新版本的订阅服务可能会以不同的形式在订阅数据库中存储数据。如果您并行运行这两个服务，那么您是在同时用两个模式运行系统。如果您进行蓝绿色部署，并且其他服务依赖于新形状中的数据，则它们必须同时更新*，如果订阅服务部署失败并回滚，它们可能也需要回滚，从而产生级联后果。**

**同样，可能很容易认为有了 NoSQL 数据库，这些模式问题就消失了，但事实并非如此。不执行模式的数据库不会导致无模式的系统——它们只是意味着模式倾向于在应用程序级管理，而不是在数据库级管理。了解数据的形状及其演变方式这一根本挑战是无法消除的。**

**沟通的复杂性经常被忽略**

**当您构建一个相互依赖的大型服务网络时，可能会有很多服务间的通信。这导致了一些挑战。首先，有更多的点可能会失败。我们必须预料到网络调用会失败，这意味着当一个服务调用另一个服务时，它至少要重试多次。现在，当一个服务可能需要调用许多服务时，我们就陷入了复杂的境地。**

**假设用户在视频共享服务中上传视频。我们可能需要运行上传服务，将数据传递给代码转换服务，更新订阅，更新推荐等等。所有这些调用都需要一定程度的协调，如果失败，我们需要重试。**

**这种重试逻辑会变得难以管理。试图同步做事情往往最终站不住脚，有太多的失败点。在这种情况下，更可靠的解决方案是使用异步模式来处理通信。这里的挑战是异步模式本质上使系统有状态。正如前面提到的，有状态系统和分布式系统很难处理。**

**当微服务系统使用消息队列进行服务内部通信时，您实际上有一个大型数据库(消息队列或代理)将服务粘合在一起。同样，虽然一开始看起来不像是一个挑战，但是模式会反咬你一口。版本 X 的服务可能会编写一个具有特定格式的消息，当发送服务更改其发送的消息的细节时，依赖于该消息的服务也需要更新。**

**服务可以处理多种不同格式的消息，但这很难管理。现在，当部署新版本的服务时，您会遇到两个不同版本的服务可能试图处理来自同一队列的消息，甚至可能是由不同版本的发送服务发送的消息。这可能导致复杂的边缘情况。为了避免这些边缘情况，只允许某些版本的消息存在可能更容易，这意味着您需要将一组服务的一组版本作为一个连贯的整体来部署，确保先适当地排出旧版本的消息。**

**这再次强调了独立部署的想法在您了解细节时可能不像预期的那样成立。**

****版本控制可能很难****

**为了减轻前面提到的挑战，需要非常小心地管理版本。同样，有一种倾向认为遵循 semver[4]这样的标准就能解决问题。并没有。Semver 是一个可以使用的合理约定，但是您仍然需要跟踪可以一起工作的服务和 API 的版本。**

**这可能很快变得非常具有挑战性，并且可能会发展到您不知道哪些版本的服务实际上会一起正常工作的地步。**

**众所周知，管理软件系统中的依赖关系非常困难，无论是节点模块、Java 模块、C 库还是其他什么。当由单个实体消费时，独立组件之间*冲突的挑战很难处理。***

**当依赖关系是静态的时，这些挑战很难处理，并且可以修补、更新、编辑等等，但是如果依赖关系本身是 *live services* ，那么您可能不能够仅仅更新它们——您可能必须运行许多版本(具有已经描述的挑战)或者关闭系统，直到它被整体修复。**

****分布式交易****

**在需要跨操作的事务完整性的情况下，微服务可能会非常痛苦。分布式状态很难处理，许多可能失败的小单元使得编排事务非常困难。**

**通过使操作幂等、提供重试机制等等来试图避免这个问题可能很诱人，并且在许多情况下这可能是有效的。但是您可能会遇到这样的情况，您只需要一个事务失败或成功，而永远不会处于中间状态。解决这个问题或在微服务模型中实现它所涉及的工作量可能非常大。**

****微服务可以是伪装的整体****

**是的，单独的服务和组件*可能*被隔离部署，但是在大多数情况下，你必须运行某种编排平台，比如 Kubernetes。如果你使用的是托管服务，比如谷歌的 GKE <sup id="fnref:4">或者亚马逊的 EKS <sup id="fnref:5">，那么管理集群的大量复杂性就会被你处理掉。</sup></sup>**

**但是，如果您自己管理集群，那么您就是在管理一个大型、复杂的任务关键型系统。尽管单个服务可能具有前面描述的所有优点，但是您需要非常小心地管理您的集群。该系统的部署可能很困难，更新可能很困难，故障转移可能很困难，等等。**

**在许多情况下，整体利益仍然存在，但重要的是不要轻视或低估管理另一个大型复杂系统的额外复杂性。托管服务可能会有所帮助，但在许多情况下，这些服务都是新生的(例如，亚马逊 EKS 在 2017 年底才宣布)。**

****网络噩梦****

**在已知主机上运行的更传统的服务模型，具有已知的地址，具有相当简单的网络设置。**

**然而，当使用微服务时，通常会有许多服务分布在许多节点上，这通常意味着会有更加复杂的网络安排。服务之间将会有负载平衡，DNS 可能会被更多地使用，虚拟网络层等，以试图“隐藏”这种网络的复杂性。**

**然而，根据[特斯勒定律](https://github.com/dwmkerr/hacker-laws/#the-law-of-conservation-of-complexity-teslers-law)(或竞争性守恒定律)，这种网络复杂性是固有的——当您在较大规模的集群中发现真实的运行时问题时，它通常位于非常低的网络级别。这类问题很难*诊断。我已经开始跟踪文章末尾的一些例子，但我认为 [Tinder 向 Kuberenetes](https://medium.com/@tinder.engineering/tinders-move-to-kubernetes-cda2a6372f44) 的迁移很好地展示了这一挑战。***

**总的来说，这种转变仍然可能是最好的，但在网络层面不会没有一些严峻的挑战，这将需要一些严肃的专业知识来处理！**

## **微服务疯狂之死！**

**通过做出谨慎和深思熟虑的决定来避免疯狂。为了帮助解决这个问题，我提出了几个你可能想问自己的问题，以及这些问题的答案可能意味着什么:**

**![Diagram: Questions to ask yourself when considering microservices](../Images/4fc2c26835d91e9d4f4ab76aea545fcb.png)**

**你可以在这里下载一份 PDF 文档:[microservice-questions.pdf](https://github.com/dwmkerr/blog/blob/master/articles/2018/microservice-madness/images/microservice-questions.pdf)**

## **最后的想法:不要混淆微服务和架构**

**我在这篇文章中有意避免使用“a”字。但是我的朋友 [Zoltan](http://twitter.com/zoltanarvai) 在校对这篇文章时提出了一个非常好的观点(他也为此做出了贡献)。**

**没有微服务架构。微服务只是组件的另一种模式或实现，不多也不少。它们是否存在于一个系统中，并不意味着该系统的架构已经解决。**

**微服务在许多方面更多地与包装和操作的技术过程有关，而不是系统的内在设计。组件的适当边界仍然是工程系统中最重要的挑战之一。**

**不管你的服务规模有多大，也不管它们是否在 Docker 容器中，你都需要仔细考虑如何将一个系统组合在一起。没有正确的答案，有许多选项。**

**我希望你觉得这篇文章很有趣！一如既往，如果你有任何问题或想法，请在下面评论。您还可以关注一些关于以下内容的热烈讨论:**

## **附录:进一步阅读**

**您可能会对以下链接感兴趣:**

**请分享任何你认为值得阅读或观看的话题！**

* * *

 **## 谢谢

感谢来自 [campusmvp.es](https://www.campusmvp.es) 的 José将文章翻译成西班牙语-[La muerte de La locura de los microservicios en 2018](https://www.campusmvp.es/recursos/post/la-muerte-de-la-locura-de-los-microservicios-en-2018.aspx)！

## 个案研究

我收集了一些有趣的例子，说明大型组织已经大规模过渡到微服务:

* * *

## 参考** 