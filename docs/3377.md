# 事故报告:无意中泄露私人存储库 GitHub 博客

> 原文:[https://github . com/blog/2273-事件-报告-不慎-私密-储存库-泄露？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://github.com/blog/2273-incident-report-inadvertent-private-repository-disclosure?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

<main role="main" id="post-30396" class="col-12 col-lg-7 post__content col-md-8 post-30396 post type-post status-publish format-standard hentry category-engineering">

10 月 20 日星期四，GitHub 系统的一个 bug 通过 Git 拉取和克隆暴露了少量用户数据。总共有 156 个 GitHub.com 用户的私人仓库受到影响(包括 GitHub 的一个)。我们已经通知了受此私有存储库泄露影响的所有人，因此如果您没有收到我们的消息，您的存储库没有受到影响，您的信息也没有持续的风险。

这不是一次攻击，没有人能够故意检索易受攻击的数据。没有外人参与揭露这些数据；这是一个编程错误，导致少量 Git 请求从错误的存储库中检索数据。

不管这件事是否影响到你，我们真诚地道歉。我们不仅有责任保护您的信息安全，还有责任保护您对我们的信任。没有您的信任，GitHub 就不会存在，我们对此事件的发生深感抱歉。

以下是我们调查的技术分析，包括对事件的高度概述、我们如何缓解事件，以及我们为防止将来发生类似事件而采取的具体措施。

## 高级概述

为了加快 unicorn worker 的引导时间，并简化 fork 引导后的代码，我们应用了以下漏洞补丁:

![diff](../Images/75402e040afa63dfd54c5be83dda4a96.png)

我们的 rails 应用程序中的数据库连接分为三个池:一个只读组，一个由 Spokes 使用的组(我们的分布式 Git 后端)，以及普通的活动记录连接池。只读组和辐条组由我们自己的连接处理代码手动管理。这意味着当使用变更运行时，该池在 rails 应用程序的所有子进程之间共享。新代码行只断开由活动记录管理的`ConnectionPool`对象，而之前的代码片段将断开内存中保存的所有`ConnectionPool`对象。

这个错误对大多数查询的影响是一个畸形的响应，它会出错并导致几乎立即的回滚。但是，很少一部分查询响应被解释为合法数据，其形式为存储存储库数据的文件服务器和磁盘路径。一些存储库请求被路由到另一个存储库的位置。应用程序无法区分这些不正确的查询结果和合法的查询结果，因此，用户收到了他们不应该收到的数据。

当功能正常时，该系统的工作原理大致如下。然而，在这个失败窗口中，步骤 4 中的 MySQL 响应返回了格式错误的数据，这最终会导致 git 代理从错误的文件服务器和路径返回数据。

![System Diagram](../Images/0a708234991189a0c72d7fca7f2200b4.png)

我们对这 10 分钟窗口的分析发现:

*   1700 万个对 git 代理层的请求，其中大部分由于部署错误而失败
*   250 万个请求成功到达我们文件服务器层上的 git-daemon
*   在到达我们的文件服务器的 250 万个请求中，绝大多数是“已经是最新的”无操作读取
*   250 万个请求中有 40，000 个是非空提取
*   40，000 个非空请求中有 230 个易受此缺陷影响，并提供不正确的数据
*   这占当时总运营的 0.0013%

## 更深入的分析和取证

在确定了 bug 的影响之后，我们开始确定在部署期间哪些请求受到了这种影响。通常，这是一个简单的任务，因为我们有一个内部的 Git 监视器，记录每个存储库访问。然而，这些日志包含一些同样的错误数据，这些错误数据首先导致了错误路由的请求。在主 git 日志中没有准确的用户名或存储库名称，我们不得不求助于 git 代理和 Git 守护进程发送到 syslog 的数据。简而言之，我们的目标是将来自代理、git-daemon 和我们的主 git 日志记录的记录连接起来，从每个来源提取任何准确的数据。跨服务器和数据源关联记录是一项挑战，因为时间戳因负载、延迟和时钟偏差而异。此外，给定的 git 请求可能会在到达 Git 之前被代理或 git-daemon 拒绝，从而在代理日志中留下与 git-daemon 或 Git 日志中的任何记录都不相关的记录。

最终，我们使用时间戳、客户机 IP 和传输的字节数将数据从代理加入到 Git 日志记录系统，然后仅使用时间戳加入到 git-daemon 日志中。如果一个日志中的一个记录可以连接另一个日志中的几个记录，我们会考虑所有情况，并选择最坏的情况。我们能够识别用户请求的存储库(在我们的 git 代理上正确记录)与实际发送的存储库(由 git-daemon 正确记录)不匹配的情况。

我们进一步检查了给定请求发送的字节数。在许多情况下，发送的数据不正确，字节数远远大于请求的存储库在磁盘上的大小，但与发送的存储库大小非常接近。这给了我们进一步的信心，确实有些库被完全公开给了错误的用户。

尽管我们看到了 100 多个错误路由的获取和克隆，但我们没有看到错误路由的推送，这表明数据的完整性没有受到影响。这是因为 Git 推送操作分两步进行:首先，用户上传包含文件的包文件并提交。然后，我们更新存储库的 refs(分支提示),指向上传的包文件中的提交。从用户的角度来看，这些步骤看起来像一个单一的操作，但是在我们的基础设施中，它们是不同的。要破坏 Git 推送，我们必须将这两个步骤错误地路由到同一个地方。如果只有包文件被错误路由，那么没有 refs 会指向它，git fetch 操作也不会获取它。如果只有 refs 更新被错误路由，它将没有指向任何包文件，并将失败。事实上，我们看到了两个包文件在事件中被误路由。它们被写入错误存储库中的临时目录。然而，因为 refs-update 步骤没有被路由到同一个不正确的储存库，所以杂散包文件对用户来说是不可见的，并且在下次那些储存库执行“git gc”垃圾收集操作时被自动清理(即删除)。因此，任何错误的推送都不会产生永久或用户可见的效果。

错误路由的 Git 拉取或克隆操作由几个步骤组成。首先，用户通过 SSH 或 HTTPS 连接到我们的一个 git 代理(我们也支持 Git 协议连接，但不会以这种方式公开私有数据)。用户的 Git 客户机请求特定的存储库，并向 Git 代理提供凭证、SSH 密钥或帐户密码。Git 代理检查用户的凭证，并确认用户能够读取他或她所请求的存储库。此时，如果 Git 代理从其 MySQL 连接获得意外响应，那么身份验证(是哪个用户？)或授权(他们可以访问什么？)检查只会失败并返回一个错误。许多用户在事故中被告知，他们的存储库访问“由于过度使用资源而被禁用”

在公开存储库数据的操作中，身份验证和授权步骤成功了。接下来，Git 代理执行路由查询，查看请求的存储库位于哪个文件服务器上，以及它在该服务器上的文件系统路径是什么。这是 MySQL 错误结果导致存储库泄露的步骤。在少数情况下，两个或多个路由查询同时在同一个 Git 代理上运行，并收到不正确的结果。当发生这种情况时，Git 代理获得了一个文件服务器和路径，用于来自同一个代理的另一个请求。请求最终被路由到错误存储库的完整位置。此外，存储库访问记录的信息是来自用户请求的存储库和用户实际获得的存储库的信息的混合。这些损坏的日志极大地阻碍了发现泄露程度的努力。

一旦 git 代理得到了错误的路由，它就将用户的请求转发给 git-daemon，最终转发给 Git，在其他人的存储库的目录中运行。如果用户正在检索一个特定的分支，它通常不存在，并且拉取失败。但是如果用户拉或者克隆所有的分支，那就是他们所收到的:所有的提交和文件对象都可以从错误的存储库中的所有分支到达。用户(或者更常见的是，他们的构建服务器)可能期望下载某一天的提交，而不是收到其他存储库的全部历史。

令人惊讶的是，无意中获取了其他存储库的全部历史的用户甚至可能没有注意到。随后的“git pull”几乎肯定会被路由到正确的位置，并且会纠正用户的 git 存储库工作副本中任何被覆盖的分支。但是，不需要的远程引用和标记仍然存在。这样的用户可以删除远程引用，运行“git remote prune origin”，并手动删除所有不需要的标记。一个可能更简单的替代方法是，拥有不需要的存储库数据的用户可以删除整个存储库副本，并再次“git 克隆”它。

## 接下来的步骤

为了防止这种情况再次发生，我们将修改数据库驱动程序，以检测并仅解释与数据库发送的数据包 id 相匹配的响应。在应用程序端，我们将整合连接池管理，以便活动记录的连接池管理所有连接。我们正在跟进，将应用程序升级到一个没有“连接重用”问题的 Rails 新版本。

我们将继续分析围绕这一事件的事件，并利用我们的调查来改进 GitHub 的系统和流程。我们认为，未经授权暴露哪怕是一个私人存储库都是一个严重的失败，我们对发生这一事件表示诚挚的歉意。

</main>