# 有意义的可用性|晨报

> 原文:[https://blog . acolyer . org/2020/02/26/有意义-可用性/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://blog.acolyer.org/2020/02/26/meaningful-availability/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

[有意义的可用性](https://www.usenix.org/system/files/nsdi20spring_hauer_prepub.pdf)，豪尔等人，NSDI'20

*感谢 Damien Mathieu 的推荐*。

这篇写得非常清楚的论文描述了 Google G Suite 团队对一个有意义的可用性指标的探索:一个准确反映最终用户体验的指标，工程师可以用它来确定问题并指导改进。

> 一个好的可用性度量标准应该是有意义的、成比例的和可操作的。我们所说的“有意义”是指它应该捕捉用户的体验。我们所说的“成比例”是指指标的变化应该与用户感知的可用性的变化成比例。我们所说的“可操作”是指该指标应该让系统所有者了解一段时间内可用性低的原因。本文表明，没有一个常用的度量标准满足这些要求…

谷歌选定的替代方案叫做*窗口用户正常运行时间*，在过去的一年里，它已经在整个 G Suite 的产品中使用。我们马上会看到窗口用户正常运行时间是如何工作的，但是首先让我们回顾一下可用性报告的常用方法，以及它们为什么没有通过 Google 的测试。

### 数九个

可用性度量的基本形式是“良好”服务与总需求服务的比率:`availability = good service / total demanded service`。他们通常用“九个九的数量”(例如“五个九的可用性”)来描述。现在我们只需要决定我们所说的“服务”、“良好”和“总需求”是什么意思。

**基于时间的**可用性指标可能是大多数人首先想到的。这里我们可以说`availability = uptime / (uptime + downtime)`。一种更好的表达方式是`MTTF / (MTTF + MTTR)`(平均无故障时间和平均恢复时间)。对于一个所有用户都经历相同故障的非容错系统来说，这是可以的，但是对于一个某处出现故障是正常的分布式系统来说,“停机时间”意味着什么呢？系统只有在对所有用户都关闭的情况下才会关闭吗？是否有任何一个用户宕机？如果某个百分比的用户下降了呢？这些限制意味着这些指标没有意义，因为它们依赖于任意的阈值，并且与系统不可用的严重程度不成比例。它们也与受影响的用户数量不成比例(高峰需求期间的停机时间！=安静期的停机时间)。

为了尝试并克服这些限制，一些系统转向了基于**计数的**可用性指标，其中最常见的是*成功率* : `availability = successful requests / total requests`。这比基于时间的指标更合理，但也存在一些问题:

*   该指标倾向于高流量用户的体验(G Suite 报告用户的活动水平存在 3 个数量级的差异)
*   当系统被认为停机时，用户发出的请求会减少，这也会扭曲指标
*   该指标对最终用户来说意义不大，因为它没有捕捉到任何关于系统不可用的时间的概念。

基于时间和基于计数的指标也很难转化为可操作的见解…

> …没有一个现有指标能够区分每小时开始时 10 秒的低可用性或每季度一次的高峰使用时间内 6 小时的低可用性。

第一个是令人讨厌但相对较小的麻烦，第二个是大停电！

### 使可用性变得有意义和相称

一个人的正常运行时间是另一个人的停机时间('它对你来说是停机吗？它是为我而降的……’)。通过从单个用户的角度考虑正常运行时间(停机时间)，我们可以结合基于时间和基于计数的指标的优势，给出一个*有意义的*和*比例*指标:*用户正常运行时间*。

$ \ display style \ mathrm { user \ uptime } = \ frac { \ sum _ { u \ in users } \ mathrm { uptime }(u)} { \ sum _ { u \ in users } \ mathrm { uptime }(u)+\ mathrm { down }(u)} $

> 因为这个指标是以时间为单位的，所以对用户来说是有意义的。因为它不受任意阈值的限制，所以它与不可用性的持续时间和大小成反比。

那么，我们如何衡量每个用户的运行(停止)时间呢？我们可以使用定期发送的探测请求，如下所示:

![](../Images/75c90f11d23800314823bd3e0b0aa180.png)

但是这里的挑战是很难创建能够准确反映各种真实用户请求的探针。那么，如果我们使用真实的用户请求呢？这准确地捕捉到了用户体验，但是现在我们有了另一个问题:用户不会随着时间的推移发出均匀间隔的请求:

![](../Images/08076fbec943d5014da49c9d05eac508.png)

谷歌用以下规则处理这个问题:

*   在一次成功(或失败)的操作之后，假设系统启动(或关闭),直到用户看到相反的证据。

如果一个用户发出一个不成功的请求，然后几天都没有与系统交互，该怎么办？对于该用户来说，系统是否应该一直处于关闭状态？直觉上这感觉不对。因此，最后的修饰是一个截止持续时间，设置为用户请求到达间隔时间的第 99 个百分位数(Gmail 为 30 分钟)。如果在截止时间内没有请求到达，该段被标记为*非活动*，并且不计入用户停机时间或正常运行时间。

![](../Images/413cb885b4a4f1e2f77a9dccc1848e5c.png)

### 使可用性可行

为了使可用性信息具有可操作性，我们希望能够区分不同持续时间的中断(例如，一个用户中断 1000 分钟，而 1000 个用户中断 1 分钟)。一般来说，检查可用性的窗口越大，可用性数字看起来就越好。为了解决这个问题， *windowed* user-uptime 同时结合了所有时标(窗口大小)的信息。对于给定的窗口大小 *w* ，通过枚举大小 *w* 的所有窗口，计算每个窗口的可用性，然后取最小值来计算可用性。总的来说，结果被称为*最小累积比率*或 MCR。

这里有一个例子:

![](../Images/d4316425eaa8226f4626bd5cfe098b86.png)

这些情节真的信息量很大。例如，我们可以一眼看出:

*   本季度的总体可用性约为 99.99%
*   不存在可用性低于 92%的一分钟或更长时间的窗口，并且…
*   从曲线的**拐点(大约 2 小时)，我们可以推断出可用性下降到 92%的事件持续了大约两个小时。**

曲线的拐点告诉我们感兴趣的窗口大小。然后，您可以通过查看一段时间内该大小的窗口来深入研究:

![](../Images/6f3964756cc33ba03ca1f235b70d9055.png)

> 这些数据是可操作的，它告诉我们降低我们整体可用性的窗口。我们的工程师使用这些图表来查找和修复不可用性的来源。

为了使事情简单明了($MCR(w)$作为一个单调函数，参见论文的第 5.2 节)，保持窗口大小为彼此的线性倍数(例如 2 的幂)。

### 窗口化用户-生产中的正常运行时间

第 6 节包含来自 Google 的缩放和移位的生产数据，说明了所有讨论过的基于时间和基于计数的指标的可用性限制，并给出了窗口运行时间的实例。

例如，这里有一张一个月内 Google Drive 和 Hangouts 的窗口用户正常运行时间图。

![](../Images/1d2c15987c9ca59409cf9ba4cf33bbd7.png)

您可以看到，Hangouts 的可用性受到四小时事件(曲线拐点)的影响，而 Drive 没有明显的 kenn，这表明不是任何单一的长时间中断，而是频繁的短时间中断阻碍了服务获得更高的可用性。“*因此，除非我们解决其根本原因，否则硬盘将会月复一月地遭受这些停机时间的困扰*。”

为了能够沿着多个维度(例如，组织、操作类型等)对数据进行切片，有必要在每个维度的窗口粒度的最佳级别存储数据。

### 最后一句话…

> …我们相信窗口化的用户正常运行时间具有广泛的适用性:任何云服务提供商都应该能够实施它。