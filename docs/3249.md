# Twitter 如何部署其小部件 JavaScript

> 原文:[https://blog . Twitter . com/2016/how-Twitter-deployments-its-widgets-JavaScript？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://blog.twitter.com/2016/how-twitter-deploys-its-widgets-javascript?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

部署是困难的，而且做起来会令人沮丧。许多 bug 在部署过程中显现出来，尤其是当有大量代码变更时。现在，如果一项部署同时面向数百万人，那会怎么样呢？这是我的团队如何安全轻松地部署这种规模的故事。

网络发布者使用一个 JavaScript 文件 *[widgets.js](https://dev.twitter.com/web/javascript/loading)* ，在他们的网站上嵌入 Twitter 内容。嵌入式 Tweet、嵌入式时间轴和 Tweet 按钮由同一个 JavaScript 文件驱动，这使得 web 发布者可以轻松地将小部件集成到他们的网站中。我们每周更新 widgets.js，部署错误修复和添加功能，而不需要我们的发布者做任何工作来接收更新。

但是为了确保我们的客户保持简单，我们需要承担一些复杂性。具体来说，我们需要部署一个单一的、未版本化的、众所周知的、静态的资产，发布者信任它在他们的页面中运行。这个代码每月被超过 10 亿的访问者每秒执行大约 30 万次。我们知道这对我们来说是一项重大的责任，这就是为什么我们最近投资升级 widgets.js 部署流程，以尽早发现错误，并避免负面的客户影响。

## 安全部署

我们通过巩固理想部署的样子来开始这个项目。具体来说，我们确定了我们所追求的安全部署的三个品质:

*   可逆性:‘先回滚，后调试’是我们的座右铭。回滚应该快速、容易且简单。理想情况下，这是一个巨大的红色按钮，可以降低我们的心率。
*   所有的代码都有缺陷，部署有一种不可思议的方式让它们浮出水面。这就是为什么我们想要分阶段发布新代码的能力。
*   **可见性:**我们需要图表来显示 widgets.js 的两个版本在任何时候的表现。我们还需要能够按国家、浏览器类型和小部件类型进行钻取。这些图表应该是实时的，这样我们可以快速了解部署的进展情况，并采取必要的措施。

这些是我们为自己设定的目标。现在，让我们深入了解我们是如何实现这些目标的细节。

## 部署如何工作

因为 *widgets.js* 是一个众所周知的资产(platform . Twitter . com/widgets . js)，它的文件名中没有版本控制，这使得它更难控制其部署进度。我们决定控制该文件新版本发布的方式是控制我们的域名 platform.twitter.com 在 DNS 级别的解析方式。这样，我们可以设置规则，在部署期间将文件解析为新版本或旧版本。

*部署架构*

为了实现对 DNS 的控制，我们必须配置三个组件:

**DNS 管理服务:**这是一项让我们控制如何将 platform.twitter.com 解析为 IP 地址的服务。我们使用地理区域来控制部署，基于以下三个规则，对应于部署的每个阶段:
阶段 1:来自区域 A 的 5%的流量获得 IP2，其他获得 IP1。
阶段 2:来自区域 A 的 100%流量获得 IP2，其他流量获得 IP1。对越来越大的区域重复上述步骤。
第三阶段:所有流量 100%获得 IP2。这包括 TOR 流量和任何我们无法确定其来自哪个地区的请求。

**CDN(内容交付网络):**这是一项服务，有助于以高性能的方式为我们的静态资产提供服务。我们的配置是这样的，如果请求是通过 IP1 发出的，它将服务于来自源 1 的资产，否则来自源 2。

**起源:**一个存储服务，像亚马逊 S3，在那里 *widgets.js* 被上传。CDN 向 origin 索要最新版本服务。

默认状态是所有请求都由源 1 中的资产提供服务。部署从上传新版本的 *widgets.js* 到 ORIGIN 2 开始。然后，如上所述，我们通过从阶段 1 到阶段 3 开始将流量转移到起点 2。如果部署成功，我们将资产从源 2 复制到源 1，并将所有流量重置到源 1。

## 给新部署流程打分

我们的目标是执行安全部署，所以让我们来评估一下我们做得如何。通过拥有 2 个原点，我们能够立即回滚——这里的回滚是将所有流量移回原点 1，在那里我们有先前版本的 *widgets.js* 。基于地理位置的部署为我们提供了一种逐步推广新版本的方法，并且只有在安全的情况下才继续进行。最后，我们的客户端代码记录发布版本，因此我们能够构建实时图表，告诉我们部署是否成功。

今天，成功的部署看起来是这样的:

*部署成功时新老版本的流量变化*

我们已经使用这个部署过程将近一年了，并且比以前更早地检测到了几个回归。例如，我们最近在代码中有一个错误，一个懒惰加载的 JavaScript 文件被错误地处理，导致我们的小部件不能完全呈现。但是由于这一部署过程，我们很快就看到了影响，并能够在它广泛影响客户之前解决它。

## 后续步骤

对于下一次迭代我们可以改进什么，我们有很好的想法。我们了解到的一件事是，我们的 DNS 规则可以更好。我们希望第一阶段是一个小而重要的用户数量，让我们快速洞察关键的回归。在第二阶段，我们希望用户样本更大，以捕捉更细微的 bug，这些 bug 只会在大规模时出现。将我们的阶段与这些目标相匹配需要对 DNS 规则进行一些调整，这是我们未来想要投资的一个领域。

我们希望改进的另一个方面是总部署时间。由于有如此多的移动部分，我们的部署时间从几分钟增加到了几个小时，这主要是因为每次我们将流量从一个阶段转移到另一个阶段时，我们都必须等待所有中间缓存失效。

我们还希望在未来添加性能指标，这样我们就可以将我们的发布验证从原始的成功/失败扩展到更深入的性能洞察，例如全球不同位置的渲染时间。

我们使用外部供应商进行 CDN 和 DNS 管理，我在这里描述的 DNS 级别的所有配置都使用公开记录的 API，您可以在今天的部署中使用这些 API。总的来说，我们对新的部署流程今天的工作方式非常满意，因为它鼓励我们更频繁地发布更新，同时仍然保持发行商的简单性。