# 可测试性设计——由缺陷构成

> 原文：<https://blog.nelhage.com/2016/03/design-for-testability/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

当设计一个新的软件项目时，一个人经常会面临关于如何构建它的大量选择。核心抽象应该是什么？他们之间应该如何互动？

在这篇文章中，我想讨论一个设计启发，我发现它是回答或影响这些问题的有用指南:

> 优化代码的可测试性

具体来说，这意味着当您编写新代码时，当您设计它并设计它与系统其余部分的关系时，问自己这个问题:“我将如何测试这个代码？我将如何编写自动化测试来验证代码的正确性，并尽可能减少对环境或系统其余部分的不相关假设？”如果你对这个问题没有一个好的答案，重新设计你的抽象或者接口，直到你有了答案。

我发现这个启发法在两个不同的方面有价值，我将在这里讨论这两个方面。

# 你考得好 [*🔗︎*](#you-get-good-tests)

这一点也许是显而易见的:如果你以拥有好的测试为目标，你很可能以好的测试结束。

然而，我认为值得多说一点。

首先，我想强调在一个有良好测试的代码库中工作是多么美妙。验证变更的过程很简单:只需运行测试。无需设置复杂的开发环境，无需手动或交互式地调试系统；只需`make test`，即使不能保证，也能高度确信你的代码做了你认为它做的事情，并且没有破坏任何重要的东西。

在大型和成熟的软件系统中，进行变更最困难的部分不是变更本身，而是以一种不倒退任何其他重要行为的方式进行变更。因此，能够快速提供基本保证的又好又快的测试是一个巨大的生产力提高。

第二，为了真正实现好的测试的好处，您需要能够快速运行测试——或者至少是覆盖您的变更的测试子集——以便保持快速的开发周期。

为了在系统扩展时保持这个属性，你需要有好的*单元*测试。关于“单元”、“功能”、“集成”和其他种类的测试之间的界限，有很多宗教性的争论；这里的“单元”测试指的是对代码库的某个特定模块或组件进行测试，对应用程序中其他代码的依赖或调用最小。

你总是需要一些集成测试，端到端地测试应用程序，以消除组件之间不可避免的微妙交互。但是主要依赖单元测试会带来显著的优势:

*   单元测试很快:通过使用有限数量的代码，它们比必须调用整个应用程序的测试运行得更快。
*   更重要的是，单元测试*扩展*:在一个大部分是单元测试的代码库中，测试速度应该随着应用程序的规模线性扩展。随着更多功能性端到端测试的出现，您面临着向二次方扩展的风险，因为每个组件都需要测试，而这些测试又会顺便测试几乎所有其他组件。
*   因为单元测试与清晰的代码片段相关联，所以很容易只运行与特定变更相对应的测试，从而为开发提供更快的反馈循环。

然而，好的单元测试不是偶然发生的。没有好的“单元”，就很难有好的单元测试:具有狭窄且定义良好的接口的代码部分，可以在这些接口上进行测试。

拥有这样的逻辑单元的最佳方式是直接这样做:在编写代码时牢记这一点，这样的逻辑单元允许优秀的测试，进而允许快速的反馈循环，同时维护一个成熟的项目。

# 你得到更好的代码 [*🔗︎*](#you-get-better-code)

编写代码时考虑测试的第二个原因是，它实际上会产生更好的代码！

让我们考虑一下易于测试的代码应该具有的一些特征:

## 对纯函数的偏好超过不可变数据 [*🔗︎*](#a-preference-for-pure-functions-over-immutable-data)

不可变数据结构上的纯函数很容易测试:你可以创建一个(示例输入，预期输出)对的表格。它们通常也很容易被 QuickCheck 之类的工具模糊，因为输入很容易描述。

## 接口明确的小模块 [*🔗︎*](#small-modules-with-well-defined-interfaces)

如果一段代码有一个小的、定义良好的接口，我们可以根据该接口编写黑盒测试，测试所描述的接口契约，而不必过分关心模块的内部或系统的其余部分。

## IO 和计算的分离 [*🔗︎*](#a-separation-of-io-and-computation)

一般来说，IO 比纯代码更难测试。因此，可测试系统将它从代码的纯逻辑中分离出来，允许它们被单独测试。

## 依赖关系的显式声明 [*🔗︎*](#explicit-declaration-of-dependencies)

与接受句柄作为参数的代码相比，从全局环境中隐式提取数据库名称的代码更难测试——在测试过程中，您可以使用不同的句柄调用后者，每次都针对干净的数据库进行测试，同时在多个线程中进行测试，或者您需要的任何其他操作。

一般来说，可测试代码在某些时候接受依赖项作为显式参数，而不是假设它们隐式可用。

* * *

如果我观察这些特征，我发现它们通常也是好的、结构良好的代码的特征！通过在设计系统时考虑到测试，我们通常会得到一个比我们原本拥有的更好的系统。

此外，通过间接接触这些属性——通过测试的镜头——我们使它们更加具体。很容易无限期地争论什么是软件系统的正确模块、接口和结构；但是面对“是什么使得充分测试这段代码变得容易？”更容易评估我们的选择，并决定我们什么时候走得够远。

# 结论 [*🔗︎*](#conclusion)

对于一个复杂的软件系统来说，没有什么比自信地做出改变的能力更重要的了，而高质量的自动化测试是我们为此所拥有的最重要的工具之一。好的测试不是偶然发生的，甚至不是靠蛮力完成的:它们是通过设计发生的，因为应用程序是为支持它们而编写的。

当你写软件时，总是问自己“我如何测试这个软件的正确性？”并愿意为此目标而设计。作为回报，你将得到一个你可以——并保持——更有信心的系统，一个在其他方面结构更好的系统。