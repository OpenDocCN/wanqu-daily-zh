# 我为什么喜欢数据库|作者 Jeeyoung Kim | Medium

> 原文:[https://medium . com/@ JEE youngk/why-I-love-databases-1 d4c 433685 f？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://medium.com/@jeeyoungk/why-i-love-databases-1d4cc433685f?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

# 我为什么喜欢数据库

去年，我在[广场](https://squareup.com)处理各种数据库。我做到了:

*   调查和解决数据库性能问题。
*   为新应用程序设计数据模型和分片策略。
*   评估和运行新的数据库。

最初出于需要，我很快就迷上了数据库。数据库的研究几乎贯穿了计算机科学的每一个主题——它的理论和实现既复杂又具有挑战性。

然而，我很快意识到这并不是一种普遍的激情。对我的许多同事和朋友来说，数据库是一个神奇的黑盒系统，太可怕太复杂而难以理解。我想改变这一切。

在谈论数据库时，不能忽略分布式系统的话题。大多数现代数据库都是分布式的，要么是隐式的(分布式集群数据库)，要么是外部的(单个应用程序通过应用程序级分片连接到多个数据库)。

这篇文章是我对数据库和分布式系统的热爱的表白。它主要面向像我这样的程序员，即经常与数据库交互的应用程序开发人员。我们主要用 Java、Python 或 Ruby 编程，编写服务器端应用程序。我将介绍:

*   比较和评估不同的数据库。
*   如何理解并充分利用你的数据库？
*   从高层次理解数据库的工作方式。

# 首先，什么是数据库？

在本文中，任何接受并保存数据以备将来检索的软件都是数据库。这既包括传统的 RDBMS 和 NoSQL 数据库，也包括 Apache Zookeeper 和 Kafka 等系统。

# CAP 定理

[上限定理](http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed)。这是我最喜欢的不可能结果，自从图灵的*停止问题*和 P≠NP(技术上不是*结果)。*CAP 定理表明，任何分布式系统充其量只能满足 CP(一致性&分区容差)、AP(可用性&分区容差)，或者介于两者之间。因此，一致性和可用性之间出现了有趣的权衡。

关于 CAP 定理的几个重要误解:

*   传统的“*三选二*的说法没有意义。您不能放弃分区容差，因为这将意味着“在分区期间执行的操作的行为是未定义的”，在这种情况下，数据库并不真正一致。(参见[1])
*   达到上限定理的极限不是默认给定的。有许多数据库既不一致、不可用，也不支持分区。达到上限定理的极限需要仔细的设计和实现。

# 分布式系统

如前所述，许多现代数据库以某种方式分布。这有两个主要动机:

*   将**扩展到单台机器之外——在多个节点中存储和处理数据。**
*   提高**可用性—** 确保数据库不会出现单点故障。

这两个目标密切相关。一般来说，通过增加机器数量来扩展系统会对可用性产生负面影响，因为遇到故障的概率会增加。因此，实现高可用性几乎是可伸缩性的先决条件。

# 正确性与效率

正确性和 T2 效率都很重要，并且在分布式数据库中密切相关。

正确性在任何软件中都很重要，但对数据库来说更是必不可少，因为(1)数据库保存数据，不正确的数据会在重启后继续存在，以及(2)数据库被认为是软件栈中最可信的基础。

数据库正确意味着什么？许多分布式数据库都有特殊的一致性语义。你可以在这里做一个权衡。一般来说，更严格的一致性使得应用程序代码更容易推理，但代价是效率和可用性。

除了理论，正确性还有实现和操作上的挑战。分布式系统本质上是复杂的。众所周知，像 [Paxos](https://en.wikipedia.org/wiki/Paxos_(computer_science)) 这样的算法很难理解和正确实现。随着系统变得越来越复杂，更多模糊的故障场景出现了。像 Redis 和 ElasticSearch 这样的系统遭受着分布式系统的非公理化设计的困扰。

除了上述权衡之外，由于前面的困难，效率也很重要。我对低级编程了解得越多，我就意识到一台机器每秒可以执行多少次原始操作。在许多情况下，效率降低了复杂性，使整个系统更简单。分布式系统比低级编程更难的事实促使我寻求这些效率。给定相同的负载，我很乐意选择需要更少机器来操作的数据库。

最后，机器间协调的计算和延迟开销可能很大。总之:运动部件越少越好。

为了从代码中获得更高的性能和效率，必须深入到更低层次的抽象，包括:

*   内存分配器和垃圾收集器[2]
*   文件系统调度程序和 IO 设备特征
*   内核设置
*   各种系统调用的实现细节，(fork，execv，malloc)

它们之间的任何不和谐都会导致糟糕的性能。您不必是内核黑客，但是您需要对这些组件如何交互有一个高层次的了解。

# 增强应用能力

就像不同的编程语言各有利弊一样，数据库也有自己独特的特点。充分理解它们是很重要的。它允许您实现一个复杂而高效的应用程序，同时将大多数复杂的、容易出错的工作委托给数据库。

如果您没有严格的性能或可用性要求，传统的 RDBMS 通常是一个不错的选择。酸保很厉害，明面很棒。分割 RDBMS 是痛苦的，但是很容易理解。MySQL 和 Postgres 是两个流行的选择。

全文搜索引擎允许您构建高级索引和搜索功能。它们最终的一致性很少成为问题，因为搜索是一种固有的模糊操作。Lucene 及其后代(Solr，ElasticSearch)是热门选择。

消息队列和事件处理系统消除了容易出错、难以实现的代码。Kafka，Storm，Spark SQL，RabbitMQ，Redis 都是比较热门的选择。

具有跨区域复制功能的数据库使区域故障转移和高可用性变得更加容易。这里的开源选择不多，但 Apache Cassandra 可能是最成熟的一个。

共识、领导者选举和分布式锁很难实现和测试。不要实现你自己的。使用 Zookeeper，etcd，或者 raft-as-a-library。

现在谈谈细节。数据库是一个固有的[漏洞抽象](http://www.joelonsoftware.com/articles/LeakyAbstractions.html)。他们通常能很好地隐藏他们潜在的复杂性，但是忽视他们的局限性最终会伤害到你。几件重要的事情:

*   理解数据库的正确性保证。一次失败的手术意味着什么[3]？哪些操作是完全一致的，哪些不是？
*   理解数据是如何持久化和检索的。哪些操作是高效的，哪些不是？有没有查询规划器，或者每个操作的详细统计？
*   分片和集群拓扑。了解数据如何在集群中分布。您的分片策略是均匀分布数据，还是存在热点？
*   数据建模模式和反模式。

# 运营挑战

一旦成为软件堆栈的一部分，数据库将全天候与您的基础架构共存。它们带来了独特的运营挑战。

操作数据库就像在大海中航行。无论何时遇到问题，都需要在不破坏数据库的情况下修复它，即使是在暴风雨中。因此，数据库必须具有:

*   方式**自省&监控**系统。
*   旋钮**维护&管理**系统。
*   **复制、备份和恢复。**丢失数据非常糟糕。机器总有一天会崩溃。因为数据库是有状态的，所以不能简单地通过重新部署来恢复故障机器。

所有这些功能。坦率地说，所有数据库在这方面都有缺点。允许在系统运行时改变每一个配置是一个困难的挑战。许多操作需要数据库范围的互斥、额外的系统资源或重新启动。例子包括:

*   在 MySQL 之前的版本中，添加列需要全表锁。像 [pt-online-schema-change](http://www.percona.com/doc/percona-toolkit/2.1/pt-online-schema-change.html) 这样漂亮的解决方案可以缓解这个问题。 [MySQL](https://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html) 现在支持在线模式迁移。
*   Cassandra 允许您轻松地添加、删除和修复节点。然而，这些操作增加了系统的额外负载。

此外，你不能轻易替换一个数据库。即使是在同一个数据库中迁移数据也不简单。迁移到另一个数据库甚至更难，如果不是不可行的话[4]。应用程序代码更容易逐步推出和恢复。数据的寿命比代码长得多。数据模式和存储的数据通常在多个应用程序之间共享。因此，选择初始数据库系统和相应的数据模型是非常重要的。

最后，数据库最终会失败。无论您使用什么样的平台/基础架构即服务，有些故障都是不可避免的:

*   损坏或丢弃数据的应用程序错误。[5]
*   误解数据库的安全性和一致性保证并丢失写入。
*   数据模型和数据库不匹配——例如，数据集不适合单个碎片。期望比较和交换在最终一致的数据库中工作。
*   操作故障—机器崩溃。硬盘快没电了。操作系统升级。
*   网络分区[6]。
*   雷群—单个系统故障级联到整个系统。
*   而最糟糕的是——“事情突然慢了”。“延迟的随机峰值”。“一天一次零星错误”，“这个记录应该早就有了”。

对此没有单一的解决方案。操作数据库的艺术属于维护高 SLA 系统的艺术，但是如果我需要给出一些提示:

*   应用程序开发人员了解限制和故障模式行为。
*   编写弹性应用程序。多数据中心部署。数据中心之间的自动故障转移。
*   拥有一支有能力的操作工程师团队(现场可靠性工程师，DBA ),他们了解不同的故障场景和恢复方法。

PS:在 [Square](https://squareup.com/) ，我们有一个令人敬畏的在线数据存储(ODS)团队，他们将这个问题从我们这里抽象出来

# 基本构件

数据库提供的抽象是非常神奇的。数据接收、查询、复制和故障切换都在同一个包中？但是当你习惯了它，你开始了解到有一些基本的构建块——所有数据库共享的公共模式和组件。

首先，数据检索简化为以下之一:

*   键值查找(哈希表)
*   范围查找(树和 LSM)
*   文件偏移查找(卡夫卡，HDFS)

归根结底，计算机不理解 SQL、索引、连接或其他花哨的东西。高级操作需要被翻译成机器可以执行的东西。

对于持久数据结构， [B 树](https://en.wikipedia.org/wiki/B-tree)、[哈希表](https://en.wikipedia.org/wiki/Hash_table)和[日志结构合并树](https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/) (LSM 树)是流行的选择。最有可能的情况是，您的数据存储在其中一个中，除非它需要一些特殊的查找(例如:地理空间查询)。LSM 树是一种流行的现代选择，由于其卓越的写性能和合理的读性能，在 [BigTable](https://en.wikipedia.org/wiki/BigTable) 、 [HBase](https://hbase.apache.org/) 、 [Cassandra](https://cassandra.apache.org/) 、 [LevelDB](https://github.com/google/leveldb) 和 [RocksDB](http://rocksdb.org/) 中使用。

最后，在不同的系统中重用了流行的模式和算法:Paxos、 [Raft](https://raftconsensus.github.io/) 、[一致散列法](https://en.wikipedia.org/wiki/Consistent_hashing)、 [Quorum 读/写](https://en.wikipedia.org/wiki/Quorum_(distributed_computing))、 [Merkel 树](https://en.wikipedia.org/wiki/Merkle_tree)和[向量时钟](https://en.wikipedia.org/wiki/Vector_clock)是一些基本的构建模块。

# 摘要

这篇文章是对一些主题的简单、高层次的概述。还有很多其他主题我没有涉及，比如针对不同工作流的优化(OLAP、OLTP、批处理)和数据库的 UX(查询语言、传输协议、客户端库)，这些同样重要。不同一致性语义的含义，如*顺序一致性、读自己的写、至少一次交付都是*也很有趣。

数据库最好的一点是它是一个非常成熟的抽象。它基本上是可行的，并且作为应用程序开发人员，不需要太多思考就可以非常容易地保存和检索数据。这绝对是值得庆祝的，但是剥掉这项足够先进的技术的皮绝对是值得的。

我希望更多的人对这门学科感兴趣，并充分利用它。