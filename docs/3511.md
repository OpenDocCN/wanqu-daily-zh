# 增量 Swift

> 原文：<https://realm.io/news/tryswift-amy-dyer-incremental-swift/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

当您准备升级到 Swift，但无法重写您现有的 Objective-C 应用程序时，您会怎么做？在这[试试吧！Swift](https://www.meetup.com/try_SwiftNYC/) talk，Amy 使用 Etsy 作为案例研究，讨论了将 Swift 逐步集成到您的应用中的蓝图。

Swift 为 Objective-C 互操作性提供了丰富的特性，但是将它们应用到您当前的代码库并不总是简单明了的。Amy 讲述了技术细节，如林挺和管理依赖关系，以及收集支持的组织策略，以及他们在 Etsy 学到的其他东西。

阅读本文后，您将为向 Swift 的平稳过渡做好准备:在您的代码和您的公司中都是如此。

* * *

让我们谈谈在您的应用中逐步采用 Swift。今天我想介绍的是使用我们在 Etsy 的经验作为案例研究。我将告诉你一些关于:

*   我们从哪里开始，以及我们如何决定开始使用 Swift。
*   我们运行的实验开始进入我们的代码库。
*   我们学到的教训或我们一路上打破的东西。

Etsy 是一个全球市场，让世界各地的人们在线上和线下进行联系，以制造、销售和购买独特的商品。在 Etsy，我们有四个本地应用。我们有一个给买家的应用程序，一个给卖家的应用程序，这两个程序都在 iOS 和 Android 上。

2015 年，当 Swift 2.0 问世，Swift 开始开源时，在我们看来，这完全是不可思议的。Etsy 的许多其他工程师和我开始对我们自己如何使用 Swift 感到兴奋。

我会看着一个类，我会说，“如果我能用泛型重写它，那会好得多。”或者，“如果我有编译时 API 可用性，那么编写这个特性会容易得多。我们开始对自己说:我们可以继续使用 Objective-C，或者我们应该重写所有的东西。

来自不同公司的精彩文章让我想起了 Lyft 的一篇，他们谈到如何将他们的应用程序移植到 Swift 使其速度更快、更小、减少了错误。这让他们的开发者更开心。所有这些事情对我们来说都是神奇和令人兴奋的，我们也想这样。

我们说:“太好了，让我们重写一切吧！”我们决定提出一项提案，随着时间的推移，逐步将我们的应用程序移植到 Swift，一类一类地移植。当然，我们需要做的第一件事是建立共识。让我感到惊讶的是，当我与 iOS 开发之外的人谈论开始使用 Swift 时，我有两个来自人们的评论。

人们会说 Swift 已经过时一年了:你不是已经不用了吗？那不是发生过的事情吗？或者人们会说，你完全疯了吗？你为什么要从头开始重写你的应用程序？“收集共识是这个过程的一个重要部分，我们决定通过一个我们称之为架构审查的过程来做到这一点。也就是说，你写一份提案，让一群聪明的人聚在一个房间里，你有责任解释为什么你认为你的新代码，你的新想法会让你的生活变得更好。

获取更多类似这样的发展新闻

我们把这些聪明人召集在一起，其中一个人问道，“*你怎么知道你写的所有这些 Swift 代码会比你已经有的 Objective-C 更好？*

这对我们来说是个好问题，因为我们实际上有很多目标-C。截至 2016 年 8 月，我们有:

*   5 年以上的承诺历史。
*   280，000 行目标-C 和计数。
*   2500 个实现文件(*并且我不包括我们的库*)。

我提出这个问题并不是因为它不好。所有这些代码代表了 Objective-C 的大量经验、权威和专业知识。抛弃所有这些并重新开始对我们来说可能不是最谨慎的方法。我们决定我们需要找到这个问题的答案；我们需要一个使用 Swift 的理由，而不仅仅是因为它神奇、酷、令人兴奋。

我们决定后退一步，我们说，“也许我们不必生活在一个世界或另一个世界。让我们开始用 Swift 编写我们的测试吧。”这正是我们三四个月来所做的:我们开始用 Swift 编写功能和单元测试，用它作为回答这个问题的工具。

### 稳定性和策略 

当你在这两种语言之间来回切换时，你开始关注 Objective-C，并开始意识到它不能表达某些东西。你会写一个函数，你会看着它，你会想，如果这个自变量为零呢？一切都会破碎吗？大概吧。

这给了我们答案。我们说，“我们不想用 Swift，因为它很酷。**我们希望使用 Swift，因为我们认为它能让我们编写更安全、崩溃更少的代码**。从那里我们能够再次建立共识。

我们进行了另一次架构审查，提出了一项新的提案，我们开始与人们讨论我们的新目标，即不要将所有东西都转移到 Swift，也不要强制进行 Swift 开发，而是让它成为可能。

因为如果我们相信我们编写的 Swift 代码会更好、更安全，那么我们就可以开始用 Swift 编写新的功能，并保持我们已经知道并信任的所有旧目标。这就是我们着陆的地方。

我们说，“与其只和 Objective-C 或 Swift 生活在一起，不如让我们成为一个双语言代码库。让我们致力于此。”我认为，这实际上是一个明智的决定，因为实际上，如果我们一次移植一个应用程序，无论如何我们都需要几年时间才能完全移植到 Swift。

### 缺点，优点 

这种方法有许多缺点。显然，这意味着您处于这种尴尬的、介于两者之间的代码库状态。

Xcode 会忘记你在看什么语言，给你一个错误语言的头。更重要的是，开发者需要懂两种语言，这在学历上也是一个劣势。最后，我们必须处理所有这些混乱的互操作性特性，即桥接头和自动生成的 Objective-C。

但对我们来说，优势超过了这一点。如果我们一点一点地适应 Swift，它会给我们更多的时间去适应，去冒险。它还让我们了解 Swift 将如何为我们服务。最后，它让我们有时间了解 Swift 作为一个组织，因此我们知道，当我们写更多 Swift 时，我们将成为更好的 Swift 作者。

我们需要一种方法来开始使用 Swift，而我们通过实验找到的方法是 Swift。

### 雨燕通过实验 

我们说:我们将对我们认为如何将 Swift 的每一部分添加到我们的代码库做出假设，然后我们将找到一种方法来测试它们。

这一点很重要，因为我们知道事情会变坏，我们希望确保我们变坏的任何东西都不会影响我们的用户或我们生产中的实际应用程序。事情会因为许多原因而破裂，包括 Swift 不稳定。

它是不稳定的，从某种意义上说，它正在积极发展，苹果公司仍在做出突破性的变化；也不稳定的事实是，有时它只是崩溃- Xcode 崩溃，操场崩溃。

我们想确保这不会给我们的野外生活带来问题。

我们也意识到我们的应用是一个更大的生态系统的一部分:我们不仅仅是一个好的存储库，我们也有第三方服务。崩溃日志，而且我们还要向苹果提交账单；我们有账单机，我们必须做翻译(可能还有我们想都没想过的事情)。

对我们来说，重要的是要问自己，这些影响我们应用的外部事物，加入 Swift 会对它产生什么影响。

然后我们提出了三个目标:

1.  让我们添加这个快速运行时。
2.  添加我们的第一个 Swift 类，并 A/B 测试它
3.  开始在 Swift 中开发新功能。

### 添加 Swift 运行时 

当您开始在您的应用程序中发布 Swift 时，因为 Swift 不是一个稳定的二进制接口，所以您实际上发布了所有这些库，这些库是您的应用程序的 Swift 运行时所需的动态链接库。

当你检查一堆箱子时，我们决定装运一些不运行的代码；我们在 Swift 中添加了一个隐藏的视图控制器，不需要用户运行它。

我们学到的第一件重要的事情是:**确保那些库确实在那里**。如果你用 Swift 应用解压一个 IPA 文件，你会在有效载荷旁边看到一个名为 *SwiftSupport* 的文件夹。并且应该用一堆像 swiftlibcore.dlib 这样的动态库来填充。

如果这些库不存在，苹果会给你发一封讨厌的邮件，拒绝你的应用。省得自己心痛，拉开拉链。原来某些无头构建，包括 Xcode 构建，默认情况下不包含这个文件夹。WatchKit 应用程序也存在同样的问题。

我们学到的另一件事是:**监控构建规模**。Swift 运行时中的这些库加起来大约有 17MB(相当大)。

我浪费时间担心，这会不会超过空中下载的限制，这会影响下载，那就不好了。我花了很多时间尝试编写脚本，告诉我当我们将应用程序提交到应用程序商店时，它会有多大？事实证明，这很难，因为像应用程序变薄这样的事情，苹果压缩了它。你不能回答你的应用有多大的问题。

解决办法就是:上传到 iTunes Connect。在所有菜单的深处，在 Activity，All Builds 下，你点击一个 build，苹果会告诉你他们将会给你的用户提供多大的应用。

第一次实验成功后，我们决定继续运行我们的第一个 Swift 代码。

### 运行我们的第一个 Swift 代码 

这是实验二。我们决定使用的方法是 A/B 测试。我们一行一行地重写了现有的简单视图控制器。有用的是，我们没有测试我们在 Swift 中编写新代码的能力，我们只是测试 Swift 本身以及它如何与我们的 Objective-C 代码库的其余部分进行交互。

这个实验也教会了我们一些新的东西:**它崩溃了**。

我有一个突击测验给你。这段代码在哪里崩溃？

```
 guard let collection  = self.collection else { return }
let isPrivate = collection.isPrivate()
let isFavorites = collection.type == "favorites" 
```

当你访问属性`collection.type`时，它在第三行崩溃。

这里发生的是`collection`是 Objective-C 类的一个实例，我们没有向它添加可空性说明符。这意味着 collection.type 作为属性隐式地展开字符串。隐式取消包装的可选。因此，它实际上是可选值，当您试图访问它时，它会自动为您打开包装。

这是需要学习的重要一课:**注释你的文件**。这对我们来说很有趣，因为，当然，对于大约 2500 个头文件，注释所有的头文件是完全不切实际的。

我们找到的解决方案是在导入文件时给文件添加注释。你的 Swift 桥接头是你的 Swift 代码和你的 Objective-C 之间的防火墙，只要你在那里注释东西，你就安全了。

需要特别提醒的是，不要忘记 headers nest，一个导入标题的标题，您需要确保您的 Swift 注释在它链接的所有标题中都可用。

我们了解到的另一件事是:**我们的故障记录器没有在 Swift** 中给我们提供有用的信息。我们试图找出我们的代码在哪里崩溃，我们在堆栈跟踪中收到了随机垃圾。

事实证明，Swift 的一个有趣的特性是，因为它有适当的名称空间，所以您不能确保在链接器级别的编译中有命名冲突。Swift 中的所有这些符号都被编译成这种混乱的格式。

Xcode 工具附带了一个有用的工具，叫做 Swift-demangle。你可以把你的栈跟踪，放入 Swift-demangle，给你一个合适的栈跟踪。通过我们的崩溃修复，我们决定开始在 Swift 中编写新代码。

### 在 Swift 中编写新代码 

我们提出了一个团队目标:**不要写任何其他开发人员必须重写才能从 Objective-C** 中使用的 Swift。

我这样说的原因是因为我们认为代码重用是一个重要的目标。我们不希望出现这样的情况:有人在 Swift 中编写了一个令人兴奋的新实用程序，然后另一个开发人员想在 Objective-C 的一半代码中使用它，但他们不能。

这实际上比听起来要难，因为 Swift 中的许多特性并不向后兼容 Objective-C (泛型、元组、结构)。如果您的 Swift 代码中包含所有这些内容，那么您会自动生成 Objective-C 标头，但不会包含所有这些内容。

我们采用的解决方案很简单:**使用访问级别**。我们在文件中有 private，在 Swift 3.0 中有 private。我们所决定的是，如果你要使用，例如，一个泛型或结构，确保它被标记为私有。你可以写你的非常快速的代码，但它会为它接口。你被迫从 Objective-C 中写一些你仍然可以使用的东西。

但是，你怎么能强迫这样做呢？我们着陆的方法是:**使用棉绒**。

Linter 是一个小软件，它将源代码作为输入和输出样式违规(逗号和大括号)。你可以用这个做更强大的事情。我在名为 [SwiftLint](https://github.com/realm/SwiftLint) 的伟大开源项目上写了一个 linter 规则。

```
 Code/Swift/Interoperability.swift:19:2: warning: Objective-C Interoperability Violation: Object ‘someFunction(_:_:)’ of type FunctionFree should be private, but is internal (objective_c_interoperability) 
```

Linter rule 会仔细检查并确保您没有以可公开访问的方式使用任何这些仅限 Swift 的功能。如果您这样做，它会警告您，您可以确保将该代码排除在我们的代码库之外。

最后，我们学到的最后一件事是，我们的许多 Objective-C 代码在 Swift 中看起来很糟糕。不是很*迅捷*。原来有一个奇妙的宏叫做`NS_REFINED_FOR_SWIFT`。

如果你有一段难看的 Objective-C 代码，你可以用这个宏标记它，然后用 Swift 写一个扩展。

```
 @interface MyClass : NSObject
- (void)anUglyFunction NS_REFINED_FOR_SWIFT;
@end

extension MyClass {
  public func aPrettierFunction() -> Void {
    return self._anUglyFunction()
  }
} 
```

这让你可以重新定义 Swift 如何看待这个功能，你可以让它更规范。如果这种方法对您有用，2015 年 WWDC 有一场名为“用 Swift 改进您现有的应用”的精彩演讲

### 教育、标准化和未来 

我们想确保我们仍然在回答这个问题:*我们如何确保 Swift 编码的编写与我们已经拥有的 Objective-C 一样好或者更好？*

我们首先需要的是**代码标准**。我们希望确保我们都同意我们将编写的 Swift 代码。

有趣的是，我们没有一个人觉得自己有权从头开始编写自己的 Swift 代码标准。这对我们来说也是一种新的语言。我们所做的，我给你的建议是，当然，你可以借一些。

许多公司公开发布他们的 Swift 代码标准。我们从 GitHub 的开始。您以此为起点，我们开始根据我们自己对互操作性的关注来修改它，以达到我们今天拥有的代码标准。当然，另一件事是不要忘记标准化新版本。

一旦你有了一个以上的 Swift 开发者，你就可能运行着一个以上的 Xcode 版本。这在 Objective-C 中不是问题，但在 Swift 中却很快成为问题。

因为你们将开始发布代码，然后你们将开始为彼此使用新的措辞，它不会编译所有代码，因为你们运行的版本略有不同。

从命令行，你可以检查你运行的是什么版本的 Swift，只要同意一个就行。Swift.org 现在发布了工具链，你可以独立于 Xcode 版本安装到 Xcode 中。或者你可以同时安装 Xcode。

然后，当然，我们必须处理 Swift 的未来版本。采用 Swift 3.0 可能会遇到与最初采用 Swift 相同的问题。这是一个突破性的变化。我们该如何应对？我们决定继续保持相同的实验方法。

我们将使用 code migrator 在分支机构中运行 Swift 3.0 视为在我们的一台构建机器上安装 Xcode 的未来版本。这让我们可以使用相同的实验方法来确保 Swift 3.0 也不会导致任何问题。

最后，我们有教育。这是我们正在进行的事情。这是我们感到兴奋的事情:“我们如何让 iOS 以外的其他开发者为 iOS 应用做出贡献？我们采取的方法是举办一系列研讨会和午餐会，开始向更多人介绍 Swift。

### 大局 

如果您坐在观众席中，并且您有一个大目标-C，并且您希望明天就开始使用 Swift，我对您有什么建议，您可以从哪里开始？

首先，你需要找到你存在的理由，你的杀手锏:你需要一个使用 Swift 的理由。不仅仅是 FOMO。它需要是对你作为开发者或你的用户有益的东西。

一旦你找到了原因，你就开始告诉人们，让其他人在你的代码中使用 Swift 就变得容易多了。

我给你的下一个建议是从你的代码库之外开始。对我们来说，从编写测试开始是非常宝贵的。重要的一点是，它让我们获得了写 Swift 的经验。但另一件重要的事情是，它让我们获得了在 Etsy 编写 Swift 的经验，并弄清楚这对我们意味着什么。

当你从你的代码库之外开始时，无论是测试还是工具，或者玩具项目或者类似的事情，你都给了自己一个集体学习的机会。

我给你的下一个建议，当然是做一个测试假设；所有为我们而破碎的东西，它们可能也会为你而破碎，你可能也会找到一些新的。每个系统都不一样，每个系统都是独一无二的。你能找出什么会给你带来问题的唯一方法就是去尝试。

我的建议是制作一个图表，找出所有接触你的应用程序的东西，并问自己"*如果我有 Swift，这种情况会改变吗？*”或“*这将如何改变？*。”然后，对于其中的每一件事，尝试设计一个实验，找出如何在不破坏生产应用程序的情况下测试它。

**你可以做到**。我们很幸运能和这两种非常强大的语言一起工作，它们是可以互操作的。它给你工具，否则我们可能没有。不要害怕开始。

谢谢大家！

### 资源

 <dov class="about-speaker flex center xs-column">关于内容

本次演讲于 2016 年 9 月在 [try 现场直播！纽约斯威夫特](https://www.tryswift.co/)。该视频由 Realm 录制、制作和转录，经会议组织者许可，在此发布。</dov>