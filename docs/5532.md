# 设计超大型(JavaScript)应用程序| Malte Ubl | Medium

> 原文:[https://medium . com/@ cram force/designing-very-large-JavaScript-applications-6e 013 a 3291 a 3？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

# 设计超大型(JavaScript)应用程序

[最初发表在我的博客《工业共情》上。](https://www.industrialempathy.com/posts/designing-very-large-javascript-applications/)

这是我在 JSConf 澳大利亚演讲的文字记录。[在 YouTube 上观看整个演讲](https://www.youtube.com/watch?v=ZZmUwXEiPm4)。这个帖子的[续集在这里](/@cramforce/designing-even-larger-applications-460ee029012d?source=friends_link&sk=e732423e46e87029473431067fd066fc)可以看到。



Slide text: Hello, I used to build very large JavaScript applications.



你好，我曾经构建过非常大的 JavaScript 应用程序。我真的不再这样做了，所以我认为这是一个很好的时间来回顾一下，分享一下我学到的东西。昨天我在会议派对上喝啤酒，有人问我:“嘿，马尔特，到底是什么给了你谈论这个话题的权利和权威？”我想回答这个问题实际上是这次演讲的主题，尽管我通常觉得谈论自己有点奇怪。所以，我在谷歌建立了这个 JavaScript 框架。它被照片、网站、Plus、Drive、Play、搜索引擎、所有这些网站所使用。有些很大，你可能用过一些。



Slide text: I thought React was good.



这个 Javascript 框架不是开源的。它不是开源的原因是它和 React 是同时出现的，我想“这个世界真的需要另一个 JS 框架来选择吗？”。谷歌已经有了一些这样的东西——棱角分明的和聚合物的——感觉再来一个会让人们困惑，所以我想我们还是保密吧。但是除了不开源之外，我认为它还有很多值得学习的地方，值得分享我们一路走来学到的东西。



Picture of lots of people.



那么，让我们来谈谈非常大的应用程序以及它们的共同点。当然可能会有很多开发者。可能有几十个，甚至更多——这些是有感情和人际关系问题的人，你可能必须考虑到这一点。



Picture of very old building.



即使你的团队不是很大，也许你已经工作了一段时间，也许你甚至不是第一个维护它的人，你可能不知道所有的上下文，可能有你不真正理解的东西，你的团队中可能有其他人不理解应用程序的所有内容。这些是我们在构建非常大的应用程序时必须考虑的事情。



Tweet saying: A team of senior engineers without junior engineers is a team of engineers.



我想在这里做的另一件事是给我们的职业生涯一点背景。我想我们很多人会认为自己是高级工程师。或者我们还没有到达那里，但是我们想成为其中一员。我认为高年级意味着我能够解决几乎所有别人可能抛给我的问题。我知道我的工具，我知道我的领域。这项工作的另一个重要部分是，我让初级工程师最终成为高级工程师。



Slide text: Junior -> Senior -> ?



但实际情况是，在某些时候我们可能会想“下一步会是什么？”。当我们到达资历阶段时，我们下一步要做什么？对于我们中的一些人来说，答案可能是管理，但我不认为这应该是每个人的答案，因为不是每个人都应该成为经理，对不对？我们中的一些人真的是伟大的工程师，为什么我们不能在我们的余生都这样做呢？



Slide text: “I know how I would solve the problem”



我想提出一个方法来升级到更高的级别。作为一名高级工程师，我谈论自己的方式是，我会说“我知道我会如何解决问题”，因为我知道我会如何解决问题，所以我也可以教别人去做。



Slide text: “I know how others would solve the problem”



我的理论是，下一个层次是我可以对自己说“我知道其他人会如何解决问题”。



Slide text: “I can anticipate how API choices and abstractions impact the way other people would solve the problem.”



让我们更具体一点。你可以这样说:“我可以预测我所做的 API 选择，或者我引入到项目中的抽象，它们如何影响其他人解决问题的方式。”我认为这是一个强大的概念，它允许我思考我所做的选择如何影响应用程序。



Slide text: An application of empathy.



我称之为移情的应用。你和其他软件工程师一起思考，你在思考你所做的事情和你给他们的 API，它们如何影响他们编写软件的方式。



Slide text: Empathy on easy mode.



幸运的是，这是简单模式下的移情。同理心一般很难，这个还是很难的。但至少你感同身受的人也是其他软件工程师。因此，虽然他们可能与你非常不同，但他们至少有一个共同点，那就是他们都在开发软件。随着你获得更多的经验，这种同理心真的会变得很好。



Slide text: Programming model



考虑到这些话题，有一个非常重要的术语我想讲一下，那就是编程模型——这个词我会经常用到。它代表“给定一套 API、库、框架或工具，人们如何在这种环境下编写软件。”我的演讲实际上是关于，API 等等的细微变化，它们如何影响编程模型。



Slide text: Programming model impact examples: React, Preact, Redux, Date picker from npm, npm



我想举几个影响编程模型的例子:假设你有一个 Angular 项目，你说“我要移植这个来反应”，这显然会改变人们编写软件的方式，对吗？但是你会想“啊，60KB 的虚拟 DOM munging，让我们切换到 Preact”——这是一个 API 兼容的库，它不会改变人们编写软件的方式，只是因为你做出了选择。也许你会想“这真的很复杂，我应该有一些东西来协调我的应用程序如何工作，我要引入 Redux。”–这将改变人们编写软件的方式。然后你得到这个要求“我们需要一个日期选择器”，你去 npm，有 500 个结果，你选择一个。你选哪一个真的重要吗？它绝对不会改变你写软件的方式。但是让 npm 唾手可得，这个巨大的模块集合，拥有它绝对会改变你写软件的方式。当然，这些只是一些可能影响人们编写软件的例子。



Slide text: Code splitting



现在，我想谈谈所有大型 JavaScript 应用程序在交付给用户时的一个共同点:它们最终会变得如此庞大，以至于你不想一次性交付它们。为此，我们都介绍了一种叫做代码分割的技术。代码分割意味着您为您的应用程序定义了一组包。所以，你说“一些用户只使用我的应用程序的这一部分，一些用户使用另一部分”，所以你把只有当用户实际处理的应用程序部分被执行时才被下载的包放在一起。这是我们所有人都能做的事。像许多事情一样，它是由闭包编译器发明的——至少在 JavaScript 世界是这样。但是我认为最流行的代码拆分方式是使用 webpack。如果你使用的是超级棒的 RollupJS，他们最近也增加了对它的支持。这肯定是你们都应该做的事情，但是当你把它引入一个应用程序时，有一些事情需要考虑，因为它确实对编程模型有影响。



Slide text: Sync -> Async



过去同步的东西现在变成了异步的。没有代码分割，你的应用程序就很简单。有一件大事。它开始运行，然后稳定下来，你可以对它进行推理，你不必等待。对于代码分割，你可能有时会说“哦，我需要那个包”，所以你现在需要去网络，你必须考虑到这种情况会发生，所以应用程序变得更加复杂。



Slide text: Human



此外，我们还有人进入这一领域，因为代码拆分需要您定义捆绑包，并且需要您考虑何时加载它们，所以这些人，您团队中的工程师，他们现在必须做出决定什么将进入哪个捆绑包以及何时加载该捆绑包。每当你有一个人参与进来，这显然会影响编程模型，因为他们必须考虑这些事情。



Slide text: Route based code splitting



有一种非常成熟的方法可以解决这个问题，这种方法让人们在进行代码拆分时摆脱混乱，这种方法被称为基于路由的代码拆分。如果你还没有使用代码分割，这可能是你应该做的第一步。路由是应用程序的基线 URL 结构。例如，您可能会在“/product/”上创建产品页面，而在其他地方创建类别页面。您只需将每条路由做成一个包，应用中的路由器现在就知道存在代码分割。每当用户到达一个路由时，路由器加载相关的包，然后在这个路由中，您可以忘记现有的代码拆分。现在，您又回到了编程模型，这几乎等同于对所有东西都有一个大的包。这是一个非常好的方法，也绝对是一个好的开始。

但是这个演讲的题目是设计**非常**大的 JavaScript 应用程序，它们很快变得如此之大，以至于每条路径上的单个包可能不再可行，因为路径本身变得非常大。我实际上有一个足够大的应用程序的好例子。



Google Search query screenshot for “public speaking 101”



我在想如何成为一个演讲的公众演讲者，我得到了这个漂亮的蓝色链接列表。您完全可以想象这个页面非常适合一个单一的路由包。



Google Search query screenshot for “weath”



但后来我想知道天气，因为加州有一个艰难的冬天，突然有这个完全不同的模块。所以，这条看似简单的路线比我们想象的要复杂。



Google Search query screenshot for “20 usd to aud”



然后我被邀请参加这个会议，我正在检查 1 美元是多少澳元，有这个复杂的货币转换器。显然，还有大约 1000 多个这样的专用模块，把它们都放在一个包中是不可行的，因为这个包的大小只有几兆字节，用户会非常不高兴。



Slide text: Lazy load at component level?



因此，我们不能只使用基于路由的代码分割，我们必须想出一种不同的方法来做这件事。基于路径的代码分割很好，因为你在最粗糙的层次上分割了你的应用程序，任何更低层次的东西都可以忽略它。既然喜欢简单的东西，那就做超细粒度而不是超粗粒度的拆分怎么样。让我们想想，如果我们懒惰地加载我们网站的每一个组件，会发生什么。当你只考虑带宽时，从效率的角度来看，这看起来真的很好。从延迟等其他角度来看，这可能非常糟糕，但肯定值得考虑。



Slide text: React component statically depend on their children.



但是让我们想象一下，例如，您的应用程序使用 React。且在反应中组件静态地依赖于它们子组件。这意味着如果你停止这样做，因为你懒于加载你的孩子，那么它会改变你的编程模型，事情不再那么美好。



ES6 import example.



假设你有一个货币转换器组件，你想把它放在你的搜索页面上，你导入它，对吗？这是 ES6 模块中通常的做法。



Loadable component example.



但是如果你想延迟加载它，你会得到这样的代码，你使用动态导入，这是延迟加载 ES6 模块的一个新奇的东西，你把它包装在一个可加载的组件中。当然有 5 亿种方法可以做到这一点，我不是 React 专家，但所有这些都将改变你编写应用程序的方式。



Slide text: Static -> Dynanic



事情不再那么美好了——一些静态的东西，现在变成了动态的，这是编程模型变化的另一个危险信号。



Slide text: Who decides what to lazy load when?



你必须突然想知道:“谁决定什么时候延迟加载”，因为这将影响你的应用程序的延迟。



Slide text: Static or dynamic?



人又出现了，他们必须考虑“有静态导入，有动态导入，我什么时候使用哪个？”。这样做是非常糟糕的，因为一个静态导入，当它应该是动态的时候，可能会突然把不应该是动态的东西放到同一个包中。当你在很长一段时间内拥有很多工程师时，这些事情就会出错。



Slide text: Split logic and rendering



现在，我将谈谈 Google 实际上是如何做到这一点的，以及在获得良好性能的同时获得良好编程模型的一种方法。我们所做的就是把我们的组件按照渲染逻辑和应用程序逻辑分开，就像你按下货币转换器上的一个按钮会发生什么一样。



Slide text: Only load logic if it was rendered.



因此，现在我们有两个独立的东西，我们只在以前呈现组件时加载组件的应用程序逻辑。这是一个非常简单的模型，因为您可以简单地在服务器端呈现一个页面，然后无论实际呈现的是什么，都会触发下载相关的应用程序包。这将人排除在系统之外，因为加载是由渲染自动触发的。



Slide text: Currency converter on search result page.



这个模型看起来不错，但是它也有一些缺点。如果你知道服务器端渲染通常在 React 或 Vue.js 这样的框架中是如何工作的，他们所做的就是一个叫做水合的过程。水合作用的工作方式是，你在服务器端渲染一些东西，然后在客户端再次渲染，这意味着你必须加载代码来渲染已经在页面上的东西，这在加载代码和执行代码方面都是非常浪费的。这是一堆浪费的带宽，这是一堆浪费的 CPU 但这真的很好，因为你可以忽略客户端，你的服务器端渲染的东西。我们在谷歌使用的方法不是这样的。因此，如果你设计这个非常大应用程序，你必须考虑:我是采用更复杂的超快速方法，还是采用效率较低但如此好的编程模型的水化方法？你必须做出这个决定。



Slide text: 2017 Happy New Year



我的下一个话题是我在计算机科学中最喜欢的问题——它不是给事物命名，尽管我可能给它起了个坏名字。就是*“2017 假日特辑题”*。这里有谁曾经写过一些代码，现在不再需要了，但它仍然在你的代码库中？……这种情况时有发生，我觉得 CSS 特别因此出名。你有一个很大的 CSS 文件。那里有一个选择器。谁真的知道这是否仍然匹配你的应用程序中的任何东西？所以，你最终只是把它放在那里。我认为 CSS 社区正处于一场革命的前沿，因为他们意识到这是一个问题，他们创造了像 CSS-in-JS 这样的解决方案。这样你就有了一个单一的文件组件，2017HolidaySpecialComponent，你可以说“现在已经不是 2017 年了”，你可以删除整个组件，所有的东西都消失了。这使得删除代码变得非常容易。我认为这是一个非常大的想法，它应该不仅仅适用于 CSS。



Slide text: Avoid central configuration at all cost



我想举几个例子来说明这个总的想法，你要不惜一切代价避免应用程序的集中配置，因为集中配置，就像有一个集中的 CSS 文件一样，使得删除代码非常困难。



Slide text: routes.js



我之前谈到了您的应用程序中的路线。许多应用程序都有一个类似“routes.js”的文件，其中包含所有的路由，然后这些路由将自己映射到某个根组件。这是集中配置的一个例子，在大型应用程序中不希望出现这种情况。因为有些工程师会问“我还需要那个根组件吗？我需要更新另一个文件，它属于另一个团队。我不确定我能不能改变它。也许我明天会做。这样，这些文件就只能添加了。



Slide text: webpack.config.js



这种反模式的另一个例子是 webpack.config.js 文件，在该文件中有一个假定用来构建整个应用程序的东西。这在一段时间内可能会很好，但最终需要了解其他团队在应用程序中某个地方所做工作的各个方面，这是不可伸缩的。同样，我们需要一种模式来展现如何分散我们构建过程的配置。



Slide text: package.json



这里有一个很好的例子:npm 使用的 package.json。每个包都说“我有这些依赖，这是你如何运行我，这是你如何建立我”。显然，不可能有一个庞大的配置文件适用于所有的 npm。这对于成千上万的文件来说是行不通的。这肯定会在 git 中引起很多合并冲突。当然，npm 非常大，但我认为我们的许多应用程序变得足够大，以至于我们不得不担心相同类型的问题，并不得不采用相同类型的模式。我没有所有的解决方案，但我认为 CSS-in-JS 带来的想法将会出现在我们应用程序的其他方面。



Slide text: Dependency trees



更抽象地说，我会把这个想法描述为:我们负责抽象地设计我们的应用程序，如何组织它，就像*负责塑造我们的应用程序*的依赖树一样。当我说“依赖”时，我指的是非常抽象的。可能是模块依赖，可能是数据依赖，可能是服务依赖，有许多不同的种类。



Slide text: Example dependency tree with router and 3 root components.



显然，我们都有超级复杂的应用程序，但我将使用一个非常简单的例子。它只有 4 个组件。它有一个路由器，知道如何从应用程序的一个路由到下一个路由，它有几个根组件，A、B 和 c。



Slide text: The central import problem.



正如我之前提到的，这存在中心导入问题。



Slide text: Example dependency tree with router and 3 root components. Router imports root components.



因为路由器现在必须导入所有根组件，如果您想要删除其中一个组件，您必须转到路由器，您必须删除导入，您必须删除路由，最终您会遇到 2017 年假日特辑问题。



Slide text: Import -> Enhance



我们谷歌已经想出了一个解决方案，我想向你们介绍一下，我想我们从来没有讨论过这个问题。我们发明了一个新概念。它被称为增强。它是你用来代替进口的东西。



Slide text: Import -> Enhance



其实是进口的反义词。这是一种反向依赖。如果你增强了一个模块，你就让这个模块依赖于你。



Slide text: Example dependency tree with router and 3 root components. Root components enhance router.



查看依赖关系图，会发生什么呢？仍然有相同的组件，但是箭头指向相反的方向。因此，不是路由器导入根组件，而是根组件使用 enhance 向路由器宣告它们自己。这意味着我可以通过删除文件来删除根组件。因为它不再增强路由器，所以这是您删除组件所必须做的唯一操作。



Slide text: Who decides when to use enhance?



如果不是因为人类，那真是太好了。他们现在必须考虑“我是导入某些东西，还是使用 enhance？我在什么情况下用哪个？”。



Image: Danger. Hazardous chemicals.



这是这个问题的特别糟糕的情况，因为增强一个模块的能力，能够使系统中的其他一切都依赖于你，这是非常强大的，如果出错的话是非常危险的。很容易想象这可能会导致非常糟糕的情况。因此，在谷歌，我们认为这是一个好主意，但我们把它定为非法，没有人可以使用它——只有一个例外:生成代码。实际上，它非常适合生成代码，并且解决了生成代码的一些固有问题。使用生成的代码，你有时不得不导入你看不到的文件，不得不猜测它们的名字。然而，如果生成的文件就在阴影中，并且增强了它所需要的任何东西，那么就不会有这些问题。你根本不需要知道这些文件。它们神奇地增强了中央注册表。



Slide text: Single file component pointing to its parts that enhance a router.



我们来看一个具体的例子。这里有我们的单个文件组件。我们在它上面运行一个代码生成器，并从中提取这个小的路由定义文件。而那个路由文件只是说“嘿路由器，我在这里，请导入我”。很明显，你可以将这种模式用于其他各种事情。也许你正在使用 GraphQL，你的路由器应该知道你的数据依赖，然后你可以使用相同的模式。



Slide text: The base bundle



不幸的是，这不是我们需要知道的全部。在计算机科学中，有一个我第二喜欢的问题，我称之为“*一堆垃圾”*。您的应用程序中的包图中的基础包是将总是被加载的包——与用户如何与应用程序交互无关。所以，它特别重要，因为如果它很大，那么再往下的一切也会很大。如果它很小，那么依赖包至少也有可能很小。一个小趣闻:在某个时候，我加入了 Google Plus JavaScript 基础设施团队，我发现他们的基础包有 800KB 的 JavaScript。所以，我给你的警告是:如果你想比 Google Plus 更成功，不要在你的基础捆绑包中放 800KB 的 JS。不幸的是，很容易陷入这种糟糕的状态。



Slide text: Base bundle pointing to 3 different dependencies.



这里有一个例子。你的基础包需要依赖于路线，因为当你从 A 到 B 时，你需要已经知道 B 的路线，所以它必须总是在附近。但是你真的不希望在基础包中包含任何形式的 UI 代码，因为根据用户如何进入你的应用，可能会有不同的 UI。因此，例如，日期选择器绝对不应该在您的基础包中，结账流程也不应该。但是我们如何防止这种情况呢？不幸的是，进口非常脆弱。你可能会天真地导入那个很酷的 *util* 包，因为它有一个生成随机数的功能。现在有人说“我需要一个用于自动驾驶汽车的实用程序”，突然你将用于自动驾驶汽车的机器学习算法导入到你的基础包中。这样的事情很容易发生，因为导入是可传递的，所以随着时间的推移事情会越积越多。



Slide text: Forbidden dependency tests.



我们找到的解决方案是*禁止依赖测试*。禁止依赖测试是一种断言的方式，例如你的基础包不依赖于任何 UI。



Slide text: Assert that base bundle does not depend on React.Component



我们来看一个具体的例子。在 React 中，每个组件都需要从 React.Component 继承。因此，如果您的目标是基础包中不能有 UI，只需添加这个断言 React 的测试即可。组件不是基本包的可传递依赖项。



Forbidden dependencies crossed out.



再看前面的例子，当有人想要添加日期选择器时，您只是得到一个测试失败。这些测试失败通常很容易修复，因为通常那个人并不是真的想要添加依赖关系——它只是通过一些传递路径悄悄进入。相比之下，当这种依赖已经存在 2 年了，因为你没有测试。在这种情况下，通常很难重构代码来摆脱依赖。



Slide text: The most natural path



理想情况下，你会找到最自然路径。



Slide text: Most straightforward way must be the right way.



你希望达到这样一种状态，无论你团队中的工程师做什么，最直接的方式也是正确的方式——这样他们就不会偏离正道，这样他们自然会做正确的事情。



Slide text: Otherwise add a test that ensure the right way,



这并不总是可能的。在这种情况下，只需添加一个测试。但这不是很多人觉得有能力做的事情。但是**请感觉被授权添加测试到您的应用程序，以确保您的基础设施的主要不变量**。测试不仅仅是为了测试你的数学函数是否正确。它们也适用于基础设施和应用程序的主要设计特性。



Slide text: Avoid human judgement outside of application domain.



在应用程序领域之外，尽可能避免人工判断。当开发一个应用程序时，我们必须理解业务，但是并不是你组织中的每个工程师都能够并且愿意理解代码分割是如何工作的。他们不需要这么做。当不是每个人都理解它们并记住它们的复杂性时，尝试以一种好的方式将这些东西引入到你的应用程序中。



Slide text: Make it easy to delete code.



让删除代码变得简单。我的演讲叫做“构建超大型 JavaScript 应用”。我能给出的最好建议是:不要让你的应用程序变得太大。不到达那里的最好方法是在为时已晚之前删除东西。



Slide text: No abstraction is better than the wrong abstraction.



我想再强调一点，那就是人们有时会说完全没有抽象比有错误的抽象要好。这实际上意味着错误抽象的成本非常高，所以要小心。我觉得这有时候被曲解了。这并不意味着你不应该有抽象。这只意味着你必须非常小心。

> 我们必须善于找到正确的抽象概念。



Slide text: Empathy and experience -> Right abstractions.



正如我在演讲开始时所说的:达到这个目的的方法是运用同理心，和你团队中的工程师一起思考他们将如何使用你的 API，以及他们将如何使用你的抽象。经验是你如何随着时间的推移充实那种同理心。综上所述，移情和经验使您能够为您的应用程序选择正确的抽象

如果你觉得这很有趣，可以考虑阅读我关于[设计文档](/@cramforce/design-docs-a-design-doc-a152f4484c6b)的文章或者这篇文章的[续篇“设计更大的应用程序”](/@cramforce/designing-even-larger-applications-460ee029012d?source=friends_link&sk=e732423e46e87029473431067fd066fc)。