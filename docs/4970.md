# 为什么我们从 NoSQL MongoDB 迁移到 PostgreSQL - DZone 数据库

> 原文:[https://dzone . com/articles/why-we-moved-from-no SQL-MongoDB-to-PostgreSQL？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://dzone.com/articles/why-we-moved-from-nosql-mongodb-to-postgresql?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

几年前，我们将我们的[代码库转移到了 monorepo](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository) ，这帮助我们在代码重用和整体开发速度方面实现了巨大的扩展。我们非常自豪能够在零停机升级的情况下运行 99.99%可用性的弹性服务。

从旅程的一开始，我就决定全力以赴将 JavaScript 作为我们的默认编码语言。最重要的原因是我想雇佣全栈开发人员，他们可以处理产品的每个方面，所以我们选择 Angular.js 作为 UI，Node.js 作为 API，以及一个无模式的 JSON 数据库(NoSQL MongoDB)。我们基于这一理念做出了所有的技术决策(另一篇博客讲述了我学到的东西以及为什么我不再是全栈开发的粉丝),而且效果非常好...一段时间。

## 它始于一些小问题...

尽管我们有能力以闪电般的速度添加功能，但我们开始看到偶尔的停机时间，这似乎总是归结于 MongoDB。例如:

*   我们非常高兴 MongoDB 的主实例和辅助实例能够全天候可用。然而，有一天我们的性能突然下降，每个文档的检索时间开始超过一秒钟。我们尝试使用许多工具和分析器，但是无法弄清楚发生了什么。最后，我们重建了一个新的服务器，将它切换为主服务器，并重建了辅助服务器。检索时间再次下降到 150 毫秒。这还是一个未解之谜！
*   我们的 Mongo 实例达到了 4TB，我们为我们不断增长的采用率感到自豪。由于缺乏管理大型数据库的工具，我们依赖索引来降低搜索时间。当 NoSQL DBs 第一次流行时，没有办法创造独特性，所以这些功能是事后才想到的。我们的 MongoDB 的一些膨胀实际上是由于索引，但是重建它们是原始的，并且整个 DB 将被锁定。
*   有一次，我们需要重启我们的数据库服务器 MongoDB 花了四个小时才恢复在线。这导致我们的服务停机时间延长，并且我们对 MongoDB 流程和状态的了解非常少。

## 然后就是击倒拳！

MongoDB 最大的优点和缺点是它有一个灵活的模式。这意味着同一集合中的文档(旧世界中称为“表”)不需要有相同的字段集或结构，集合文档中的公共字段可以保存不同类型的数据。简而言之，没有严格的模式规则，这就为许多牛仔式的修补打开了方便之门。

虽然许多开发人员喜欢这种灵活性，但这也让他们承担了很高的责任来把事情做好。

例如，让我们考虑一个存储 Git 存储库信息的简单模式:

| **字段名** | **添加于** |
| 供应者 | 12/1/2012 |
| 报告组织 | 12/1/2012 |
| repoName | 12/1/2012 |
| isPrivate | 7/17/2014 |
| 有团队 | 2/23/2016 |

正如您所猜测的，随着字段的增加，模式会在一段时间内更新，以满足不断发展的产品的新需求。这意味着根据存储库添加到这个文档的时间，它可能有也可能没有`isPrivate`和`hasTeams`字段。我们的后端和前端服务需要优雅地处理这两种情况，这导致了如下代码:

```
if exists(repo.hasTeams) and repo.hasTeams === true
{
# do something
} else {
# do something
}
```

**在每一个使用`repo.hasTeams`的地方，我们都需要添加这段代码。**随着许多微服务、许多模式和 40 多名开发人员到处添加这些模块，我们的代码库开始变得难看。此外，每次我们看到系统出现故障时，都是一个壮观的崩溃，没有简单的方法来恢复。我敢打赌，90%的崩溃都是由于某段代码需要一个不存在于该文档中的字段。内部头脑风暴提出了构建模式验证器和各种黑客的想法，但这难道不是数据库应该提供的现成功能吗？

一个针对 Mongo(或任何等效的 NoSQL 数据库)的大黑点！

压垮骆驼的最后一根稻草是，我们引入了一个关键字段，它绝对需要出现在我们最重要的集合中的每个文档中。为了确保每个文档都包含该字段，我们必须逐个检索每个文档，更新它，然后放回原处。由于收集了数百万个文档，这一过程导致数据库性能下降到不可接受的程度，我们不得不接受 4 个多小时的停机时间。

就在那时，我决定 NoSQL 不再为我们工作了。每个人都有自己的想法，但是我们已经完成了与它的斗争，并给我们的客户(和我们自己)带来了不必要的痛苦。

## 波斯特格里斯来救援了！

在大约一年前的最后一次事件之后，我们迁移到了 PostgreSQL。如果你感兴趣的话，我可以在另一篇博客中解释一步一步的迁移过程。我们没有遗憾，以下因素极大地提高了我们的可用性和弹性:

*   Postgres 有一个强类型模式，几乎没有出错的空间。首先为表创建模式，然后向表中添加行。您还可以使用规则定义不同表之间的关系，以便可以跨多个表存储相关数据并避免数据重复。所有这一切意味着团队中的某个人可以充当数据库架构师，并控制作为其他人遵循的标准的模式。
*   **您可以在 PostgreSQL 中更改表，而不需要为每个操作锁定它**。例如，您可以添加一列并将值快速设置为`NULL`，而无需锁定整个表。
*   Postgres 还支持 JSONB，它允许您创建非结构化数据——但是具有数据约束和验证功能，以帮助确保 JSON 文档更有意义。Sisense 的人写了一个很棒的博客，详细比较了 JSON 文档的 [Postgres 和 MongoDB】。](https://www.sisense.com/blog/postgres-vs-mongodb-for-storing-json-data/)
*   **由于 Postgres 更高效地存储信息，并且数据不会不必要地跨表重复，我们的数据库大小减少了 10 倍**。
*   正如之前的研究所示，我们发现 **Postgres 在索引和连接**方面表现得更好，结果我们的服务变得更快更敏捷。

自从我们迁移以来，我们对 Postgres 非常满意，我们不再为管理我们的数据库而苦恼。结果，我们看到我们的 NPS 显著上升，因为客户对一个“总是工作”的平台更满意。