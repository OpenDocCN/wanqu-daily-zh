# 如何构建好的软件

> 原文:[https://www.csc.gov.sg/articles/how-to-build-good-software?UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://www.csc.gov.sg/articles/how-to-build-good-software?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

## 为什么坏软件会发生在好人身上

坏软件是世界上少数几件你不能用钱解决的事情之一。十亿美元航空公司的航班搜索应用程序往往不如学生团体开发的应用程序。世界各地的老牌出租车公司都有糟糕的预订应用，尽管它们面临着拼车服务的威胁。令人头疼的企业 IT 系统通常是有着巨额预算的项目，需要花费多年时间来构建。不管坏软件的原因是什么，它似乎不是缺乏资金。

令人惊讶的是，糟糕软件的根本原因与具体的工程选择关系不大，而与开发项目的管理方式关系更大。最糟糕的软件项目通常以一种非常特殊的方式进行:

项目负责人开始时希望构建一个特定的解决方案，但从未明确指出他们试图解决的问题。然后，他们从一大群涉众那里收集一长串需求。然后，这个列表被交给相应的大型外部开发团队，他们开始从头开始构建这个高度定制的软件。一旦所有的需求都满足了，每个人都会庆祝系统的启动和项目的完成。

* * *

##### 糟糕软件的根本原因与具体的工程选择关系不大，更多的是与开发项目的管理方式有关。

* * *

然而，虽然该系统在技术上符合规范，但当它被放到实际用户手中时，就会发现严重的问题。它速度慢，令人困惑，充满了微妙的错误，这使得使用它是一种挫折。不幸的是，此时外部开发团队已经解散，没有剩余的资源来进行必要的修复。几年后，当一个新项目启动时，所有关于这些问题原因的知识都已经离开了组织，循环又开始了。

与李宏毅的对话(上)
*向下滚动查看更多视频*

正确的编码语言、系统架构或界面设计会因项目而异。但是软件有一些特殊的特征，这些特征总是导致传统的管理实践失败，同时允许小型创业公司在预算有限的情况下取得成功:

重用好的软件很容易；它能让你快速建造好的东西；软件并不受限于构建它所投入的资源数量，而是受限于它在崩溃前能变得多复杂；而
软件中的主要价值不是生产出来的代码，而是生产它的人积累的知识。

理解这些特征可能不能保证好的结果，但是它确实有助于澄清为什么如此多的项目产生坏的结果。此外，这些导致了一些可以显著提高成功几率的核心操作原则:

1.开始尽可能简单；
2。找出问题，迭代；和
3。尽可能雇佣最好的工程师。

虽然有许多微妙的因素需要考虑，但是这些原则形成了一个基础，让您开始构建好的软件。

## 重用软件可以让你快速构建好的东西

软件很容易复制。在机械层面上，代码行可以被复制并粘贴到另一台计算机上。更一般地说，互联网上充斥着关于如何使用网上现成的代码模块构建不同类型系统的教程。现代软件几乎从来不是从零开始开发的。即使是最具创新性的应用程序也是使用现有的软件构建的，这些软件经过组合和修改后可以获得新的结果。

可重用代码模块的最大来源是开源社区。开源软件是一种免费发布代码供任何人查看和使用的软件。许多开源社区的最大贡献者都是大型科技公司。如果你想像脸书一样使用最先进的星球可扩展数据库，只需下载他们在 2008 年开源的 Cassandra 代码。如果你想亲自尝试谷歌的前沿机器学习，请下载 2015 年发布的 TensorFlow 系统。使用开源代码不仅可以让你的应用程序开发更快，还可以让你接触到比你自己开发的任何东西都要复杂得多的技术。对于最流行的开源代码，它甚至更安全，因为有更多的人关注和修复漏洞。这就是数字技术取得如此快速进步的原因:即使是最新的工程师也可以在我们专业提供的最先进的工具上进行构建。

云服务的出现进一步提高了可重用性，提供了对专有系统的完全使用，只需支付订阅费。需要一个简单的网站？使用 Squarespace 或 Wix 等网站建设服务，只需点击几下就可以配置一个。一个数据库？从亚马逊网络服务或微软 Azure 订阅一个虚拟的。云服务允许开发者从专业化中获益；服务提供商处理一个可靠的、高质量的软件的设置、维护和持续开发，该软件由它的所有订户使用。这使得软件开发人员不再浪费时间在已解决的问题上，而是专注于交付实际价值。

如果你所有的时间都花在重建现有技术上，你就不可能取得技术进步。软件工程是关于建立自动化系统的，而自动化的第一件事是日常的软件工程工作。关键是要理解什么是可重用的正确系统，如何定制它们以满足您的独特需求，以及解决在此过程中发现的新问题。

* * *

##### 软件工程是关于构建自动化系统的，而自动化首先要做的事情之一就是日常的软件工程工作。

* * *

## 软件受到复杂性的限制

一个软件的有用程度通常受限于它的复杂性，而不是构建它所投入的资源量。

IT 系统通常有很多功能，但仍然被用户讨厌，因为它们变得令人困惑。相比之下，排名靠前的移动应用往往因其简单和直观而受到称赞。学习使用软件很难。超过一点，新特性实际上让用户的情况变得更糟，因为累积的复杂性开始变得难以承受。例如，在作为苹果媒体生态系统的中心近 20 年后，iTunes 今年被拆分为三个不同的应用程序(音乐、播客和电视节目)，因为其功能变得过于复杂，一个应用程序无法处理。从可用性的角度来看，限制不在于可以实现多少功能，而在于一个简单直观的界面能容纳多少功能。

即使忽略了可用性，一旦项目变得过于复杂，工程进展也会慢下来。添加到应用程序中的每一行新代码都有机会与其他行进行交互。一个应用程序的代码库越大，每当构建一个新功能时，就会引入更多的错误。最终，新 bug 产生的工作量抵消了特性开发的工作量。这被称为“技术债务”，是专业软件开发中的主要挑战。这就是为什么许多大型 It 系统的问题多年都没有解决的原因。在项目中增加更多的工程师只会增加混乱:当代码库被自身的重量压垮时，他们开始运行得更快。

* * *

##### 构建好的软件包括扩展和降低复杂性的交替循环。

* * *

在这种情况下，唯一的前进方式是后退一步，合理化和简化代码库。可以重新设计系统架构，以限制意外的交互。即使已经构建了非关键功能，也可以将其删除。可以部署自动化工具来检查错误和写得不好的代码。比尔·盖茨曾经说过“用代码行数来衡量编程进度就像用重量来衡量飞机制造进度一样”。人类的大脑只能处理有限的复杂性，所以一个软件系统能有多复杂取决于这个复杂性预算的使用效率。

构建好的软件包括扩展和降低复杂性的交替循环。随着新功能的开发，无序自然会在系统中累积。当这种混乱开始引发问题时，进度就会暂停，以便花时间清理。这两步过程是必要的，因为没有柏拉图式的好工程:它取决于你的需求和你遇到的实际问题。即使是一个简单的用户界面，如谷歌的搜索栏，也包含着大量的复杂性，不可能在一次迭代中得到完善。挑战在于管理这个循环，让它变得足够混乱以取得有意义的进展，但不要让它变得太复杂以至于变得势不可挡。

* * *

##### 没有柏拉图式的好工程:它取决于你的需求和你遇到的实际问题。

* * *

## 软件更多的是开发知识，而不是编写代码

在软件开发中，大多数想法都是糟糕的；这不是任何人的错。只是可能的想法太多了，以至于任何特定的想法都可能行不通，即使它是非常谨慎和明智的选择。要取得进步，你需要从一堆糟糕的想法开始，丢弃最糟糕的，进化出最有希望的。苹果是远见卓识设计的典范，在最终产品落地之前，它会经历几十个原型。最终产品可能看似简单；这是复杂的知识，为什么这个特殊的解决方案被选择，而不是它的替代品，使它成为好的。

即使在产品被制造出来之后，这些知识仍然很重要。如果一个新的团队接管了一个不熟悉的软件的代码，这个软件将很快开始退化。操作系统会更新，业务需求会改变，并且会发现需要修复的安全问题。处理这些细微的错误通常比一开始就构建软件更难，因为这需要对系统的架构和设计原则有深入的了解。

与李宏毅的对话(第二部分)
*向下滚动查看更多视频*

在短期内，一个不熟悉的开发团队可以用权宜之计解决这些问题。但是，随着时间的推移，由于额外代码的临时性质，新的错误会不断积累。由于不匹配的设计范例，用户界面变得混乱，系统的复杂性整体上增加了。软件不应该被视为静态的产品，而应该被视为开发团队集体理解的生动体现。

* * *

##### 软件不应该被视为静态的产品，而是开发团队集体理解的生动体现。

* * *

这就是为什么依赖外部供应商进行核心软件开发很困难的原因。你可能得到了一个运行的系统和它的代码，但是关于它是如何构建的和做出了什么样的设计选择的无价知识离开了你的组织。这也是为什么把一个系统交给新的供应商进行“维护”经常会导致问题。即使系统被很好地记录，每当新的团队接管时，一些知识就会丢失。随着时间的推移，这个系统变成了许多不同作者的代码的拼凑。坚持跑步变得越来越难；最终，没有人真正理解它是如何运作的。

为了让你的软件长期保持良好的工作状态，让你的员工在外部的帮助下学习，以在你的组织中保留关键的工程知识是很重要的。

## 优秀软件开发的 3 个原则

#### 1.尽可能简单地开始

那些旨在为某个特定领域提供“一站式服务”的项目往往注定要失败。理由似乎很合理:有什么比让你的应用程序解决尽可能多的问题更好的方法来确保你的应用程序解决人们的问题呢？毕竟这对于超市等实体店是行得通的。不同之处在于，一旦实体店建立起来，增加一个新的销售项目相对容易，但拥有两倍功能的应用程序的构建难度是两倍多，使用难度也大得多。

构建好的软件需要专注:从能够解决问题的最简单的解决方案开始。一个制作精良但过于简单的应用程序在添加必要的功能时从来不会有问题。但是一个大的 IT 系统，做了很多糟糕的事情，通常是不可能简化和修复的。即使是像微信、Grab 和脸书这样成功的“什么都做”应用程序，也是从非常具体的功能开始的，只是在巩固了自己的地位后才扩展。软件项目很少因为太小而失败；他们失败是因为他们太大了。

* * *

##### 软件项目很少因为太小而失败；他们失败是因为他们太大了。

* * *

不幸的是，保持一个项目的焦点在实践中是非常困难的:仅仅从所有涉众那里收集需求就已经创建了一个巨大的特性列表。

与李宏毅的对话(第三部)
*向下滚动最后一个视频*

管理这种膨胀的一种方法是使用优先级列表。需求仍然被收集，但是每一个都根据它们是否是绝对关键的特性、高价值的附加物或者最好拥有的东西而被标记。这创建了一个低得多的压力的计划过程，因为特性不再需要被明确地排除。涉众可以更加理智地讨论哪些特性是最重要的，而不用担心项目中遗漏了什么。这种方法也明确了拥有更多功能的利弊。希望提高某个特性优先级的利益相关者还必须考虑他们愿意降低哪些特性的优先级。团队可以从最关键的目标开始，在时间和资源允许的情况下，沿着列表向下进行。

我们对所有最成功的应用程序都遵循类似的流程。Form.gov.sg 一开始是一个手动 Outlook 宏，我们花了 6 个小时为我们的第一个用户设置，但今天已经处理了大约 100 万份公众提交的材料。Data.gov.sg 一开始是一个开源项目的直接拷贝，现在每月访问量已经超过 30 万次。Parking.sg 有一个庞大的列表，上面有近 200 个可能的功能，我们从未抽出时间来构建这些功能，但今天仍然有超过 110 万用户。这些系统很受欢迎，不是因为它们简单，而是因为它们简单。

#### 2.找出问题并迭代

事实上，现代软件如此复杂，变化如此之快，以至于再多的计划也无法消除所有的缺点。就像写一篇好论文一样，笨拙的初稿是必要的，以便对最终的论文有所了解。为了构建好的软件，你需要首先构建坏的软件，然后积极地找出问题来改进你的解决方案。

这从一些简单的事情开始，比如和你想要帮助的人交谈。目标是理解你想要解决的根本问题，避免仅仅基于先入为主的偏见而匆忙找到解决方案。当我们第一次开始研究 Parking.sg 时，我们的假设是执法人员发现不得不不停地对纸质优惠券进行心算令人沮丧。然而，在与一位经验丰富的官员相处了一个下午后，我们发现对于专业人士来说，做这些计算其实很简单。这一次对话为我们节省了几个月的潜在浪费，让我们重新将项目的重点放在帮助司机上。

当心伪装成问题陈述的官僚目标。“司机在处理停车券时感到沮丧”是一个问题。“我们需要为司机开发一个应用程序，作为我们部门家庭数字化计划的一部分”不是。“用户对在政府网站上查找信息有多难感到恼火”是一个问题。“作为数字政府蓝图的一部分，我们需要重建我们的网站，以符合新的设计服务标准”不是。如果我们的最终目标是让公民的生活变得更好，我们需要明确承认那些让他们的生活变得更糟的事情。

有一个清晰的问题陈述可以让你实验性地测试不同解决方案的可行性，这些解决方案在理论上很难确定。与聊天机器人交谈可能不会比浏览网站更容易，用户可能不想在手机上安装另一个应用程序，无论它使国家变得多么安全。对于软件来说，显而易见的解决方案往往有致命的缺陷，直到投入使用时才显现出来。我们的目标还不是制造最终产品，而是首先尽可能快、尽可能便宜地发现这些问题。测试界面设计的非功能实体模型。尝试不同功能的半功能模型。匆忙编写的原型代码可以帮助更快地获得反馈。在这个阶段创建的任何东西都应该被视为是一次性的。这个过程的期望输出不是编写的代码，而是对构建什么是正确的更清晰的理解。

* * *

##### 当心伪装成问题陈述的官僚目标。如果我们的最终目标是让公民的生活变得更好，我们需要明确承认那些让他们的生活变得更糟的事情。

* * *

对正确的解决方案有了很好的理解，您就可以开始构建实际的产品了。您停止探索新的想法，并缩小范围来识别您的特定实现的问题。从少数测试人员开始，他们会很快发现需要修复的明显错误。随着问题的解决，你可以越来越多地向更多的人敞开心扉，他们会发现更深奥的问题。

大多数人只反馈一次。如果你开始向大量的观众发布，每个人都会给你同样明显的反馈，你将无处可去。即使是由最好的工程师提出的最好的产品创意，也会从重大问题开始。目的是反复优化输出，打磨粗糙的边缘，直到出现一个好的产品。

即使在所有这些迭代之后，产品发布后的问题才是最重要的。一个只发生 0.1%的问题在测试中可能不会被注意到。但是一旦你有了一百万用户，每天这个问题得不到解决，你就要面对一千多个愤怒的人。您需要在新的移动设备、网络中断或安全攻击对您的用户造成实质性伤害之前解决这些问题。通过 Parking.sg，我们构建了一系列辅助系统，这些系统持续检查主系统中的任何支付差异、重复停车会话和应用程序崩溃。随着时间的推移，建立一个“免疫系统”可以让你避免在新问题不可避免地出现时不知所措。

总的来说，方法是使用这些不同的反馈循环来有效地识别问题。小的反馈回路允许快速和容易的修正，但是遗漏了更广泛的问题。大的反馈循环捕捉到更广泛的问题，但速度慢且成本高。您希望两者都用，尽可能用紧循环解决问题，同时仍然用宽循环来捕捉意外错误。构建软件不是为了避免失败；它是关于战略性的失败，尽可能快地得到你需要的信息来建造好的东西。

#### 3.尽可能雇佣最好的工程师

拥有优秀工程的关键是拥有优秀的工程师。谷歌、脸书、亚马逊、网飞和微软都运营着数量惊人的世界上最大的技术系统，然而，它们以一些最具选择性的面试流程而闻名，同时仍在激烈竞争招募最强的候选人。随着这些公司的发展，即使是应届毕业生的工资也上涨了很多，这是有原因的，而不是因为他们喜欢送钱。

史蒂夫·乔布斯和马克·扎克伯格都说过，最好的工程师的工作效率至少是普通工程师的 10 倍。这并不是因为优秀的工程师写代码要快 10 倍。这是因为他们做出了更好的决定，节省了 10 倍的工作。

一个好的工程师对他们可以重用的现有软件有更好的理解，因此减少了他们必须从头构建的系统的部分。他们更好地掌握了工程工具，自动化了他们自己工作的大部分常规方面。自动化也意味着解放人类去解决意想不到的错误，这是最好的工程师更擅长的。优秀的工程师自己设计的系统更健壮，更容易被他人理解。这具有乘数效应，让他们的同事更快、更可靠地建立他们的工作。总的来说，优秀的工程师更有效率，不是因为他们产生了更多的代码，而是因为他们做出的决定将你从你不知道可以避免的工作中解救出来。

与李宏毅的对话(四)

这也意味着最好的工程师组成的小团队通常比普通工程师组成的大团队更快地完成工作。他们充分利用可用的开源代码和复杂的云服务，将平凡的任务卸载到自动化测试和其他工具上，这样他们就可以专注于工作中创造性的问题解决方面。他们通过区分关键功能的优先次序和删除不重要的工作来快速测试用户的不同想法。这是经典著作《神话中的*人月*[<sup>1</sup>](#notes)的中心论点:一般来说，增加更多的软件工程师不会让一个项目进行得更快，只会让它变得更大。

* * *

##### 构建软件不是为了避免失败；它是关于战略性的失败，尽可能快地得到你需要的信息来建造好的东西。

* * *

小规模的优秀工程师团队也会比大规模的普通工程师团队产生更少的错误和安全问题。类似于写一篇文章，有越多的作者，就有越多的编码风格、假设和怪癖需要在最终的复合产品中协调，从而暴露出更多的潜在问题。相比之下，由一个更小的优秀工程师团队构建的系统会更简洁、更连贯，也更容易被创建者理解。没有简单就没有安全，而简单很少是大规模合作的结果。

工程工作的协作性越强，工程师就需要越优秀。工程师代码中的问题不仅影响他的工作，也影响他同事的工作。在大型项目中，糟糕的工程师最终会为彼此创造更多的工作，因为错误和糟糕的设计选择会像滚雪球一样产生大量的问题。大型项目需要建立在高效设计的坚实可靠的代码模块上，并有非常清晰的假设。你的工程师越优秀，你的系统在被自身重量压垮之前就能变得越大。这就是为什么最成功的科技公司尽管规模庞大，却坚持要最好的人才。系统复杂性的硬限制不是工程努力的数量，而是它的质量。

## 结论

好的软件开发始于对你想要解决的问题建立清晰的理解。这让您可以测试许多可能的解决方案，并集中在一个好的方法上。通过重用正确的开源代码和云服务，允许立即访问已建立的软件系统和复杂的新技术，可以加速开发。开发周期在探索和整合之间交替，快速而混乱地推进新的想法，然后集中和简化以保持复杂性可控。随着项目的推进，它会在越来越大的人群中进行测试，以消除越来越不常见的问题。对于一个好的开发团队来说，启动是真正的工作加速的时候:应该构建自动化系统的层次，以快速处理问题并防止对实际用户的伤害。最终，尽管软件开发有无限的复杂性，但是理解这个过程为解决如何构建好的软件的复杂性提供了基础。

* * *

关于作者

| 李宏毅领导着一个由工程师、设计师和产品经理组成的团队，他们为公众利益开发技术。他们参与的项目包括 parking . SG——一个取代停车券的应用程序，用于在几分钟内建立在线政府表格的 Form.gov.sg—a 网络应用程序，以及 Data.gov.sg—the 政府的开放数据仓库。在加入公共部门之前，弘毅在谷歌分布式数据库和图像搜索团队工作。在空闲时间，他从事个人项目，如 typographing.com 和 chatlet.com。 |  |

* * *

注意

1.  小佛瑞德·P·布鲁克斯，*神话中的人月:软件工程论文集，周年纪念版*，第二版。(马萨诸塞州波士顿:艾迪森-韦斯利·朗曼出版社，1995 年)。

[返回风气主页](/ethos)