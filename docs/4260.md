# 代码的进化部署在 Reddit - Upvoted

> 原文:[https://Reddit blog . com/2017/06/02/the-evolution-of-code-deployes-at-Reddit/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://redditblog.com/2017/06/02/the-evolution-of-code-deploys-at-reddit/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

**尼尔·威廉姆斯** & **绍拉布·夏尔马**
T5】u/斯普拉达格&u/福克莱点

我们一直在 Reddit 上部署代码。每个工程师都编写代码，让它被审查，签入代码，并定期将其推广到生产中。这种情况每周会发生 200 次，端到端的部署通常不到 10 分钟。

驱动这一切的系统已经进化了很多年。让我们来看看它一直以来是如何变化的(以及如何没有变化)。

## **故事从哪里开始:一致且可重复的部署(2007-2010)**

当前系统的种子是一个名为 *push* 的 Perl 脚本。它写于 Reddit 历史上一个与现在非常不同的时代。整个工程团队在[小到可以容纳在一个小会议室](https://redditblog.com/wp-content/uploads/2010/03/1dff6-table.jpg)。Reddit 还没有上 AWS。该站点运行在固定数量的服务器上，额外的容量必须手动添加，并且由一个名为 r2 的大型整体 Python 应用程序组成。

多年来没有改变的一件事是，请求在负载均衡器上被分类，并被分配给其他相同的应用服务器的特定“池”。例如，[列表](https://www.reddit.com/r/rarepuppers/)和[评论](https://www.reddit.com/r/AskReddit/comments/cq1q2/help_reddit_turned_spanish_and_i_cannot_undo_it/)页面由不同的服务器池提供服务。虽然任何给定的 r2 进程都可以处理任何类型的请求，但是各个池不会受到其他池的流量峰值的影响，并且当它们具有不同的依赖关系时，可能会独立出现故障。

*push* 工具有一个硬编码的服务器列表，是围绕 monolith 的部署过程构建的。它将遍历所有的应用服务器，SSH 进入机器，运行一个预设的命令序列，通过 git 更新服务器上的代码副本，然后重启所有的应用程序进程。本质上(经过大量提炼，不是真正的代码):

```
# build the static files and put them on the static server
`make -C /home/reddit/reddit static`
`rsync /home/reddit/reddit/static public:/var/www/`

# iterate through the app servers and update their copy
# of the code, restarting once done.
foreach $h (@hostlist) {
 `git push $h:/home/reddit/reddit master`
 `ssh $h make -C /home/reddit/reddit`
 `ssh $h /bin/restart-reddit.sh`
}
```

部署是连续的。它一个接一个地通过服务器。听起来很简单，但这实际上是一件好事:它允许一种金丝雀部署的形式。如果您部署到几个服务器，并注意到一个新的异常出现，您会知道您引入了一个 bug，可以在影响所有请求之前中止(Ctrl-C)并恢复。因为易于部署，所以很容易在生产中进行尝试，并且如果不成功，恢复起来也很容易。这也意味着一次只需要进行一次部署，以确保新的错误来自于你的部署，而不是 T2 的部署，所以更容易知道什么时候恢复什么。

这对于确保部署的一致性和可重复性非常重要。它跑得相当快。一切都很好。

## **一帮新人(2011)**

然后我们雇佣了一群人，发展到 6 名工程师，现在可以挤在一个稍微大一点的会议室里。我们开始觉得有必要围绕部署进行更好的协调，尤其是当个人在家工作时。我们修改了*推送*工具，通过 IRC 聊天机器人宣布何时开始和结束部署。这个机器人只是坐在 IRC 里宣布事件。实际进行部署的过程看起来是一样的，但是现在系统为您做了工作，并告诉每个人您在做什么。

这是我们将聊天用于部署工作流的开始。这个时候有很多关于从聊天室管理部署*的系统的讨论，但是因为我们使用第三方 IRC 服务器，我们不能完全信任聊天室的生产控制，所以它仍然是单向的信息流。*

随着网站流量的增长，支持网站的基础设施也在增长。我们有时不得不推出一批新的应用服务器并投入使用。这仍然是一个非常手动的过程，包括在*推送*中更新主机列表。

当我们增加容量时，我们通常会一次增加几台服务器。这样做的结果是，依次遍历服务器列表将会快速连续地接触到同一个池中的多个服务器，而不是不同的混合。

我们使用 [uWSGI](https://uwsgi-docs.readthedocs.io/en/latest/) 来管理工作进程，所以当我们告诉应用程序重启时，它会终止现有的进程并启动新的进程。新的池需要一些时间来准备好为请求提供服务，再加上一次只针对一个池，这将影响该池为请求提供服务的能力。因此，我们可以安全部署到服务器的速度有限。随着服务器列表的增长，部署的长度也在增长。

## **重新设计的部署工具(2012)**

我们对现在用 Python 编写的部署工具进行了一次彻底的检查，这个工具也叫做 *push* 。新版本有几处重大改进。

首先，它从 DNS 获取主机列表，而不是硬编码。这允许我们更新主机列表，而不必记得更新部署工具——一个基本的服务发现系统。

为了帮助解决顺序重启的问题，我们在部署之前打乱了主机列表。因为这会混淆服务器池，所以它允许我们以更高的速度安全地滚动，从而更快地部署。

最初的实现每次都是随机的，但是这使得快速恢复代码变得很困难，因为您不会每次都部署到相同的前几个服务器上。所以我们修改了 shuffle，使用一个种子，在恢复时可以在第二次部署中重用。

另一个小但重要的变化是总是部署代码的固定版本。该工具的以前版本会更新给定主机上的*主机*，但是如果*主机*因为有人不小心推送了代码而在部署过程中改变了，该怎么办？通过部署特定的 git 修订版而不是分支名称，我们确保了在生产中的任何地方部署都获得了相同的版本。

最后，新工具区分了它的代码(主要是主机列表和进入它们)和正在运行的命令。它仍然严重偏向于 r2 的需求，但是它有一个各种各样的 API 原型。这允许 r2 控制它自己的部署步骤，这使得向构建和发布流程推出变更变得更加容易。例如，下面是可能在单个服务器上运行的内容。确切的命令是隐藏的，但顺序仍然是 r2 的工作流程所特有的:

```
sudo /opt/reddit/deploy.py fetch reddit
sudo /opt/reddit/deploy.py deploy reddit f3bbbd66a6
sudo /opt/reddit/deploy.py fetch-names
sudo /opt/reddit/deploy.py restart all
```

取名字的事情是 r2 独有的事情！

## **自动缩放器(2013)**

然后我们决定实际上使用云技术和 autoscale(这是另一篇博文的主题)。这让我们在网站不太繁忙时节省了大量资金，并自动增长以满足意外需求。

以前的改进自动从 DNS 获取主机列表，这是一个自然的过渡。主机列表的变化比以前频繁得多，但对工具来说没有什么不同。最初作为生活质量的东西变成了能够启动 autoscaler 的一部分。

然而，自动缩放确实带来了一些有趣的边缘案例。没有免费的午餐。如果在部署过程中启动服务器，会发生什么情况？我们必须确保每个新启动的服务器都签入新代码，如果有的话。服务器在部署中期退出怎么办？该工具必须变得更加智能，以检测服务器何时合法地离开，而不是部署过程本身出现问题，应该发出警报。

顺带一提的是，我们也是在这个时候因为各种原因从 uWSGI 切换到 [Gunicorn](http://gunicorn.org/) 的。就部署而言，这并没有真正产生影响。

事情就这样继续着。

## **太多的服务器(2014 年)**

随着时间的推移，为高峰流量提供服务所需的服务器数量不断增加。这意味着部署时间越来越长。在最糟糕的情况下，正常部署需要将近一个小时。这不太好。

我们重写了部署工具以并行处理主机。新版本叫做*。*旧工具花费了大量时间来启动 ssh 连接并等待命令完成，因此安全数量的并行化允许更快的部署。这立即将部署时间再次缩短至 5 分钟。

为了减少一次重启多个服务器的影响，部署工具的 shuffle 变得更加智能。它不是盲目地调整服务器列表，而是以最大限度地将服务器从每个池中分离出来的方式来交错服务器池。更有意识地减少对现场的影响。

新工具最重要的变化是部署工具和驻留在每个服务器上的工具之间的 [API 被更加清晰地定义，并且与 r2 的需求分离。这样做的初衷是为了更加开源友好，但不久之后它就变得非常有用了。下面是一个部署示例，突出显示的命令是远程执行的 API。](https://github.com/reddit/rollingpin/blob/master/example-deploy.py)

## **人太多(2015)**

突然间，似乎有很多人同时在 r2 上工作。这很好，意味着更多的部署。遵守一次一个部署的规则变得越来越困难，单个工程师不得不口头协调他们发布代码的顺序。为了解决这个问题，我们向聊天机器人添加了另一个功能，协调部署队列。工程师会请求部署锁，要么得到它，要么被放入队列。这有助于维持部署中的秩序，并让人们在等待锁定时放松一下。

随着团队的成长，另一个重要的补充是[在中心位置](https://codeascraft.com/2010/12/08/track-every-release/)跟踪部署。我们修改了 deploy 工具，向 Graphite 发送一个指标，这样就很容易将部署与指标的变化联系起来。

## **两项(多项)服务(2015 年也)**

就在这时，我们突然有了第二项服务上线。该网站的新手机版即将上线。这是一个完全不同的堆栈，有自己的服务器和构建流程。这是对部署工具的解耦 API 的第一次真正测试。随着在每个项目的不同位置执行构建步骤的能力的增加，它保持不变，我们能够在同一个系统下管理两个服务。

## **25 多项服务(2016)**

在接下来的一年中，我们看到了 Reddit 团队的爆炸性增长。我们从两个服务团队发展到几十个，从两个团队发展到十五个团队。我们的大部分服务要么建立在我们的后端服务框架[基板](https://github.com/reddit/baseplate)上，要么建立在类似于移动网络的节点应用程序上。部署基础设施对他们来说是通用的，更多的将很快上线，因为 *rollingpin* 不关心它正在部署什么。这使得用人们熟悉的工具开发新的服务变得容易。

## **安全网(2017)**

随着专用于 monolith 的服务器数量的增加，部署时间也增加了。我们希望部署高并行数，但这样做会导致应用服务器同时重启太多。因此，我们的能力不足，无法处理传入的请求，使其他应用服务器超载。

Gunicorn 的主进程使用了与 uWSGI 相同的模型，并将立即重新启动所有工作进程。当新的工作进程正在启动时，您不能为任何请求提供服务。我们的 monolith 的启动时间从 10-30 秒不等，这意味着在此期间，我们将无法满足任何要求。为了解决这个问题，我们用 Stripe 的工人管理器 [Einhorn](https://github.com/stripe/einhorn) 替换了 gunicorn 主进程，而[保留了 gunicorn 的 HTTP 堆栈和 WSGI 容器](https://github.com/reddit/reddit/blob/master/r2/r2/lib/einhorn.py)。Einhorn 通过产生一个新的工作进程，等待它声明自己准备好，然后获取一个旧的工作进程，并重复直到所有工作进程都被升级。这创建了一个安全网，并允许我们在部署期间达到最大容量。

这个新模型引入了一个不同的问题。如前所述，更换和启动一个工作人员可能需要 30 秒。这意味着，如果你的代码有一个 bug，它不会马上显现出来，你可能会通过很多服务器。为了防止这种情况，我们引入了一种方法来阻止部署转移到另一台服务器上，直到所有工作进程都重新启动。这是通过简单地轮询 einhorn 的状态并等待直到所有新工人都准备好。为了保持速度，我们只是增加了并行度，现在这样做是安全的。

这种新机制允许我们同时部署到更多的机器上，尽管需要额外的安全等待，但大约 800 台服务器的部署时间缩短到了 7 分钟。

## **回顾过去**

这种部署基础设施是多年逐步改进的产物，而不是任何单一的大规模专门努力的结果。历史的阴影和每一步的权衡在当前系统和过去的任何时候都是可见的。这种进化的方法有利也有弊:在任何给定的时间里都不那么费力，但是我们最终可能会走进死胡同。关注你的发展方向是很重要的，这样你才能继续朝着有用的方向前进。

## **未来**

Reddit 的基础设施需要支持团队成长，并不断构建新的东西。公司的增长率是 Reddit 历史上最高的，我们正在从事比以往更大更有趣的项目。我们今天面临的重大问题有两个方面:提高工程师的自主性，同时维护生产基础设施中的系统安全性，以及为工程师发展一个安全网，使他们能够放心地快速部署。

如果这些听起来很有趣，或者如果你只是想部署一堆代码，来加入我们的 Reddit 吧！在我们的[职业页面](https://about.reddit.com/engineering/#hiring)上查看我们的空缺职位列表。如果你想和作者讨论这篇文章，请前往 [r/programming](https://www.reddit.com/r/programming/comments/6exoa4/the_evolution_of_code_deploys_at_reddit/) ！