# 开发人员是如何把密码安全搞错的

> 原文:[https://blog . cloud flare . com/how-developers-get-password-security-so-error/？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://blog.cloudflare.com/how-developers-got-password-security-so-wrong/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)

![leakypipes-1](../Images/59eee760d4559c38eb70889fd1a5d2cf.png)

无论是在现实生活中，还是在网上，我们都有需要证明自己的时候——我们需要确认我们就是我们所说的那个人。这可以通过三件事来实现:

*   你*知道的事情*
*   你*有的东西*
*   你*是*的东西

密码是你*知道*的一个例子；它们在 1961 年被引入，用于麻省理工学院分时计算机的计算机认证。不久之后，一名博士研究员攻破了这个系统(通过能够简单地下载一个未加密的密码列表),并使用了计算机上分配给其他人的时间。

随着时间的推移；开发人员继续不安全地存储密码，用户也继续设置薄弱的密码。尽管如此，还没有为密码安全创造出可行的替代方案。迄今为止，由于研究人员很少考虑现实世界的限制，还没有创建出保留密码提供的所有好处的系统。比如说；当使用指纹进行身份验证时，工程师通常会忘记，有相当一部分人没有可用的指纹或硬件升级成本。

### 破解密码

在 20 世纪 70 年代，人们开始思考如何更好地存储密码，加密哈希开始出现。

加密散列像活板门一样工作；虽然散列一个密码很容易，但是将这个“散列”变回原来的输出要困难得多(或者对于一个理想的散列算法来说在计算上很困难)。它们被用在很多事情上，从加速文件搜索，到银行的一次性密码生成器。

理想情况下，密码应该使用专业的哈希函数，如 Argon2、BCrypt 或 PBKDF2，它们被修改以防止彩虹表攻击。

如果您使用 SHA-1 散列算法对密码`p4$$w0rd`进行散列，输出将是`6c067b3288c1b5c791afa04e12fb013ed2e84d10`。每次运行该算法时，输出都是相同的。因此，攻击者能够创建彩虹表，其中包含常见密码的哈希，然后这些信息被用来破解密码哈希(其中密码和哈希列在彩虹表中)。

BCrypt 之类的算法本质上是在使用随机字符串散列密码之前加盐密码。这个随机字符串与密码哈希一起存储，用于通过使输出唯一来帮助密码更难被破解。哈希过程重复多次(由难度变量定义)，每次都将随机盐添加到哈希的输出中，并重新运行哈希计算。

比如说；BCrypt hash `$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy`以`$2a$10$`开始，表示使用的算法是 BCrypt，包含一个随机的`N9qo8uLOickgx2ZMRZoMye`盐和一个结果 hash`IjZAgcfl7p92ldGxad68LJZdL17lhWy`。当输入已知时，存储 salt 允许同样地重新生成密码散列。

可惜；加盐已经不够了，使用现代图形处理器(专门反复做同样的任务)破解密码可以越来越快。当一个网站遭到安全攻击时，用户的密码可以在数据库转储中离线，以便在离线时被破解。

另外；未能限制登录请求或使用验证码的网站可能会受到暴力攻击。对于给定的用户，攻击者将重复尝试不同的(但相同的)密码，直到他们获得对给定用户帐户的访问权。

有时，网站会在几次登录尝试失败后将用户锁在门外，相反，在尝试了最常见的一组密码后，攻击可以针对快速转移到新帐户。可以尝试使用如下列表(在某些情况下有很多很多密码)来破坏帐户:

![common-weak-passwords](../Images/f46bd2fc15cdf9a44fbcf1fd937a08e0.png)

业界试图通过要求密码组成规则来解决这个问题；要求用户在设置密码之前遵守复杂的规则(要求最少数量的数字或标点符号)。研究表明，这项工作无助于解决密码重复使用、弱密码或用户将个人信息放入密码的问题。

#### 凭据填充

虽然看起来这对于密码存储能力差的网站来说只是一个不好的迹象，但凭据填充让这个问题变得更糟。

用户在不同网站之间重复使用密码是很常见的，这意味着来自受损网站的用户名和密码可以用来破坏更重要的信息，如在线银行网关或政府登录。当密码被重复使用时——只需一个网站被攻破，就可以访问用户拥有凭证的其他网站。

![this-is-not-fine-009-a7b6e6](../Images/5197362fc3ce1666d31bafaecd803041.png) <small> [这不细——笔尖](https://thenib.com/this-is-not-fine)</small>

### 修复密码

要解决这个问题，基本上需要做三件事:

*   改善用户决策的良好 UX
*   改善开发人员教育
*   消除被破解密码的重复使用

#### 我如何保护自己(或我的用户)？

在讨论我们正在做的事情之前，我想简要地讨论一下你现在可以做些什么来帮助保护自己。对于大多数用户来说，有三个步骤你可以立即采取来帮助自己。

使用密码管理器(如 1Password 或 LastPass)为每个网站设置随机的唯一密码。此外，尽可能启用双因素身份验证；除了你*知道的密码*之外，它还使用你*拥有的*来验证你。这意味着，除了密码之外，你还必须从手机等设备上输入一个短期密码，才能登录任何网站。

世界上许多最流行的社交媒体、银行和购物网站都支持双因素身份认证。你可以在[turnon2fa.com](https://www.turnon2fa.com/tutorials/)的热门网站上找到如何启用它。如果您是开发人员，您应该努力确保支持双因素身份验证。

为您的密码管理器设置一个安全易记的密码；是的，为它启用双因素身份验证(并保证备份代码的安全)。你可以在我的博客文章中找到额外的安全提示(包括如何创建安全主密码的提示):[简单网络安全提示](https://blog.cloudflare.com/cyber-security-advice-for-your-parents/)。

开发人员应该废除糟糕的实践组合规则(并尽可能简化它们)。密码过期策略弊大于利，所以寻求废除它们。如需了解更多信息，请参考英国国家网络安全中心的博客文章:[强制常规密码过期的问题](https://www.ncsc.gov.uk/articles/problems-forcing-regular-password-expiry)。

最后；Troy Hunt 有一篇关于用户和开发人员密码的精彩博文:[密码进化:现代时代的认证指南](https://www.troyhunt.com/passwords-evolved-authentication-guidance-for-the-modern-era/)

#### 改善开发人员教育

开发人员应该寻求在他们工作的组织中建立一种安全文化；尝试谈论安全性，谈论挑战恶意登录请求的好处，并以简单的术语谈论密码哈希。

如果您正在处理一个处理身份验证的开源项目；暴露简单的密码哈希 APIs 例如现代 PHP 版本中的`password_hash`、`password_​needs_​rehash`、&、`password_verify`函数。

#### 消除密码重复使用

我们知道复杂的密码组合规则在很大程度上是无效的，最近的指南也效仿了这种做法。一个更好的替代组合规则的方法是阻止用户使用已知已被破解的密码注册。根据[最新的 NIST 指南](https://pages.nist.gov/800-63-3/sp800-63b.html)，在存储或更新密码时，需要确保它们不包含常用、预期或泄露的值。

这说起来容易做起来难，Troy Hunt 的 *Pwned Passwords* 数据库的最新版本包含超过 5 亿个密码(超过 30 GB 未压缩)。虽然开发人员可以使用 API 服务来检查密码是否被重用，但这需要发送原始密码，或者在未加盐的哈希中发送密码。当一个企业中有多个服务处理身份验证，并且每个服务都必须存储大量密码时，这尤其成问题。

这是我最近开始研究的一个问题；作为我们对 Troy Hunt 的 *Pwned Passwords* 数据库的贡献的一部分，我设计了一个*范围搜索* API，它允许开发人员检查一个密码是否被重用，而不需要共享密码(即使是以散列的形式)——相反只需要发送所使用的加密散列的一小段。你可以在帖子中找到更多关于这一贡献的信息:[用 k-匿名验证泄露的密码](https://blog.cloudflare.com/validating-leaked-passwords-with-k-anonymity/)。

第二版 *Pwned 密码*现已发布——你可以在 Troy Hunt 的博客文章“[我刚刚发布了 Pwned 密码，第二版](https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/)”中找到更多关于它如何工作的信息。