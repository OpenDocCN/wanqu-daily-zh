# 史蒂夫的博客咆哮道:丰富的程序员食物

> 原文：<https://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

|  | 橄榄园:穷人去那里吃富人的食物。
*—戴夫·耶格* |

这是另一个我已经坐了很久的博客话题，试图找到一种礼貌的方式来表达一些根本不礼貌的事情。我看不出做这件事的方法。所以:你很有可能被这篇博客文章冒犯了。(嘿，别说我没警告你。)

顺便说一下，我已经关闭了博客评论，因为聪明的坏人已经知道如何使用非算法的方法来击败验证码，而我自己没有带宽来管理垃圾邮件。抱歉。

我不想让你心脏病发作，所以我会在前面给你一个温和而坚定的执行摘要。如果你能在没有明显心跳加速的情况下完成我的执行摘要，那么你可能就没事了。否则，你可能会考虑在读这篇文章之前狂饮一番，就像老电影中人们需要锯掉腿时所做的那样。我就是这么做的，无论如何(喝酒，也就是不锯腿)。

*Gentle, yet insistent executive summary:*

如果你不知道编译器是如何工作的，那么你就不知道计算机是如何工作的。如果你不能 100%确定你是否知道编译器是如何工作的，那么你就不知道它们是如何工作的。

你必须

*know*

你知道，你知道。

事实上，在我个人看来，编译器构造是大学计算机科学课程中第二重要的计算机科学课程。

因为在过去一年左右的时间里，我在这个话题上的每一次深入尝试都完全无法在我清醒后说服我，我将把这部作品作为，呃，舞台作品，有 N 个辉煌的，呃，部分，由幕间休息分开。所以废话不多说...

实际上，听起来工作量太大了。所以我只会咆哮。反正这是你花大价钱听的，对吧？我保证会取笑别人，以至于当我取笑你时，你几乎不会注意到。

**Cots and Beards**

我在学校学过编译器。没错。确实如此。来自华盛顿大学的大卫·诺特金教授，大约在 1991 年末左右。

猜猜我得了多少分？我得了零分。比如 0.0。在我的成绩单上，那是我的期末成绩。这就是在华盛顿大学发生的事情，当你得到一个不完整的，不采取必要的纠正措施(顺便说一下，我从来没有弄明白。)经过一段时间后，它变成零。

你可以通过各种合法的方式得到一个未完成的课程，包括我的方式，那是一个考虑不周的傻瓜，他学了一门课程超过了截止日期，然后决定不完成它，因为他不喜欢它。我

*earned*

那不完整，我告诉你。

几年后我又考了编译器。我在大学里呆了很长时间，因为我在毕业前一年被 Geoworks 聘为全职员工(还有其他原因)，这让我的毕业时间延长了好几年。

顺便说一句，别那么做。当你全职工作时，真的很难完成。拿到你的学位，

*then*

去工作吧。如果你是一名即将完成学业的博士候选人，那就更是如此。你不想下半辈子只是另一个乞丐。即使你本身不难过，我们也会为你难过。

第二次我在编译器上得了一个不错的分数。实际上，第一次我对编译器的理解相当肤浅，第二次就不那么糟糕了。我多年来没能理解的是，我告诉你这些是为了让你免受痛苦

*why*

编译器实际上首先很重要。

这是我 1991 年拿回来时的想法。看看听起来是否耳熟。我认为:编译器是一种工具

*my*

程序，在抱怨了很多之后，把它变成了计算机语言。如果你想写程序，那么编译器就是你需要的东西之一。你需要一台电脑，一个键盘，一个账户，一个编译器，一个编辑器，可选的一个调试器，你已经准备好了。你知道如何编程。你是个程序员。现在你只需要学习 API 什么的。

每当我考虑是否需要学习编译器时，我会想:我需要知道编译器在两种情况下是如何工作的。第一种情况是，我去了微软工作，不知何故，最后加入了 Visual C++团队。然后我需要知道编译器是如何工作的。第二个场景是，我突然有一种冲动，想要留长胡子，停止洗澡，去麻省理工学院朝圣，在那里我恳求理查德·斯托尔曼让我住在走廊的小床上，像耶稣会的流浪汉一样和他一起研究 GCC。

当时，这两种情况对我来说似乎都不太可能，尽管如果到了紧要关头，与在微软工作相比，一张帆布床和一把胡须似乎并不那么糟糕。

顺便说一句，很久以前，我哥哥戴夫参加过一次聚会，参加聚会的微软人太多了，显然有一些人在那里吹牛(这是一个

*party*

注意，他在 Visual C++团队中有 15 名世界上最好的编译器作者为他工作。我告诉戴夫:“哇，我不知道理查德·斯托尔曼在微软工作”，戴夫很失望，因为他当时没有想到那个特别的反驳。事情是这样的。

这个故事的悲哀之处在于，我发现自己偶尔想吹嘘自己在谷歌与世界上一些最好的编译器作者一起工作。拜托，我求你了:如果你发现我在一个聚会上吹嘘和我一起工作的编译器编写者，可怜可怜我们吧，把我当场打死。如果有必要的话，用灯砸我的头。

不管怎样，现在你知道我在 1991 年对编译器的看法了。我自己都不明白为什么要选这门课。但是我没有完成。第二次，我这样做只是因为我对第一次感到很难过:不是从零开始，而是因为让大卫·诺特金失望了，我只是花时间去理解足够好的材料，以一个体面的分数完成课程。

我绝不是非典型的。如果你是一名计算机科学的学生，并且热爱编译器(有趣的是，这通常意味着你是世界范围内你班上计算机科学专业的前 5%的学生)，那么我向你致敬。我打赌我比你更擅长网络黑客。事实上，大多数程序员和我一样，我真的不能责怪他们。

在我永远离开这个肮脏的故事之前，我觉得有必要指出

*partly*

学术界的错。除了类型系统研究之外，编译器在学术界已经失宠很长时间了，因为类型系统研究受到了与亚瑟的圣杯探索大致相同的学术谨慎和约束。因此，商学院在营销编译器方面做得不好，也没有把它们作为一个重要话题给予应有的认可。令人难过的是，大多数学校不要求你为了获得计算机科学学位而学习编译器。

叹气。

**How Would You Solve...**

你是程序员，对吗？好吧，我会为你提出一些编程情况，你告诉我你会如何解决它们。

情况 1:你正在进行大量的 Java 编程，你的公司对于如何格式化你的 Java 代码，包括每一个可以想象到的细节，都有明确的、不可协商的指导方针。你如何配置你的编辑器来根据风格指南自动格式化你的代码？

情况 2:你的公司做了大量的 Ajax 工作，你的 JavaScript 代码库几乎和你的其他代码增长一样快。您决定开始使用 jsdoc，一种用于 JavaScript 的 javadoc 伪克隆，以一种允许自动提取文档的方式记录您的函数。您发现 jsdoc 是一个可怜的 Perl 脚本，seg 在您大约 50%的代码基础上犯了错误，并且——请原谅——您发誓再也不写 Perl 了，因为，好吧，它是 Perl。挑选你最喜欢的理由。你如何编写自己的 jsdoc 提取器，记住它至少需要对 JavaScript 代码本身进行粗略的解析？

情况 3:你的公司有一个庞大的 C++代码库，这是几十个，甚至几百个工程师多年努力的结果。您发现代码需要以一种非同寻常的方式进行重构，例如，从 32 位升级到 64 位，或者改变您处理数据库事务的方式，或者(上帝保佑您)，因为您正在升级您的 C++编译器，语法和语义都发生了变化

*again*

。你的任务是修复它。你是做什么的？

场景 4:你公司的某人编写了一个基于 web 的代码评审工具。每个人都改用它。在使用了一段时间后，您意识到您错过了它的语法——为您突出显示源代码。你没有太多的时间，但你也许能抽出一周左右的时间，兼职，来实现它。你是怎么做到的？(假设你的公司 99%的代码使用五到八种语言。)

情况 5:在您当前的项目中出现了一个意想不到的、有点奇怪的新需求:您需要能够使用一种新的硬件路由器。也许你所有的 Web 2.0 的东西正在搞乱你的边界路由器或网络带宽监视器，谁知道呢。你只知道系统操作员和网络工程师告诉你，你需要直接与这些新路由器对话。路由器有 IP 地址、telnet 接口和专有命令语言。你发送命令，他们发送响应。每个命令都有自己的参数语法，您需要解析响应(没有文档化的格式，但是您可以对其进行逆向工程)来寻找特定的模式，以便为您古怪的上传或下载设置正确的状态。你用什么工具？

情况 6:你公司的项目开始下滑。工程师都很聪明，他们都在使用最新最好的敏捷面向对象软件工程原则和编程语言。他们完全没有过错。然而，由于某些原因，你的代码库变得如此复杂，以至于项目评估会严重出错。简单的任务似乎要花很长时间。工程师们开始讨论重新设计。这是他们在过去五年中经历的第 n 次这样的重新设计，但是

*this*

将会是解决所有问题的大事件。你给他们什么颜色的纸条？哦，咳咳，对不起，我的意思是这次你如何确保他们成功？

情况 7:你有一个小而轻的创业公司，里面满是酷的年轻人，留着蓝色长发，戴着鼻环和舌钉，穿着时髦的黑色衣服，拿着 iphones，还有现在年轻人拥有的其他东西。你的站点使用 Ruby on Rails，它可以很好地适应你的访问者数量。(你从来没有费心去衡量你的访问者数量是否是你的网站延迟的函数，因为你从来没有想过要去怀疑。)您已经了解了最新的可怕的 godawful Rails 安全漏洞，根据该漏洞，用户可以通过向您的公共网站发送适当格式的 GET 请求，代表您的公司任意向 SEC 提交文件。您下载新版本并阅读单元测试代码，以找出实际的漏洞是什么，因为他们没有说，您确定您需要进行一组重要的代码更改，以从您的代码库中删除特定的(并且神秘地不可 greppable)习语，通过机械转换到不同的习语来替换它。你是怎么做到的？

情况 8:某个喝醉的博主给你呈现了七种怪异的情况，并让你推测它们有什么共同点。你已经知道答案了吗？

以下是答案。什么，你认为这些是修辞？

场景#1:您游说您的公司更改样式指南，以匹配 Eclipse 默认的样式。

场景#2:您向 jsdoc 邮件列表发帖，询问是否有其他人遇到过这个问题。一些人说他们有，这个问题几乎当场就消失了。

场景 3:你辞职了。咄。在你到达第一个逗号之前，你就知道那是答案。

场景#4:坚持到底。颜色是给胆小鬼的。或者，您可能连接了 GNU Source Highlight，它涵盖了从 Fortran 到 Ada 的所有语言，您只能忍受它提供的不完整的突出显示。

场景#5: Perl。这是一把瑞士军刀。你可以用它来回避这个问题，通过取出你自己的内脏。

场景 6:粉红色。

场景#7:手动修复。见鬼，你整个网站只有大约 10k 行代码。它是

*Rails*

大声哭出来。这是一个棘手的问题。

场景 8:是的。你浏览到博客的结尾，只是为了找出第一个最重要的 CS 课程是什么。史蒂夫因这种粗俗的笑话而出名。

现在你知道了。您现在已经准备好处理您可能遇到的几乎所有编程情况。所以你显然不需要了解编译器。

**How Compilers Work**

当被问及编译器如何工作时，这里有一些来自现实生活中的计算机科学博士候选人的现实生活答案。

真正的候选人#1:“哦！他们，啊，嗯，一次扫描你的程序一行，把每一行都转换成汇编语言。”

真正的候选人#2:“编译器检查你程序中的错误，并告诉你是否有错误的语法。我只记得这些。”

真正的候选人#3:“我...<3-minute pause>...我不知道。”

真正的候选人#4:“他们预处理你的程序，把#DEFINE 语句转换成代码，然后，嗯，发出机器码。”

这几乎是你能从 75%的面试者那里得到的所有细节，因为，嘿，他们不想在麻省理工学院的走廊里工作。你能责怪他们吗？

只有大约 3%到 5%的面试候选人(这是乐观的说法)能告诉你编译器如何工作的任何细节。其他人可能会对 lex 和 yacc 以及代码生成做些手脚。

我

*told*

你的心率会加快。我没有吗？

深呼吸。

**Why Compilers Matter, Part 1**

编译器构造是一门如此重要的 CS 课程的第一个原因是，它以一种非常具体的方式汇集了你在选修这门课之前所学的几乎所有东西。

不了解机器架构就无法完全理解编译器是如何工作的，因为编译器发出的是机器码。它不仅仅是指令；为了有效地翻译你的源代码，编译器需要理解底层机器实际上是如何工作的。

顺便说一句，“机器”几乎是任何可以进行计算的东西。Perl 是一台机器。你的操作系统是一台机器。Emacs 是一台机器。如果你能证明你的洗衣机是 Turing complete，那么你可以写一个编译器在上面执行 C 代码。

但是你已经知道了。

如果不知道操作系统是如何工作的，你就无法理解现代编译器是如何工作的，因为现在没有一台有自尊的机器是在没有操作系统的情况下运行的。操作系统接口是目标机器的一部分。当然，你可以找到从事 5 到 10 年大型机项目的人，他们最终的运行速度并不比好市多的个人电脑快，而且他们可能会因为时间限制而放弃操作系统，再加上他们拥有一个全球市场的事实。但是对于我们大多数人来说，操作系统是机器的一部分。

除非你学过计算理论课程，否则你不会理解编译器是如何工作的。计算理论读起来就像编译书籍第一章的第一部分。你需要全部。

除非你上过编程语言课程，否则你很难记住编译器的各个阶段(甚至输入和输出)。在编写实现编程语言的程序之前，你必须知道编程语言的能力是什么，或者至少有一点概念。而且除非你精通不止一种语言，否则用 A 语言写一个把 B 语言转换成 c 语言的程序是没有太大意义的。

你实际上被编译问题包围了。你几乎每天都会碰到他们。我上面概述的七种情况只是冰山一角。(第八个是冰山的其余部分，但没有撇头！)

编译器接受一个符号流，根据一些特定领域的预定义规则找出它们的结构，并将它们转换成另一个符号流。

听起来很笼统，不是吗？是啊。

图像可以被认为是符号流吗？当然可以。流式传输每行像素。每个像素都是一个数字。数字是一种符号。你可以用编译器转换图像。

英语可以被认为是一种符号流吗？当然可以。这些规则非常复杂，但是没错，自然语言处理(至少确定性的那种不起作用，已经被随机方法取代)可以被认为是一种奇特的编译。

普通代码呢？我的意思是，我们并不都处理图像处理，或自然语言处理。我们其余的人呢？我们只是写代码，所以编译器真的重要吗？

那么，你曾经需要编写代码来处理你自己的代码库吗？如果你需要写一个语法荧光笔怎么办？如果你的编程语言增加了一些新特性，而你的编辑器还不支持这些特性怎么办？你只是坐在那里等着“某人”来修理你的编辑器吗？如果需要几年呢？作为一名非常优秀的程序员，你应该能够更快地修复它，这难道不是吗？

你曾经需要处理你的代码库来寻找某些习惯用法吗？你曾经需要写你自己的文件提取器吗？

你是否曾经处理过莫名其妙变得巨大的代码库，尽管你尽了最大努力使它们模块化和面向对象？你当然有。有什么解决办法？

你要么学习编译器并开始编写你自己的 DSL，要么为自己找一门更好的语言。

顺便说一下，我推荐 NBL。这是我个人最喜欢的:邪恶张量场的局部最大值，地狱附近的最高点。不过，我还不打算告诉你 NBL 是什么。耐心点！我的 Emacs 模式只完成了一半。

**If you don't take compilers...**

许多程序员不选择编译器的一个原因是他们听说编译器非常非常难。它通常是 CS 项目的“顶点”课程(OS 通常是另一个)，这意味着它是一种“可选的通过仪式”，使你成为一名真正的程序员，并让你胸有成竹，无论性别或胸毛偏好如何。

如果你试图制定一个时间表，让你在钱用完之前毕业，希望你的平均绩点不会让未来的雇主召唤看门狗来盯着你，那么当你听到“可选的通过仪式”这个短语时，如果你寻找替代方案，谁会责怪你呢？

顺便说一句，我并不是说其他计算机科学课程不重要。可以说，操作系统、机器学习、分布式计算和算法设计都与编译器的构建一样重要。除了你可以参加所有课程，但仍然不知道计算机是如何工作的，对我来说，这意味着编译器真的需要成为一门必修的 300 级课程。但是它有如此多的先决条件，以至于在大多数学校你不可能现实地做到这一点。

设计一个有效的本科计算机科学学位是困难的。难怪那么多常青藤名校都或多或少的放弃了，转而去做 Java 认证店。

如果你是一个有良心的 CS 学生，你至少会选 OS 和 AI。你可能不知道编译器是如何工作的，这很不幸，但是会有很多问题领域，在这些领域中，你至少可以提供和其他人一样多的价值。这是一件值得高兴的事情，或者至少和其他人一样高兴。

加油团队。

可悲的是，如今大多数程序员只想要学位。他们不在乎学什么。他们想要一个学位，这样他们就可以找到一份工作，这样他们就可以支付账单。

大多数程序员被一系列课程所吸引，这些课程可以被最好地描述为计算机科学的橄榄园:愚蠢的程序员去那里学习聪明的程序员的东西。

我不愿明确地说出这些课程的名称。我不够敏捷，无法避开动画、项目管理、面向对象的工程师针对我的图形流血游戏，他们使用 Java 和 Web 2.0 技术，通过团队合作和现代软件方法合理设计的用户界面来折磨我。我成了软件伦理及其对我们文化影响的一个案例研究。

但是你大概可以想象其中一些课程是什么。

如果你不使用编译器，那么你将面临

*forever*

在程序员 B-list 上:那种热切的年轻架构师变成了一个沉默寡言的老架构师，他以构建大型系统为职业，并以此为荣。

**Large Systems Suck**

这条规则是 100%可传递的。如果你造了一个，

*you*

烂透了。

**Compiler Camps**

事实证明，许多编译器“专家”并不完全了解编译器，因为编译器在逻辑上可以被认为是三个独立的阶段——事实上，它们是如此的独立，以至于它们构成了完全不同且大部分不重叠的研究领域。

编译管道的第一个重要阶段是解析。你需要把你的输入转化成一棵树。因此，您需要经历预处理、词法分析(又名标记化)，然后是语法分析和 IR 生成。词法分析通常用正则表达式来完成。句法分析通常用语法来完成。您可以使用递归下降(最常见的)，或者解析器生成器(常见于较小的语言)，或者使用执行速度相对较慢的高级算法。但是这个流水线阶段的输出通常是某种解析树。

作为一名职业程序员，只要知道这么多，你就能走得更远。即使你有

*no idea*

编译的其余部分是如何工作的，您可以实际使用生成解析树的工具或算法。事实上，解析本身就可以帮助您解决上面的情况#1 到#4。

如果你不知道解析是如何工作的，你会在正则表达式上做得很差，或者如果你不知道那些，那么在手工滚动的状态机上是成千上万行不可理解的代码，实际上并不工作。

真的。

事实上，作为一个标准的面试问题，我曾经问过候选人，他们如何在 HTML 文件树中找到电话号码，他们中的许多人(多达 30%)选择写 2500 行 C++程序作为他们的答案。

在某个时候，候选人开始告诉我，他们在我的博客上看到了那篇文章，总的来说，这很奇怪。现在我不再问了。

我偶尔问它的变体，它仍然得到他们:你要么认识到这是一个简单的问题，要么你拿出瑞士军刀，开始寻找第二个在痛苦导致你羞辱你的家人之前砍头的人。

令人惊讶的是，C++经常这样做。

下一个重要阶段是类型检查。这是一群热情的学者(以及他们的追随者和/或研究生),他们相信他们可以编写足够聪明的程序来找出

*your*

当你错的时候，程序会告诉你。奇怪的是，他们不认为自己是人工智能的人，因为人工智能已经(明智地)超越了确定性方法。

这个阵营已经或多或少地计算出了他们可以确定性地检查的实际限制，他们已经宣布这是计算本身的边界，超出这个边界，你就跨越了文明的边界，进入了杀戮或被杀戮的领域，有时也被称为人们用软件赚钱的可怕地方。

你应该听听他们在狂欢派对上喝醉时的声音。

我的一个拥有语言博士学位的好朋友最近告诉我，经历这种认识是“非常痛苦的”,那就是，这些年来对美丽的数学纯粹性的孜孜以求对现实世界几乎没有任何影响。

这个问题——嗯，一个问题——是潜在的前提，很明显，如果没有 Hindley-Milner 类型的系统，或者失败的话，像 Java 这样的一些垃圾类型的系统，你将永远无法编写工作代码；它会在自身的重量下坍塌:对于粗心的冒险者来说，这是一个巨大的、没有类型的陷阱。

显然，他们不怎么出门。

另一个问题是，他们认为任何类型的“错误”，无论在这个特定时刻对你的个人程序的操作来说是多么微不足道，都应该被视为值得登上《华尔街日报》头版的新闻。每个人都应该放下手中的犁头，停止工作，直到修好为止。类型“警告”的概念从未进入讨论。

还记得模糊逻辑出现的时候吗？哦，哦，等等——还记得冯·诺依曼和斯坦·乌兰介绍蒙特卡罗方法的时候吗？哦，对了，我总是忘记:你生于 1990 年左右，你 19 岁，我 90 多岁。

嗯，有一天他们会意识到，严格的决定论总是，总是失败，在它曾经被应用的每个维度-被诅咒的领域，它总是被概率方法取代。

称之为“可选静态类型”，作为辉煌未来的雏形。NBL，有人吗？

第三个阵营，也是最孤立的，是代码生成阵营。代码生成非常简单，假设你知道足够多的递归，意识到你的祖父母不是亚当和夏娃。因此，我真正谈论的是优化，这是一种生成代码的艺术，这种代码只是勉强足够正确，以至于大多数客户不会注意到问题。等等，不好意思，那是亚马逊化。优化是生产的艺术

*correct*

相当于由你的可能天真、昂贵的程序员编写的天真、昂贵的代码。

我会把编译器优化称为永恒黑暗的无尽深渊，除了它非常有趣。所以我想这是一个无尽的乐趣和永恒的黑暗的鸿沟。但你可以将它发挥到你永远猜不到的极致，这是一个肥沃、开放的研究领域，当他们“完成”时，他们将在类型检查营地想要的同一个地方，即人工智能专家。

我指的是机器学习，因为“人工智能”这个词不仅带有决定论的味道，而且明显缺乏风险投资。

在任何情况下，这三个阵营都不怎么来往，而且他们都有资格自称为“编译器专家”。

**The Dark Side of Compilers**

我花了这么长时间写这篇荒谬的博客的原因之一是，在我滔滔不绝地谈论它们之前，我想为自己写一个编译器。

搞定了。

嗯，算是吧。实际上，“未完成”会更准确，因为，正如我所发现的，这是所有编译器的稳定状态。

我没有透露任何细节，因为这还为时过早，我尝试用另一种有用的语言为一种有用的语言编写一个解释器，输出的是一个有用平台的有用字节码。

很有趣。它走得很快。我学到了很多，尽管 15 年前我在学校上过两次编译器课，尽管在过去的 5 年左右时间里我已经逐渐自学了编译器和编程语言。

光是做这件事，我还是学到了很多。

不幸的是，编写编译器创造了一个有生命的东西。我没有意识到这一点。我没想要一个孩子。在 20 多年的行业经验之后，我完全没有想到，即使编写一个简单的解释程序也要花费我一生的时间。

去想想。

我把“毕生的工作”归功于鲍勃·杰维斯，他是我的一个朋友，碰巧是 Turbo C(我自己就是用它学会编程的)的原始作者，也是一个非常好的，甚至是世界级的编译器作者。

他最近做了一个技术演讲(谷歌经常这样做)，他指出，即使只是观众要求的一套功能也是一生的工作。

这句话深深地引起了我的共鸣。这类似于 18 个月前我意识到我只剩下有限的几个 5 年项目，我必须开始非常小心地选择它们。在编写了自己的“生产解释器”之后，我意识到剩下的工作是无限的。

我是认真的。无界。

因此，从一个角度来看，我想我应该发布我已经得到的东西并开始营销，这样其他人就会跳上船并开始帮忙。另一方面，我开始这个特殊的副业并不是为了给自己创造一生的工作(远非如此)，而是为了确保我对编译器有足够的了解，能够在喝了几杯酒之后，向 25 万读者半智能地谈论它们。

所以我至少最好先完成字节编译器。

我会去的。会很整洁的。我只向少数人描述过这个疯狂的小副业，他们的反应几乎都是大喊“WTF？？？?"你知道，如果你发现你所知道的世界上最理智的人试图把一根点燃的炸药塞进他们的嘴里，你会大声喊出来。

这是给你的编译器。你很难在尝试的过程中不试图改变世界。

这就是为什么你需要了解他们是如何工作的。这就是为什么你，是的，你个人，需要写一个。

没你想的那么难，除了会变成一辈子的工作。没关系。如果你想，你可以离开它。你可能不想。你可能是

*forced*

由于时间的限制，你仍然是一个更好的程序员。

您将能够修复那个该死的语法突出显示。

您将能够编写文档提取器。

您将能够在 Eclipse 中修复损坏的缩进。

您将不必等待您的工具赶上来。

你甚至可以停止吹嘘如何

*smart*

你的工具是什么

*amazing*

那就是他们能理解你的代码——如果我可以这么说的话，这不是我会大声宣扬的事情，但也许这只是我的想法。

你将能够用你最喜欢的语言帮助解决所有这些问题。别想告诉我你最喜欢的语言没有问题。

当世界上一些最聪明的人(比如，詹姆斯·高斯林和盖伊·斯蒂尔)试图向 Java 社区引入非破坏闭包和真正的可扩展性时，你将能够充满信心地投票反对疲惫的大多数人。那些可怜的 Java 社区笨蛋。我同情他们所有人。真的。

见鬼，你甚至可能开始吃丰富的程序员食物。编写编译器只是开始；我从未声称这是路的尽头。你将最终能够超越你的小服务 API 和 JavaScript 小部件，开始帮助编写治疗癌症、全球所有病毒、衰老和死亡的程序。或者甚至(我真的有点冒险)把静态类型当成确定性的灵丹妙药。

不说别的，你最终会

*really*

学习你正在为之编写编译器的任何编程语言。没有别的办法了。不好意思！

就这样，我想我该结束了。我早上要去 Foo 夏令营，我不知道会发生什么，但我有一个很好的猜测，不会有太多关于编译器的讨论，除了希望来自 GVR 的关于 Python 3000 的讨论。那可能很酷。

如果你不知道编译器，不要担心。我仍然认为你是一个优秀的程序员。但是有挑战性的目标是好的！

**But What's The Most Important CS Course?**

打字 101。咄。

离开这里。