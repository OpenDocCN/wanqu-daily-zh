# 所有软件都是传统的

> 原文：<https://leejo.github.io/2016/02/22/all_software_is_legacy/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

<center>All Software is Legacy</center>

<center>February 22, 2016 ( [Prev](/2015/10/13/some_more_photos_from_south_africa/) / [Next](/2016/04/21/bahrain/) )
<font>This post is over five years old</font></center>

我自愿成为 Perl CGI 模块(CGI.pm)的主要维护者，这在未来几年可能会被认为是疯狂的时刻。对于这篇文章的非技术读者来说:CGI.pm 是几千行代码，在 90 年代中后期，甚至几年后，帮助了许多网站的运行。曾经访问过一个网站，并在网址中看到“cgi-bin”吗？是的，那是*可能是*运行 Perl 脚本，而且几乎肯定是使用 CGI.pm

实际上，早在 2014 年 4 月，我就自愿成为主要维护者。我花了这么长时间写这篇文章的原因是我一直忙于，呃，维护这个模块。我已经解决了大部分现存的问题<sup id="fnref:1" role="doc-noteref">，撰写并发表了关于模块<sup id="fnref:2" role="doc-noteref">的计划的演讲，发布了一个额外的模块来为人们提供更好的资源<sup id="fnref:3" role="doc-noteref">，偶尔还会回复关于模块<sup id="fnref:4" role="doc-noteref">的问题，哦，当然还有通常的原因，帖子需要几个月才能从我的草稿文件夹中出来。</sup></sup></sup></sup>

尽管这些年来我经常使用这个模块，甚至自愿成为主要维护者，但我并不喜欢它。它在早期是一个重要而有用的模块，但是它在现代[perl] web 栈中没有一席之地，至少在十年内不值得拥有。这并不是对原作者或原实现的批评，这只是因为 web 开发领域已经取得了进步，并且已经吸取了教训。

有一点很重要，那就是 CGI 和 CGI.pm 之间的区别。CGI 是通用网关接口协议，或者说是规范，而 CGI.pm 是该规范的实现。在某些情况下，CGI 仍然是进行 web 编程的合理协议，而 CGI.pm 不是。

CGI.pm 不是第一个实现，但是它在包含在 Perl 核心中之后被广泛采用:

```
/Users/leejo/working/CGI.pm > corelist CGI

Data for 2013-08-12
CGI was first released with perl 5.004 
```

perl 5.004 是什么时候发布的？大约二十年前的 1997 年 5 月 15 日。

**往事**

在此之前，如果您想用 Perl 进行 CGI 编程，您必须手动安装 CGI.pm，编写您自己的实现，或者安装脚本来完成。一个众所周知的例子是 cgi-lib.pl. <sup id="fnref:6" role="doc-noteref">事实上，可以说 cgi-lib.pl 通常被用作 CGI.pm 包含的函数，使得从 cgi-lib.pl 移植脚本变得容易。</sup>

随着时间的推移，CGI.pm 变得越来越大，越来越多，直到它实现了 CGI 协议规范的大部分(如果不是全部的话)，甚至更多:[https://tools.ietf.org/html/rfc3875](https://tools.ietf.org/html/rfc3875)

看一下 RFC，看看有没有什么特别的。我给你一个提示:这和日期有关…明白了吗？是的，RFC 3875 是在 2004 年 10 月完成的，在 CGI.pm 和 Perl 一起发布的七年后，在最初的 NCSA 非正式规范发布的至少十年后。RFC 3875 的工作直到 1997 年才开始，那时已经有许多不同的规范实现，没有正式的定义。

CGI 规范的第一份正式草案直到 1998 年 5 月[日](https://tools.ietf.org/html/draft-coar-cgi-v11-00)才发布。那时已经有几个大型网站在运行 Perl 甚至 CGI.pm 了:易贝，IMDb，cPanel，Slashdot，Craigslist，Ticketmaster，Booking.com，几个支付处理商，以及其他许多网站。

在此之前，CGI 协议是一项正在进行的工作，它的历史看起来像这样:

*   1993 年 6 月 2 日:Dave Raggett 更新了他的 HTML+ DTD，增加了对“输入和选择表单交互元素”的支持[0]

*   1993 年 7 月 19 日:Nathan Torkington 为标准 CERN (2.06)守护进程添加了一个可执行 shell 脚本功能[8]

*   93 年 9 月 5 日:马克·安德森表示 NCSA Mosaic 2.0 将提交表单参数为:“name = value & name = value & name = value”[1]

*   93 年 9 月 13 日:罗布·麦克库尔宣布推出 NCSA httpd 1.0a1[2]，它支持“服务器脚本，这是服务器运行以动态生成文档的可执行程序。它们很容易编写，可以用您喜欢的语言编写，无论是 C、PERL，甚至是 Bourne shell" [3]

*   93 年 11 月 14 日:罗布·麦克库尔抱怨说，他的用户避免编写代码，因为他们认为界面会改变，并抛出了一堆他希望在他所谓的“网关”中解决的开放问题

*   93 年 11 月 17 日:罗布·麦克库尔发布了“CGP/1.0 规范”[7]，两天后更名为 CGI

*   93 年 12 月 13 日:NCSA httpd 1.0 发布，支持“CGI”

随着 RFC 草案的扩展，更多使用 Perl 和 CGI.pm 的站点和软件被发布:TWiki、Bugzilla、Movable Type、LiveJournal 和数以千计的其他软件。甚至[互联网弹球数据库](http://www.ipdb.org/)。

那么发生了什么？

随着时间的推移，越来越多的功能被添加进来，范围也逐渐扩大。几年后，事实证明，一些实施决策并不完全符合现代需求，而另一些决策如果不小心使用，可能会导致严重的漏洞。可以采取一些变通办法:fastcgi 用于持久性，mod_perl 用于速度，并插入 apache，但是它们需要使用 CGI.pm 来修改脚本。

这并不罕见，当时网络还不成熟，围绕它的发展反映了这一点。还有一个考虑是，你不能预测未来，在软件开发中做出准确的估计是非常困难的。有时你只需在代码中写一个 TODO 或 FIXME，然后再担心它——Y2K 有人知道吗？IPv4？

CGI.pm 发展到可以用于早期 web 开发的许多不同功能，并且可以在这些不同的功能中以不同的方式使用。结果是 CGI.pm 不得不包含大量的代码来处理这些不同的用途，它的双重接口，边缘情况和现有的错误。简单的函数应该是几行长的积函数。

**Cruft**

```
1	'_maybe_escapeHTML' => <<'END_OF_FUNC',
2	sub _maybe_escapeHTML {
3		# hack to work around  earlier hacks
4		push @_,$_[0] if @_==1 && $_[0] eq 'CGI';
5		my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@_);
6		return undef unless defined($toencode);
7		return $toencode if ref($self) && !$self->{'escape'};
8		return $self->escapeHTML($toencode, $newlinestoo);
9 	}
10	END_OF_FUNC 
```

上面的代码块是 CGI.pm 中的一个较小的函数，演示了这些年来代码积累了多少历史。它是做什么的？它对文本输入进行净化，以防止 html 标签(之类的)被注入到输出中。例如，它会将&lt;。

这用于防止跨站点脚本攻击。事情是这样的，除去所有的样板文件和干净的界面，这样做只需要三行代码:

```
1	sub _maybe_escapeHTML {
2		return shift->{escape} ? escapeHTML( @_ ) : @_;
3	} 
```

那么其他代码在做什么呢？我们来分解一下。

```
1	'_maybe_escapeHTML' => <<'END_OF_FUNC',
...
10	END_OF_FUNC 
```

添加第 1 行和第 10 行是为了将该函数的编译推迟到运行时。大约二十年前，当 CGI.pm 刚刚流行起来的时候，硬件并不适合为每个请求编译几千行代码。为了加速模块的加载，大量的函数被包装成字符串，只有在被调用时才被编译，这就是所谓的“延迟加载”。

```
3		# hack to work around  earlier hacks
4		push @_,$_[0] if @_==1 && $_[0] eq 'CGI';
5		my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@_); 
```

第 3 行到第 5 行回避了 CGI.pm 有一个双重接口的事实——它的方法可以被过程化地调用，也可以作为对类实例(“对象”)的方法调用。要提供这种双重接口，需要 CGI.pm 中的每一个方法检查它是如何被调用的，然后在程序上调用它时创建一个默认对象。

```
6		return undef unless defined($toencode);
7		return $toencode if ref($self) && !$self->{'escape'}; 
```

第 6 行和第 7 行是健全性检查和短路。第 6 行写着“如果我们没有得到任何输入，那么就不要继续”，第 7 行写着“如果我们之前决定不想净化输入，那么就不要继续”。这些是否属于这个函数是有争议的；在 6 的情况下，我会说“是的，但是在没有输入的情况下调用方法可能是调用代码中的一个 bug”，而在 7 的情况下，我会说“是的，但是只有在这清理了其他地方的代码的情况下”(结果是这个函数在内部被调用了 39 次，所以在这里进行检查*比*更干净)。

这是 8000 线模块中的一个小功能。CGI.pm 目前有超过 150 个函数，不包括私有函数和自动生成的函数，每个函数都有相同或相似的代码来处理调用它的旧代码，并处理模块早期的实现决策。

**静止不动，向前移动**

当我告诉非 perl 开发人员，或者有时是前 perl 开发人员，我主要用 Perl 编写代码时，他们经常对仍然使用 Perl 表示震惊。他们不知道现代的生态系统，不知道 Perl 仍然在许多地方被积极地用于新的开发<sup id="fnref:11" role="doc-noteref">，不知道每年有成千上万的开发人员参加的几十个 Perl 会议，也不知道 Perl 每年都有主要的发布版本。最奇怪的是，他们似乎认为，当他们切换到他们选择的新语言时，数亿行 Perl 代码就消失了。</sup>

许多软件系统就像蜕皮的蛇一样，不断地进行维护，每隔几年就要彻底更换它们的组件。然而，在此过程中，它们的核心功能保持不变，对于许多用户来说，它们可能会持续多年而没有任何变化。有时，这条蛇会被一条更新、更亮的蛇所取代，但用户并不是被迫使用它，或者甚至不知道这是不是正确的蛇。

一些最成功的网站已经经历了多年的多次重写。更多的网站和应用程序还没有。因为没有 CGI.pm 必须保持向后兼容性。因此，虽然我已经去除了它的大部分死皮，但我几乎无法改善它的剩余状态。很多软件都是这样，生态系统的一部分必须静止不动，而其他部分则向前移动。

再说，反正 CGI.pm 再发展下去也没什么价值。在 Perl 生态系统中有更好的选择，不仅可以处理 CGI.pm 可以做的所有事情，还可以扩展功能以处理现代代码和需求。这些是生态系统中向前发展的部分。CGI.pm 是非常传统的软件。

**《遗产》**

如果你看到或听到“传统”这个词被用来指软件、代码、应用程序或设备，你可以肯定这个用法是贬义的。然而现实是所有的软件都是遗留的，我们经常用“遗留代码”来代替“技术债务”。虽然它们不是完全一样的东西，但其中一个的出现几乎肯定会让人联想到另一个。

无论如何，“技术债务”是一个更有用的术语，因为它暗示了通向遗留软件的道路。如果我们不还清债务，我们不得不宣布破产，我们不得不放弃代码。这在软件中很少发生，完全废弃，甚至几十年的旧代码也需要支持和维护。

但是技术债务是一个有用的概念，因为上市速度通常比未来的验证代码更重要。无论如何，未来证明代码是一个矛盾的说法，即当基础发生变化和期望改变时，代码可以永远工作。因此，当我们写代码时，我们担心短期，长期可以照顾自己。

你认为如果谷歌、脸书等公司预测到一年、五年、十年后的业务规模，并花额外的时间设计系统来处理这些问题，他们会发展到现在的规模和统治地位吗？“我们不能使用 php、mysql 等，因为它无法扩展到 10 亿用户？”不，他们会让它扩展，如果不能，他们会用其他可以扩展的东西来代替。

**未来遗产**

人们很容易忘记，在互联网出现之前，仍有一些遗留软件在使用。见鬼，网络已经变得如此占主导地位，以至于有时很容易忘记软件在它之前就已经存在了。下次你坐飞机的时候，看看你能不能偷看一下签到软件，可能是 60 年代写的，在模拟器上运行的东西。或者你的银行<sup id="fnref:17" role="doc-noteref">怎么样，或者你的医生办公室怎么样？<sup id="fnref:18" role="doc-noteref">这些系统就像水泥一样。</sup></sup>

你阅读这篇文章的浏览器已经有 20 年的历史了。传送数据的高级协议比那个协议早了五年。低级协议根据您假设的基础规范，再次击败 10 或 20 个。这是自下而上的遗产，当我们在此基础上建设时，我们创造了自上而下的遗产。所有这些都限制了我们的生产能力，有时我们会在基础上发现危险的裂缝。

构建这一遗产的正确方法是正确地抽象出内部结构，并提供干净和合理的接口。接口越干净，耦合越松散，就越容易将上游代码从接口中拔出并插入到其他东西中。但矛盾的是，你的界面越干净、越理性，它就越有可能成功，也就越有可能被用户所约束、固化。

从操作系统附带的琐碎的小工具(coreutils)到我们依赖的加密机制(openssh)和同步时钟的软件(ntp <sup id="fnref:21" role="doc-noteref">),传统遍布我们使用的软件。苹果仍然用一个疯狂的文件系统来装载他们的操作系统，因为有太多的遗留软件将会崩溃，如果他们修复它的话。</sup>

你写的每一行新代码都不可避免地会成为遗留软件。你选择的语言或习语将会失宠；该框架将被取代；它所使用的库将需要更新，由于错误和漏洞或一些依赖将被放弃。看看 github 吧，它是最受欢迎的开源软件项目托管网站，正迅速成为世界上最大的软件墓地。甚至你站立的肩膀也下垂了。

为了避免你认为你对此免疫，问问你自己你是否曾经为不止一家公司写过代码？曾经为一个库提供过补丁或 bug 修复吗？在 stackoverflow 上回复了一个问题？你，我，每一个软件开发者，现在都在创造遗留软件。

**遗产**

如果以上给人的感觉是软件的末日即将来临，那么让我向你保证这不是——事情就是这样。软件开发有一个思维过程，类似于“如果你不能回头看看你的旧代码，看看它有多糟糕，那么你就没有进步”。用“软件开发”来代替你的职业。每个人都编写糟糕的代码，做出糟糕的实现决策，糟糕的估计，等等。每个人都是从新手开始的。

正如所有的软件都有缺陷一样，所有的软件都是遗产。软件开发是关于解决现在存在的特定问题，而不是解决不特定的或未来的问题。每隔几年，也许十年，就会有一次范式转变。假以时日，部分技术基础将会发生足够的变化，让以前的模式变得过时。

这也许是为什么新开发人员倾向于抵制旧代码<sup id="fnref:26" role="doc-noteref">，有时从实现中得出假设，并用它来嘲笑唱诗班。闪亮的新东西可能很吸引人，但是你越新，你的软件就越快成为遗产，因为你还不知道你不知道什么。旧代码仍然存在，因为替换它的成本收益还不够有说服力，而且它只是工作。你编写的新代码会比你预期的更快地发现自己处于同样的情况。</sup>

重要的是，我们从中吸取教训，并确保未来的遗产易于理解。编写干净的接口、良好的测试、描述性的提交消息。<sup id="fnref:28" role="doc-noteref">另一个重要的是了解血统；在 CGI.pm 的例子中，这个模块是 Perl 早期大受欢迎的部分原因，甚至推动了 Perl 的发展。当 CGI.pm 实现的局限性受到冲击时，替代代码被一次又一次地写出来作为回应，导致了我们今天的处境。</sup>

我们今天所在的地方非常有趣，非常好玩，明天会更有趣，甚至更好玩。因此，这将是我最后一次写、谈论、展示或漫谈 CGI.pm，尽管这个模块可能还会存在一段时间。我宁愿专注于当前和未来的遗留代码，而不是过去。

* * *