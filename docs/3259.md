# master hackergrrl/art-of-readme GitHub 上的 art-of-readme/README.md

> 原文:[https://github . com/no ffle/art-of-readme/blob/master/readme . MD？UTM _ source = Wanqu . co&UTM _ campaign = Wanqu+Daily&UTM _ medium = website](https://github.com/noffle/art-of-readme/blob/master/README.md?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website)



# [](#art-of-readme)艺术自述

*这篇文章也可以用[中文](/hackergrrl/art-of-readme/blob/master/README-zh.md)，[日文](/hackergrrl/art-of-readme/blob/master/README-ja-JP.md)，[巴西葡萄牙文](/hackergrrl/art-of-readme/blob/master/README-pt-BR.md)，[西班牙文](/hackergrrl/art-of-readme/blob/master/README-es-ES.md)，[德文](/hackergrrl/art-of-readme/blob/master/README-de-DE.md)，[法文](/hackergrrl/art-of-readme/blob/master/README-fr.md)和[繁体中文](/hackergrrl/art-of-readme/blob/master/README-zh-TW.md)来读。*

## [](#etymology)语源

“自述”一词从何而来？

这个术语至少可以追溯到 20 世纪 70 年代的[和 PDP-10](http://pdp-10.trailing-edge.com/decuslib10-04/01/43,50322/read.me.html) ，尽管它甚至可以追溯到在一叠穿孔卡片上放置信息纸笔记的时代，“读我！”潦草地写在上面，描述它们的用途。

一位读者 <sup>[1](#footnote-1)</sup> 认为《自述》的标题可能是对刘易斯·卡罗尔的*爱丽丝漫游奇境记*的一个俏皮的推动，该书分别以一种药水和一块蛋糕为特色，分别标有*“喝我”*和*“吃我”*。

README 以全大写字母出现的模式在历史上是一致的。除了使用全大写字母的视觉效果之外，UNIX 系统会将大写字母排在小写字母之前，方便地将自述文件放在目录的其余内容 <sup>[2](#footnote-2)</sup> 之前。

意图很清楚:*“这是用户在继续之前需要阅读的重要信息。”*让我们一起探索在当今时代，什么构成了“重要信息”。

## [](#for-creators-for-consumers)对于创作者，对于消费者

这是一篇关于 READMEs 的文章。关于它们的作用，为什么它们是绝对必要的，以及如何制作它们。

这是写给模块创建者的，因为作为一个模块的构建者，你的工作是创建一些持久的东西。这是一种内在的动机，即使作者无意分享他们的作品。一旦 6 个月过去了，一个没有文档的模块开始变得陌生。

这也是写给模块消费者的，因为每个模块作者也是模块消费者。节点有一个非常健康的相互依赖度:没有人生活在依赖树的底部。

尽管关注的是 Node，但作者认为它的经验同样适用于其他编程生态系统。

## [](#many-modules-some-good-some-bad)许多模块有些好，有些不好

节点生态系统由其模块驱动。 [npm](https://npmjs.org) 是让一切*走向*的魔法。在一周的时间里，节点开发人员评估了几十个模块，以纳入他们的项目。这是一个每天都在产生的巨大的力量，已经成熟，就像一个人能写的那么快。

像任何极易接近的生态系统一样，质量标准也各不相同。npm 尽最大努力包装好所有这些模块，并将它们运送到更远的地方。然而，所发现的工具却千差万别:有些是崭新闪亮的，有些是破损生锈的，还有一些介于两者之间。甚至有一些我们不知道他们是做什么的！

对于模块，这可以采用不准确或没有帮助的名称的形式(猜猜`fudge`模块是做什么的？)，没有文档，没有测试，没有源代码注释，或者不可理解的函数名。

许多没有一个活跃的维护者。如果一个模块没有人来回答问题和解释模块是做什么的，再加上没有遗留的文档，那么这个模块就变成了一个奇怪的外星人工制品，对未来的考古学家-黑客来说是不可用和不可理解的。

对于那些有文档的模块，它们在质量谱中处于什么位置？也许只是一句话的描述:`"sorts numbers by their hex value"`。也许是一段示例代码。这两种改进都是徒劳的，但它们往往会导致现代模块洞穴探险者最糟糕的情况:挖掘源代码，试图了解它实际上是如何工作的。编写优秀的文档就是通过提供足够的指令让用户享受你的模块带来的美妙的抽象，从而让用户远离源代码。

Node 有一个“广泛的”生态系统:它很大程度上是由一长串独立的做好一件事的模块组成的，这些模块除了自己的旗帜之外没有其他旗帜。虽然也有例外，但是尽管有这些小领地，真正统治节点王国的是那些人数众多、目标单一的平民。

这种情况有一个自然的结果:很难找到完全符合你要求的高质量模块。

**这还行**。真的。进入门槛低和可发现性问题远比文化问题好，在文化问题上，只有少数特权阶层可以参与。

另外，可发现性——事实证明——更容易解决。

## [](#all-roads-lead-to-readmemd)殊途同归 README.md

节点社区以不同的方式应对可发现性的挑战。

一些有经验的节点开发人员联合起来创建质量模块的精选列表。开发人员利用他们多年来检查数百个不同模块的经验，与新来者分享*的精华:每个类别中最好的模块。这也可能采取 RSS 提要和被信任的社区成员认为有用的新模块的邮件列表的形式。*

社交图谱怎么样？这个想法激发了[node-modules.com](http://node-modules.com/)的产生，这是一个 npm 搜索的替代品，它利用你的 GitHub 社交图来找到你的朋友喜欢的或者已经制作的模块。

当然还有 npm 内置的[搜索](https://npmjs.org)功能:一个安全的默认设置，也是新开发者的常用入口。

不管你的方法是什么，不管一个模块探险者是在 npmjs.org 的、[github.com 的](https://github.com)还是其他什么地方进入地下模块，这个潜在的用户最终都会直面你的自述。既然你的用户不可避免地会发现自己在这里，怎样做才能让他们的第一印象最大限度地有效？

## [](#professional-module-spelunking)专业模块洞穴探险

### [](#the-readme-your-one-stop-shop)自述:你的一站式商店

自述文件是一个模块，它是消费者第一次，也可能是唯一一次，审视你的创作。消费者想要一个模块来满足他们的需求，所以你必须准确地解释你的模块满足什么需求，以及它如何有效地满足需求。

你的工作是

1.  告诉他们这是什么(结合上下文)
2.  向他们展示它的实际效果
3.  向他们展示如何使用它
4.  告诉他们任何其他相关的细节

这是你的工作。这取决于模块创建者来证明他们的工作是松散模块海洋中的一颗闪亮的宝石。既然如此多的开发人员会先看你的自述文件，那么质量就是你面向公众的工作衡量标准。

### [](#brevity)简洁

缺少自述文件是一个强有力的危险信号，但是即使一个冗长的自述文件也不能说明质量很高。理想的自述文件应该尽可能的短，不能再短了。详细的文档是好的——为它制作单独的页面！-但是你的自述要简洁。

### [](#learn-from-the-past)吸取过去的教训

据说那些不研究自己历史的人注定会重蹈覆辙。开发人员已经编写文档很多年了。如果不稍微回顾一下，看看人们在 Node 之前做了什么，那将是一种浪费。

尽管 Perl 受到了很多批评，但它在某种程度上是 Node 的精神祖父母。两者都是高级脚本语言，采用了许多 UNIX 习惯用法，推动了互联网的发展，并且两者都具有广泛的模块生态系统。

事实证明，Perl 社区的[僧侣](http://perlmonks.org)确实在编写[高质量的读物](http://search.cpan.org/~kane/Archive-Tar/lib/Archive/Tar.pm)方面有着丰富的经验。CPAN 是一个很棒的资源，值得通读，以了解更多关于一个始终如一地编写高质量文档的社区的信息。

### [](#no-readme-no-abstraction)没有自述？没有抽象

没有自述文件意味着开发人员需要钻研你的代码才能理解它。

Perl 僧侣在这个问题上有智慧可以分享:

> 当有人可以不用看代码就能使用你的模块时，你的文档就完整了。这一点非常重要。这使得您可以将模块的文档化接口与其内部实现(guts)分离开来。这很好，因为这意味着只要接口保持不变，您就可以自由地改变模块的内部结构。
> 
> 记住:文档，而不是代码，定义了一个模块做什么。——[肯·威廉斯](http://mathforum.org/ken/perl_modules.html#document)

### [](#key-elements)关键元素

一旦找到一个 README，brave module spelunker 必须扫描它以辨别它是否符合开发人员的需求。这实质上变成了一系列模式匹配问题，需要他们的大脑来解决，每一步都让他们更深入地了解模块及其细节。

比方说，我对 2D 碰撞检测模块的搜索将我引向 [`collide-2d-aabb-aabb`](https://github.com/hackergrrl/collide-2d-aabb-aabb) 。我开始从上到下检查它:

1.  *名字*——不言自明的名字最好。听起来很有希望，不过前提是我知道什么是“aabb”。如果这个名字听起来太模糊或不相关，这可能是继续前进的信号。

2.  *一行代码*——用一行代码描述模块有助于更详细地了解模块的功能。`collide-2d-aabb-aabb`说出来

    > 确定移动的轴对齐边界框(AABB)是否与其他 AABB 冲突。

    太棒了:它定义了什么是 AABB，以及这个模块做什么。现在来衡量它是否适合我的代码:

3.  *用法*——与其开始钻研 API 文档，不如看看模块在运行时是什么样子。我可以很快地确定示例 JS 是否符合期望的风格和问题。人们对承诺/回访和 ES6 等事情有很多看法。如果它确实符合要求，那么我可以继续进行更详细的讨论。

4.  这个模块的名字、描述和用法听起来都很吸引我。我很有可能在这一点上使用这个模块。我只需要扫描 API，以确保它完全符合我的需求，并且能够轻松集成到我的代码库中。API 部分应该详细描述模块的对象和函数、它们的签名、返回类型、回调和事件。类型应该包含在不明显的地方。警告应该说清楚。

5.  *安装*——如果我已经读到这里，那么我会尝试这个模块。如果有非标准的安装说明，这里是它们应该去的地方，但即使它只是一个常规的`npm install`，我也希望看到提到这一点。新用户开始一直使用 Node，因此拥有一个到 npmjs.org 的链接和一个 install 命令为他们提供了了解 Node 模块如何工作的资源。

6.  大多数模块把它放在最底部，但是实际上放在更高的地方可能会更好；如果一个模块的许可证与您的工作不兼容，您可能会很快将其排除。我通常坚持麻省理工学院/BSD/X11/ISC 风味。如果你有一个非许可的许可证，把它贴在模块的最顶端以防止混淆。

## [](#cognitive-funneling)认知漏点

上面的顺序不是随机选择的。

模块消费者使用很多模块，需要看很多模块。

一旦你看了数百个模块，你开始注意到思维从可预测的模式中受益。

你也开始为你想要的信息建立你自己的启发式规则，以及哪些危险信号会很快使模块失去资格。

因此，在自述文件中最好有:

1.  可预测的格式
2.  存在某些关键元素

你不需要使用*这种*格式，但是要尽量保持一致，以节省你的用户宝贵的认知周期。

这里介绍的排序被亲切地称为“认知漏斗”，可以想象为一个直立的漏斗，其中最宽的一端包含最广泛的更相关的细节，深入到漏斗中会呈现更具体的细节，这些细节只与对您的工作足够感兴趣以至于已经深入到文档中的读者相关。最后，底部可以留给那些对作品更深层次的背景感兴趣的人(背景、致谢、书目等)来了解细节。).

再一次，Perl 僧侣们在这个问题上有智慧可以分享:

> Perl 模块文档的详细程度通常是从不太详细到更详细。你的概要部分应该包含一个最小的使用示例(可能只有一行代码；跳过不常见的用例或大多数用户不需要的东西)；描述应该用宽泛的术语描述你的模块，一般只有几段；模块的例程或方法的更多细节、冗长的代码示例或其他深入的材料将在后续章节中给出。
> 
> 理想情况下，稍微熟悉你的模块的人应该能够在不点击“向下翻页”的情况下刷新他们的记忆。随着你的读者继续阅读这份文件，他们将获得越来越多的知识。-从`perlmodstyle`

## [](#care-about-peoples-time)关心人的时间

牛逼；这些关键元素的排序应该由他们让某人“短路”并放弃你的模块的速度来决定。

这听起来很凄凉，不是吗？但是想一想:你的工作，当你带着最佳的利他主义去做的时候，并不是向人们“推销”你的工作。这是为了让他们尽可能客观地评估你的创作，并决定它是否满足他们的需求——而不是，比如说，最大化你的下载量或用户群。

这种心态并不适合每个人；这需要在门口检查你的自我，尽可能让工作自己说话。您唯一的工作就是尽可能简洁地描述它的前景，这样模块探索者就可以在合适的时候使用您的工作，或者继续使用其他合适的工作。

## [](#call-to-arms)号令！

勇往直前，勇敢的模块洞穴探险者，通过优秀的文档使您的工作可以被发现和使用！

## [](#bonus-other-good-practices)奖金:其他好做法

除了本文的要点之外，您还可以遵循(或不遵循)其他实践来进一步提高自述文件的质量，并最大限度地提高其对他人的有用性:

1.  如果你的模块依赖于重要但不广为人知的抽象概念或其他生态系统，考虑包含一个背景部分。从名字看， [`bisecting-between`](https://github.com/hackergrrl/bisecting-between) 的功能并不明显，因此它有一个详细的*背景*部分来定义和链接人们需要理解才能使用和理解的大概念和抽象。如果 npm 上已经存在类似的模块，这也是解释模块动机的好地方。

2.  积极链接！如果你谈论其他模块、想法或人，将参考文本作为链接，这样访问者可以更容易地找到你的模块和它所基于的想法。很少有模块存在于真空中:所有的工作都来自于其他的工作，所以帮助用户了解你的模块的历史和灵感是值得的。

3.  如果参数和返回参数的类型不明显的话，就包括它们的信息。尽可能使用约定(`cb`可能表示回调函数，`num`可能表示 T2 等等)。).

4.  将**用法**中的示例代码作为文件包含在您的 repo 中——可能是作为`example.js`。如果用户克隆了存储库，拥有可以实际运行的自述代码是一件好事。

5.  谨慎使用徽章。他们很容易被滥用。他们也可能成为自行车脱落和无休止的争论的滋生地。它们在你的自述文件中增加了视觉噪音，通常只有当用户在浏览器中在线阅读你的降价信息时才会起作用，因为这些图片通常存放在互联网上的其他地方。对于每个徽章，思考一下:“这个徽章给本自述文件的典型读者提供了什么真正的价值？”您是否有 CI 徽章来显示构建/测试状态？通过给维护者发电子邮件或自动创建一个问题，这个信号可以更好地到达重要的地方。始终考虑自述文件中数据的受众，并问问自己是否有更好地到达目标受众的数据流。

6.  API 格式是高度可定制的。使用你认为最清晰的格式，但是要确保你的格式表达了重要的微妙之处:

    a.哪些参数是可选的，以及它们的默认值

    b.类型信息，从惯例上看不明显

    c.对于`opts`对象参数，所有被接受的键和值

    d.如果在**用法**部分不明显或没有完全涵盖，不要回避提供一个 API 函数用法的小例子。然而，这也可能是一个强烈的信号，表明该函数太复杂，需要重构，分解成更小的函数，或者完全删除

    e.积极链接专业术语！在 markdown 中，你可以将[脚注](https://daringfireball.net/projects/markdown/syntax#link)放在文档的底部，因此从头到尾多次引用它们会变得很便宜。我对 API 格式的一些个人偏好可以在[这里](https://github.com/hackergrrl/common-readme/blob/master/api_formatting.md)找到

7.  如果你的模块是一个无状态函数的小集合，拥有一个 **Usage** 部分作为函数调用和结果的[节点 REPL 会话](https://github.com/hackergrrl/bisecting-between#example)，可能比运行一个源代码文件更清楚地传达用法。

8.  如果您的模块提供了 CLI(命令行界面)而不是(或除此之外)编程 API，请将使用示例显示为命令调用及其输出。如果你创建或修改一个文件，`cat`它来演示前后的变化。

9.  别忘了使用`package.json` [关键词](https://docs.npmjs.com/files/package.json#keywords)将模块洞穴探险者引到你家门口。

10.  你改变你的 API 越多，你就需要做更多的工作来更新文档——这里的意思是你应该保持你的 API 小并且在早期就具体定义。需求会随着时间的推移而变化，但是不要将假设预先加载到模块的 API 中，而是将它们加载到一个抽象层次上:模块集本身。如果需求*做*改变，并且“做一件具体的事情”不再有意义，那么简单地写一个新的模块来做你需要的事情。“做一件具体的事情”模块仍然是 npm 生态系统的一个有效和有价值的模型，你的过程修正除了简单地用一个模块替换另一个模块之外，什么也不用花。

11.  最后，请记住，你的版本控制存储库及其嵌入的自述文件将比你的[存储库主机](https://github.com)以及你超链接到的任何东西——尤其是图像——都要长寿，所以*内联*任何对未来用户搜索你的作品至关重要的东西。

## [](#bonus-common-readme)奖金:*普通自述*

并非巧合的是，这也是 [**常用的格式——readme**](https://github.com/hackergrrl/common-readme)，一套 README 指南和方便的命令行生成器。如果你喜欢这里写的东西，你可以节省一些用`common-readme`写的时间。您也可以找到这种格式的真实模块示例。

您可能还会喜欢[标准自述文件](https://github.com/richardlitt/standard-readme)，它是一种更结构化的、可移植的、采用通用自述文件格式的文件。

## [](#bonus-exemplars)奖金:范例

理论很好，但是优秀的读物是什么样的呢？下面是一些我认为很好地体现了本文原则的例子:

## [](#bonus-the-readme-checklist)奖金:自述清单

一份有助于评估您的自述进展情况的清单:

## [](#the-author)作者

嗨，我是[基拉](http://kira.solar)。

这个小项目始于 5 月份在柏林的 squatconf，在那里我深入研究了 Perl monks 是如何编写他们的文档的，同时也感叹了 Node 生态系统中 READMEs 的状态。这促使我创建了[普通自述](https://github.com/hackergrrl/common-readme)。“README 技巧”部分充斥着各种技巧，我决定将它们收集到一篇关于写 README 的文章中。于是，自述艺术诞生了！

## [](#further-reading)延伸阅读

## 脚注

1.  谢谢， [Sixes666](https://www.reddit.com/r/node/comments/55eto9/nodejs_the_art_of_readme/d8akpz6) ！

2.  见[行话文件](http://catb.org/~esr/jargon/html/R/README-file.html)。然而，今天的大多数系统不会在所有小写字符之前对大写字母进行排序，这使得这种约定的有用性降低到全大写字母的视觉效果。

## [](#credits)信用点

衷心感谢 [@mafintosh](https://github.com/mafintosh) 和 [@feross](https://github.com/feross) 给我鼓励，让我有了这个想法并开始写作！

感谢以下了不起的读者注意到错误并给我发来声明 <g-emoji class="g-emoji" alias="heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png">❤️</g-emoji> :

感谢[@齐海燕](https://github.com/qihaiyan)将《自述的艺术》翻译成中文！下列用户也作出了贡献:

感谢 [@lennonjesus](https://github.com/lennonjesus) 将《自述》的艺术翻译成巴西葡萄牙语！下列用户也作出了贡献:

感谢[@ jabilinfante](https://github.com/jabiinfante)将《自述》的艺术翻译成西班牙语！

感谢 [@Ryuno-Ki](https://github.com/Ryuno-Ki) 将《自述的艺术》翻译成德语！下列用户也作出了贡献:

感谢[@曼弗雷德·玛德琳](https://github.com/Manfred-Madelaine-pro)和[@鲁本·玛德琳](https://github.com/Ruben-Madelaine)将《自述》的艺术翻译成法语！

## [](#other-resources)其他资源

一些读者为撰写自述文件提供了其他有用的资源:

## [](#license)执照

[知识共享署名许可](http://creativecommons.org/licenses/by/2.0/)

