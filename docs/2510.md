# 我们做错了，但并非一切都是徒劳的

> 原文：<http://codurance.com/2016/04/12/we-did-it-wrong-but-not-in-vain/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

 是的，有过多的工程设计。很多。早在 90 年代中期，当我开始我的开发生涯时，我的目标是成为一名架构师。没有一个认真的开发人员敢在选择我们喜欢的设计模式之前写一行代码——然后我们决定业务需求如何适应它们。是的，我们会首先提出我们的架构，然后是我们的宏观设计(层)和领域模型(包括 UML 图)，然后我们会考虑业务需求和详细的用例。是的，用户故事在当时并不算什么。我们有一个基本流程和许多可选流程的长期用例。

对开发者来说，90 年代是一个有趣的时期。我们终于有了互联网，一些 70 年代和 80 年代的关于结构化设计的学术论文也可供我们使用。我们也有几本关于面向对象编程的书，这在很多地方还是一个新事物。

我仍然记得我们花了无数个月绘制类、序列、组件、部署和许多其他图表，试图为有一天我们将构建的软件提出最佳设计。我们也构建了一些原型，所以我不能说我们在*精化阶段*没有编码或实验。当然，从原型中获得的所有知识都会反馈到我们的图表中。

除了内部设计，在 90 年代，我们也有了分布式系统的爆炸。我们有 CORBA 和 DCOM。我们有客户机/服务器和多层体系结构。当使用数据库作为应用程序之间的通信点时，我们了解了单点故障。是的，我们有严重的问题。我们学会了如何创建“服务”——SOA 正作为一种架构概念出现。我们学会了如何考虑可伸缩性和安全性。政府和银行以外的许多项目也变得非常庞大和复杂。

创造一个伟大的设计是大多数热情的软件开发人员的目标；这也是成为一名建筑师和职业发展的途径。我们必须学习并擅长软件设计。我们必须深入理解结构化和面向对象设计的原则。我们必须理解分布式系统的原理。我们必须深入理解所有层次的内聚性和耦合性。我们必须理解协变和逆变。我们必须学习如何设计组件边界，包括它们的契约和不变量。我们必须学会如何理解动词和名词，商业语言，并将它们映射到软件中。如果不知道如何在我们的关系数据库中建模数据，更重要的是，不知道如何让我们的查询执行得更好，我们将永远无法通过面试。我们必须以正确的粒度定义我们的专有协议，以便其他系统更容易使用它们，同时解决 I/O 和带宽问题。是的，我们花了很多时间做那件事。

90 年代的软件开发都是关于设计和架构的。是的，它必须用 UML 来完成。

但是，尽管我们学会了如何设计，我们在许多其他方面都失败了。我们交付得不够快。事实上，在一些项目中，我们根本没有交付任何东西。大多数时候，由于缺乏快速反馈和我们无法应对快速的业务发展，我们为创建完美设计所做的所有思考都被完全浪费了。我仍然记得在我们写任何代码之前，我们用来控制变更请求的巨大的电子表格。是的，我们搞砸了。很多次。

快进 20 年，我们中的一些人明白我们所做的是错误的。然后，我们将敏捷、精益和许多其他原则和实践融入到我们的工作方式中。我们将许多新的设计和架构技术整合到我们的工具包中。我们融合了新技术。我们整合了不同的业务协作方式，以及如何构建我们的团队。我们了解到虽然设计很重要，但是没有什么比持续交付软件更重要的了。我们学会了如何获得反馈和重复。我们知道我们有责任测试我们自己的代码。我们知道我们必须在生产中支持我们的软件。我们知道了创造原型并扔掉它们的价值。我们知道了实验的价值。但我们也认识到，我们不需要为了更好地工作而放弃多年来获得的所有设计技能。我们不需要抛弃我们之前和那个时代所做的所有伟大的工作，主要是围绕着 70 年代、80 年代和 90 年代的软件设计。但是我们学到的最重要的一课是，上下文才是王道，软件设计就是要权衡取舍。没有交付，设计就毫无意义。但是没有坚实的设计基础，我们还能继续交付代码吗？我不这么认为。

我今天在软件设计中看到的最大问题之一是二进制思维。如果 X 是坏的，那么 Y 一定是好的。如果 X 为公司 A 工作，那么它也会为我们工作。如果一个知名人士在一次会议的 45 分钟演讲中说了些什么，或者我们在博客中发现了些什么，那一定是真的。一直都是。

二进制思维导致的另一个常见错误是相信软件项目中的所有功能都具有相同的复杂程度，并且一个单一的设计选择将适合它们。但事实是，有些特性非常简单，有些非常复杂，还有许多特性介于两者之间。有时复杂性是在实现中发现的；其他时候，它建立在对领域的理解和建模上。有时候，复杂性在于理解我们应该构建什么。其他时候，复杂性在于与其他系统的集成。同一特性的不同部分在复杂性上也有很大差异:一些部分可能很简单，可以快速实现，而另一些部分可能非常复杂，需要预先进行大量思考。一些特性是浅层的(很少几行代码)，而另一些是深层的(成千上万行代码分布在不同的模块中)。非功能性需求也会使简单功能(业务方面)的实现变得非常复杂。有趣的是，所有这些都可以在同一个软件项目中找到。因此，如果我们同意软件项目中的不同功能具有不同程度的复杂性和规模，我们就没有办法将二元思维应用到软件设计中——没有一种单一的设计方法会在相当复杂的软件项目中起作用。

我们生活在一个信息容易快速获取的世界。在谷歌上搜索一下，我们可以找到许多现成的解决问题的方法。我担心的是，作为一个行业，我们正在失去思考的能力。我们正在失去研究和做出自己选择的能力。我们越来越多地寻找现成的配方。一条捷径。我称之为“堆栈溢出解决方案”

令我难过的是，对一些人来说，软件设计是过度工程的同义词。看到“完全没有设计”正在成为敏捷、精益创业和快速交付的同义词，我也很难过。我不认为好的软件设计、敏捷和精益原则的创始人和主要支持者是这个意思。过度工程是不好的，但完全没有设计也是不好的。简单不代表废话。简单意味着我们今天所知道的足够的设计，而不是更少。套用爱因斯坦的话，软件设计应该尽可能简单，但不能更简单。或者换一种说法:代码必须设计良好，但不能过度设计。

在过去几年里，我采访了很多开发人员，审查了很多代码，我主要担心的是，我们正在发展一种黑客文化。我遇到的许多从业不到十年的开发人员，对优秀的软件设计知之甚少。当然，他们会有不同的说法。如果你认为我在夸大其词，请你团队中的开发人员解释一下凝聚力及其不同的层次。问他们同生、协变和逆变。询问他们不同程度和类型的耦合。询问他们关于契约式设计和不变式的问题。对于那些听说过坚实原则的人，问问他们坚实原则从何而来。今天许多开发人员说设计模式不好。请他们描述一些模式、它们的区别以及何时应该或不应该应用它们。询问他们不同的模式分类。询问他们桥、适配器和中介之间的区别。访问者应该解决什么问题？问他们什么是纪念品？如果他们不能解释这一点，他们怎么能说模式不好呢？

今天的许多开发人员没有意识到在 70 年代、80 年代和 90 年代打下的软件设计基础。其他人宁愿忽略它:*这是过度工程化，他们不需要。没关系，我尊重这一点。但是为什么我们仍然有那些糟糕的软件呢？今天生产的软件真的比 20 年前生产的软件好吗？为什么开发人员还在努力用 TDD 设计代码？为什么我们仍然在谈论遗留代码？对我来说，遗留代码是设计糟糕的代码的同义词，因此难以测试和维护。*

我绝不是在为过度工程辩护，也不是在浪费时间用 UML 绘制图表。我想说的是，与此同时，我绝不会花时间预先在我的核心领域内设计类，我也不会试图构建一个企业应用程序，一次一个测试，在开始编码之前不考虑它的整体设计。设计对于软件开发至关重要。如果我正在构建一个与许多应用程序共存于一个生态系统中的应用程序，或者具有大量非功能性需求的应用程序，或者需要遵守法规的应用程序，是的，我当然会在开始编码之前对其整体结构(宏观设计)进行大量思考，但是我仍然会一次一个测试地开发其功能(“微观层次”)。设计发生在各个层面:从架构层面的预先到微观层面的及时，作为我的 TDD 流程的一部分。决定设计多少是一项技能——这都是关于找到拐点的问题，我在 T2 之前的博客中提到过这个话题。

软件设计是软件开发中最重要的技能之一。好的设计使开发人员能够协作，能够频繁地添加和更改业务特性，并且能够实现可靠的测试自动化。有了经验，我们学会了如何快速识别问题，并决定我们应该在这个问题上花费多少时间。我们还了解到，大多数设计决策应该在最后负责任的时刻做出，也就是说，当我们对问题还没有足够了解的时候，我们尽量不要过早地进行设计。

这就是为什么我说我们在 90 年代所做的一切并非都是徒劳的。尽管我们过度设计了每一件东西，也没有交付太多东西，但我们学会了如何设计。我们学会了如何独立思考。我们学会了研究。我们学会了如何权衡利弊。这花了我们一段时间，但我们也学会了如何避免二元思维，并抑制我们对新趋势的兴奋。强大的软件设计基础与敏捷和精益原则和实践的结合，使我们今天处于一个更好的位置，不仅快速交付软件，而且连续交付软件。

我们的目标是实现业务敏捷性，这可以通过可持续部署到生产中的软件来实现。将软件部署到生产环境中一次并不困难，但是一天多次将软件部署到生产环境中并保持这种节奏几个月甚至几年，这就不那么简单了。我们需要大量的规程和工程来实现持续交付，这使得软件设计和 TDD 成为我们必须掌握的两个最重要的技术规程。