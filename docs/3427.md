# 生产中的码头工人:失败的历史——HFT 的家伙

> 原文：<https://thehftguy.wordpress.com/2016/11/01/docker-in-production-an-history-of-failure/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website>

# 介绍

我和 docker 的第一次相遇要追溯到 2015 年初。对 Docker 进行了实验，以了解它是否对我们有益。当时不可能[在后台]运行一个容器，也没有任何命令来查看容器中正在运行什么、调试或 ssh。实验很快，Docker 没有用，更接近于 alpha 原型而不是发布版。

快进到 2016 年。新工作、新公司和码头工人的炒作正在疯狂增长。这里的开发人员已经将 docker 推向生产项目，我们被它卡住了。好的一面是，run 命令终于起作用了，我们可以启动、停止和查看容器。它是功能性的。

在我们撰写本文时，有 12 个 docker 化的应用程序正在生产中运行，分布在 AWS 上的 31 台主机上(每台主机一个 docker 应用程序[注意:继续阅读以了解原因])。

下面这篇文章讲述了我们与 Docker 的旅程，一次充满危险和意想不到的转折的冒险。

![so it begins, the greatest fuck up of our time](img/46742d75cbea0705caf39bd32fdff822.png)

# Docker 的生产问题

## Docker 问题:突破性的变化和倒退

我们运行了所有这些版本(或试图运行):

```
1.6 => 1.7 => 1.8 => 1.9 => 1.10 => 1.11 => 1.12
```

每个新版本都有突破性的变化。今年年初，我们开始在 docker 1.6 上运行一个应用程序。

我们 3 个月后进行了更新，因为我们需要一个仅在以后版本中可用的补丁。1.6 分支已经被放弃了。

版本 1.7 和 1.8 无法运行。我们迁移到 1.9 版本，两周后才发现上面有一个严重的错误，所以我们升级了(再次！)到 1.10。

Docker 版本之间有各种微妙的回归。它不断以意想不到的方式打破不可预测的东西。

我们必须调试的最棘手的回归是网络相关的。Docker 完全抽象了主机网络。这是一个端口重定向，DNS 技巧和虚拟网络的大混乱。

**奖励** : Docker 去年从 Debian 官方仓库移除，然后这个包从 *docker.io* 改名为 *docker-engine* 。此次变更之前的文档和资源已经过时。

## Docker 问题:无法清理旧图像

Docker 中最受欢迎和最缺乏的功能是清理旧图像的命令(旧于 X 天或 X 天未使用，等等)。**空间是一个关键问题，因为图像会频繁更新，每个图像可能会占用 1GB 以上的空间。** 

清理空间的唯一方法是运行这个 hack，最好是每天在 cron 中运行:

```
docker images -q -a | xargs --no-run-if-empty docker rmi
```

它枚举所有图像并删除它们。正在运行的容器当前正在使用的那些不能被删除(它给出一个错误)。虽然很脏，但它完成了任务。

码头工人的旅程从清理脚本开始。这是每个组织都必须经历的入会仪式。

网上能找到很多尝试，都不好用。没有 API 可以列出带有日期的图片，有时候有，但是在 6 个月内就不推荐了。一种常见的策略是从图像文件中读取日期属性并调用' *docker rmi* '，但是当命名发生变化时，它会失败。另一种策略是读取日期属性并直接删除文件，但如果做得不完美，它会导致损坏，而且**除了 Docker 本身，它无法完美地完成。**

## Docker 问题:内核支持(或缺乏支持)

关于内核、发行版、docker 和文件系统之间的交互，存在无穷无尽的问题

我们在生产中使用 Debian stable 和 backports。我们开始在 Debian Jessie 3 . 16 . 7-CKT 20-1(2015 年 11 月发布)上运行。这一个遭受一个主要的严重错误，不稳定地使主机崩溃(平均每几个小时)。

### Linux 3.x:不稳定的存储驱动

Docker 有各种[存储驱动](https://docs.docker.com/engine/userguide/storagedriver/selectadriver/)。唯一(据称)受到广泛支持的是 AUFS。

AUFS 的司机不稳定。它遭受着引起内核恐慌和损坏数据的严重错误。

**在【至少】所有的“linux-3.16.x”内核上都坏了。没有治愈的方法。**

我们密切关注 Debian 和内核的更新。Debian 在常规周期之外发布了特殊的补丁。大约在 2016 年 3 月，AUFS 出现了一个重大错误。我们认为这是一个真正的修复，但事实证明它不是。后来内核崩溃发生的频率降低了(每周，而不是每天)，但它们仍然很大，而且仍然存在。

今年夏天有一次，在一次重大更新中出现了一次倒退，这又带回了以前的一个关键问题。它开始一个接一个地杀死 CI 服务器，平均间隔 2 个小时。很快发布了一个紧急补丁来修复这种退化。

2016 年发布了多个对 AUFS 的修复。一些关键问题已经修复，但还有更多问题。AUFS 在(至少)所有的“linux-3.16.x”内核上都不稳定。

*   Debian stable 卡在内核 3.16。它不稳定。除了切换到 Debian 测试(可以用 kernel 4)之外，没有别的办法。

*   Ubuntu LTS 运行的是内核 3.19。不能保证此最新更新解决了该问题。改变我们的主操作系统将是一个重大的破坏，但我们是如此绝望，我们考虑了一段时间。

*   RHEL/CentOS-6 在内核 2.x 上，RHEL/CentoS-7 在内核 3.10 上(RedHat 后来做了很多回移植)。

### Linux 4.x:内核正式放弃 docker 支持

众所周知，AUFS 问题层出不穷，被开发商视为累赘。作为一个长期的目标，AUFS 文件系统最终在内核版本 4 中被删除了。

没有非官方的补丁来支持它，没有可选的模块，没有任何支持，什么都没有。AUFS 完全消失了。

[戏剧性的停顿]

。

。

。

没有 AUFS，docker 是如何工作的？嗯，没有。

[戏剧性的停顿]

。

。

。

所以，docker 的人写了一个新的文件系统，叫做 overlay。

OverlayFS 是一个类似于 AUFS 的现代联合文件系统。与 AUFS 相比，OverlayFS 的设计更简单，从 3.18 版本开始就已经是主流的 Linux 内核了，而且可能会更快— [码头工人重叠服务司机](https://docs.docker.com/engine/userguide/storagedriver/overlayfs-driver/)

请注意，它没有被移植到现有的发行版。Docker 从不关心[向后]兼容性。

**评论后更新** : Overlay 是支持它的内核模块(由 linux 维护者开发)和使用它的 docker 存储驱动程序(docker 的一部分，由 docker 开发)的名字。他们是两个不同的组成部分(历史和开发者可能会有重叠)。这些问题似乎主要与 docker 存储驱动程序有关，而不是文件系统本身。

## 覆盖的失败

文件系统驱动程序是一个复杂的软件，它需要非常高的可靠性。长期读者会记得 Linux 从 ext3 到 ext4 的迁移。它需要时间来编写，需要更多的时间来调试，并且在流行的发行版中作为默认文件系统来发布。

在一年内制作一个新的文件系统是不可能完成的任务。当考虑到任务被分配给 Docker 时，这实际上是可笑的，他们有不稳定和灾难性的破坏性变化的记录，这正是我们不想在文件系统中看到的。

长话短说。那并不顺利。你仍然可以用谷歌找到恐怖故事。

覆盖层开发在最初发布后 1 年内被放弃。

[戏剧性的停顿]

。

。

。

然后是重叠 2。

"*覆盖 2 驱动程序解决了覆盖限制，但仅兼容 Linux 内核 4.0[或更高版本]和 docker 1.12* " — [覆盖与覆盖 2 存储驱动程序](https://docs.docker.com/engine/userguide/storagedriver/selectadriver/#overlay-vs-overlay2)

在一年内制作一个新的文件系统仍然是一个不可能完成的任务。Docker 只是尝试了一下，失败了。然而他们又在尝试了！我们会看到几年后的结果。

目前我们运行的任何系统都不支持它。我们不能使用它，甚至不能测试它。

**经验教训**:如你所见，覆盖然后覆盖 2。没有反向端口。没有补丁。没有复古兼容性。Docker 只会向前移动，打破东西。如果你想采用 docker，你也必须继续前进，跟随 Docker、内核、发行版、文件系统和一些依赖项的发布。

## 额外收获:全球码头工人停工

2016 年 6 月 2 日，大约上午 9 点(伦敦时间)。新的库密钥被推送到 docker 公共库。

其直接后果是，在配置了中断的回购协议的系统上，任何“ *apt-get update* ”(或等效操作)的运行都将失败，并出现错误“*错误[https://apt.dockerproject.org/](https://apt.dockerproject.org/)哈希和不匹配*

这个问题是全球性的。它会影响地球上所有配置了 docker 存储库的系统。在所有 Debian 和 ubuntu 版本上确认，独立于 OS 和 docker 版本。

**世界上所有依赖 docker 设置/更新或系统设置/更新的 CI 渠道都已中断。不可能在现有系统上运行系统更新或升级。创建一个新系统并在上面安装 docker 是不可能的。** 

过了一会儿。我们从 docker 雇员那里得到一个更新:“*给出一个更新；我在内部提出了这个问题，但是需要解决这个问题的人在旧金山时区(与伦敦有 8 个小时的时差)，所以他们还没有出现。*

我个人在内部向我们的开发者宣布。如今，没有 Docker CI，我们无法创建新系统，也无法更新依赖 Docker 的现有系统。我们所有的希望都寄托在旧金山一个正在睡觉的家伙身上。

[暂停等待修复，这时免费食物和饮料就派上用场了]

下午 3 点左右(伦敦时间)，佛罗里达的一个码头工人发布了一条更新。他醒了，他发现了问题所在，正在努力解决。

稍后会重新发布密钥和包。

我们尝试在下午 5 点左右(伦敦时间)确认定位。

因为 Docker，那是一次 7 小时的星际中断。这次中断留下的只是一些关于 [GitHub 问题的消息](https://github.com/docker/docker/issues/23203)。没有尸检。它几乎没有(没有？)科技新闻或媒体报道，尽管这是一次灾难性的失败。

# 坞站注册表

docker 注册表存储和提供 docker 图像。

```
Automatic CI build  ===> (on success) push the image to ===> docker registry
```

```
Deploy command <=== pull the image from <=== docker registry
```

有一个由 docker 经营的公共登记处。作为一个组织，我们也运行自己的内部 docker 注册表。它是一个运行在 docker 主机上 docker 内部的 docker 映像(相当元)。docker 注册表是最常用的 docker 图像。

docker 注册表有 3 个版本。客户可以随意从任何:

## Docker 注册表问题:放弃并取消

docker registry v2 是完全重写的。v2 发布后不久，注册中心 v1 就退役了。

我们不得不安装一个新的东西(再次！)只是为了让 docker 继续工作。他们更改了配置、URL、路径和端点。

向 registry v2 的过渡并不是无缝的。我们必须修复我们的设置、构建和部署脚本。

吸取的教训:不要相信任何 docker 工具或 API。它们不断被抛弃和消灭。

registry v2 的目标之一是带来更好的 API。这里记录了，一份我们不记得 9 个月前存在的文件。

## Docker 注册表问题:无法清理图像

无法从 docker 注册表中删除图像。也没有垃圾收集，文档提到过，但不是真的。(图像确实有压缩和重复数据删除，但那是另一回事)。

注册表永远在增长。我们的注册表每周可以增长 50 GB。

我们不可能拥有无限存储量的服务器。我们的注册中心有几次空间不足，给我们的构建管道带来了麻烦，然后我们将图像存储转移到了 S3。

**经验教训:使用 S3 存储图像**(支持开箱即用)。

我们总共执行了 3 次手动清理。在所有情况下，我们必须停止注册表，清除所有的存储，并启动一个新的注册表容器。(幸运的是，我们可以用我们的 CI 重新构建最新的 docker 映像)。

从 docker 注册表中手动删除任何文件或文件夹都会损坏它。

迄今为止，无法从 docker 注册表中删除图像。也没有 API。(v2 的一个目的是拥有更好的 API。任务失败)。

# Docker 问题:发布周期

**docker 发布周期是 Docker 生态系统中唯一不变的:**

1.  抛弃现有的一切
2.  制作新的东西并发布
3.  忽略现有用户和追溯兼容性

发布周期适用于但不限于:docker 版本、特性、文件系统、docker 注册表、所有 API…

从 Docker 过去的历史来看，我们可以近似的得出，Docker 做的任何东西都有 1 年左右的半衰期，也就是说现在存在的东西有**一半会在 1 年**后被抛弃【和消灭】。通常会有一个替代品可用，它与它要替代的东西不完全兼容，可能会也可能不会在同一个生态系统上运行(如果有的话)。

我们制作软件不是为了让人们使用，而是因为我们喜欢制作新的东西—未来码头工人的墓志铭

# 我们组织中码头工人的现状

## 网络和微服务的增长

Docker 最初是通过一个 web 应用程序进来的。当时，开发人员很容易打包和部署它。他们尝试了一下，很快就采用了。然后，随着我们开始采用微服务架构，它扩展到了一些微服务。

Web 应用和微服务是类似的。它们是无状态的应用程序，可以不加思考地启动、停止、终止、重启。所有的硬东西都被委托给外部系统(数据库和后端系统)。

docker 的采用始于较小的新服务。起初，在开发、测试和生产中一切都很好。随着更多的 web 服务和 web 应用程序被 dockerized 化，内核恐慌慢慢开始发生。随着我们的成长，稳定性问题变得更加突出和有影响力。

一年中发布了一些补丁和回归。我们已经用 Docker 玩了一段时间了。这是一种痛苦，但似乎并没有阻止人们采用 Docker。组织内部的支持和需求仍在增长。

**注意**:这些故障从未影响到任何客户或资金。我们在控制码头工人方面相当成功。

## 从核心禁止

我们有一些运行在 Erlang 中的关键应用程序，由“核心”团队中的几个人管理。

他们试图在 Docker 中运行他们的一些应用程序。没用。由于某些原因，Erlang 应用程序和 docker 并没有一起发展。

这是很久以前做的，我们不记得所有的细节了。Erlang 对系统/网络应该如何运行有着特殊的想法，预期的负载是每秒数千个请求。任何不稳定或不兼容都可能成为明显失败的理由。(我们现在可以肯定地知道，在试验中使用的版本有多个主要的不稳定性问题)。

审判发出了危险信号。Docker 还没有准备好迎接任何重要的事情。这是正确的决定。后来的崩溃和问题设法证实了这一点。

我们只在关键应用程序中使用 Erlang。例如，**核心人员负责一个支付系统，该系统本月处理了 96，544，800 美元的交易**。它包括几个应用程序和数据库，所有这些都由他们负责。

Docker 是一种危险的负债，可能会让数百万人面临风险。它被所有核心系统禁止。

## 禁止 DBA 访问

Docker 本来就是无状态的。容器没有永久的磁盘存储，无论发生什么都是短暂的，当容器停止时就消失了。容器不是用来存储数据的。实际上，它们的设计意图是不存储数据。任何违背这一哲学的企图都注定要失败。

而且。Docker 通过它的抽象锁定了进程和文件，它们是不可访问的，就好像它们不存在一样。如果出现问题，它会阻止进行任何形式的恢复。

长话短说。根据设计，Docker 不应在生产中运行数据库。

比那更糟。还记得 docker 正在发生的内核崩溃吗？

崩溃会破坏数据库，并影响与其连接的所有系统。这是一个不稳定的错误，在大量使用的情况下会更频繁地触发。数据库是最终的 IO 密集型负载，这肯定会导致内核崩溃。此外，还有另一个 bug 会破坏 docker 挂载(破坏所有数据)，也可能破坏系统文件系统(如果它们在同一个磁盘上)。

噩梦般的场景:主机崩溃，磁盘损坏，破坏主机系统和过程中的所有数据。

结论: **Docker 决不能在生产中运行任何数据库。**

每隔一段时间就会有人过来问“*我们为什么不把这些数据库放到 docker* 里？”我们将讲述一些我们无数的战争故事，到目前为止，没有人问第二次。

**注意**:作为入职流程的一部分，我们开始回顾我们的码头工人历史。这是新的损害控制理念，在 docker 有机会成长并杀死我们之前扼杀它。

## 个人意见

Docker 的势头越来越大，有一些疯狂的狂热支持者。docker 炒作不再仅仅是一个技术问题，它也已经演变成一个社会学问题。

边界目前是受控的，仅限于一些无状态的 web 应用程序和微服务。这是不重要的东西，它们可以被归档，每天崩溃一次，我不在乎。

到目前为止，所有想用 docker 做重要事情的人在一次简短的讨论后都停止了。我最害怕的是有一天，一个码头工人狂热分子不听劝，继续推。我将被迫拦截他，这可能不太好。

噩梦般的场景:未来会计集群改造，目前拥有 2300 万美元的客户资金(M 代表百万美元)。已经有一个人真诚地问架构师"*为什么不把这些数据库放入 docker？*”，没有一个词可以形容建筑师的脸。

我的职责是为顾客服务。保护他们和他们的钱。

# 生产中幸存的码头工人

![gif-what-docker-pretends-to-be](img/82d6a201402385ceab1ab08ed5c2905d.png)

What docker pretends to be.



![gif-what-docker-really-is](img/4d9519a29271511bd6a240e3df35ea7d.png)

What docker really is.



## 跟踪版本和变更日志

密切跟踪内核、操作系统、发行版、docker 以及两者之间的所有内容的版本和变更日志。寻找 bug，希望补丁，用心阅读一切。

```
ansible '*' -m shell -a "uname -a"
```

## 让 docker 崩溃吧

让 docker 崩溃吧。不言自明。

偶尔，我们会查看哪些服务器已经失效，然后强制重启它们。

## 每样东西都有 3 个实例

高可用性要求每个服务至少有两个实例，以便在一个实例失败后仍然存在。

当使用 docker 处理任何不太重要的事情时，我们应该有 3 个它的实例。Docker 一直在崩溃，我们需要一个误差范围来支持同一服务中的两次崩溃。

大多数时候，崩溃的是 CI 或测试实例。(他们进行了大量的密集测试，问题尤其突出)。我们有很多这样的东西。有时候一个下午会有三个人挤在一起。

## 不要将数据放入 Docker

存储数据的服务不能被 dockerized。

Docker 被设计成不存储数据。不要反对它，它会导致灾难。

最重要的是，当前的问题会破坏服务器，并有可能破坏数据，所以这是一个很大的禁忌。

## 不要在 Docker 中运行任何重要的内容

**Docker 会崩溃。Docker 会毁掉它接触到的一切。**

它必须限于那些可能崩溃但不会导致停机的应用程序。这意味着大部分无状态的应用程序可以在其他地方重启。

## 将 docker 放入自动缩放组

Docker 应用程序应该在自动缩放组中运行。(注意:我们还没有完全做到这一点)。

每当一个实例崩溃，它会在 5 分钟内自动替换。不需要手动操作。自愈。

# 未来路线图

## 码头工人

Docker 面临的最大挑战是内核+发行版+ docker 版本+文件系统的组合。

现在。我们不知道有什么组合是稳定的(也许根本就没有？).我们积极寻找，不断测试新的系统和补丁。

**目标**:找到一个稳定的生态系统来运行 docker。

做一个好的稳定的软件需要 5 年时间，Docker v1.0 才 28 个月，它没有时间成熟。

硬件更新周期为 3 年，发行版发布周期为 18-36 个月。Docker 在上一个周期中并不存在，所以系统无法考虑与它的兼容性。更糟糕的是，它依赖于许多相对较新的高级系统内部组件，这些组件也没有时间成熟，也没有发布。

这可能是一个体面的软件在 5 年内。等着瞧。

**目标**:等待事情好转。在此期间尽量不要破产。

## 使用自动缩放组

Docker 仅限于无状态应用程序。如果一个应用程序可以打包成 Docker 映像，那么它就可以打包成 AMI。如果一个应用程序可以在 Docker 中运行，它就可以在自动缩放组中运行。

大多数人都忽略了它，但 Docker 在 AWS 上毫无用处，这实际上是一种倒退。

**首先**，容器的意义在于通过在同一个【大】主机上运行许多容器来节省资源。(让我们暂时忽略当前的 docker 错误，它使主机[和其上所有运行的容器]崩溃，为了可靠性，迫使我们每台主机只运行一个容器)。

因此，容器对于云提供商来说毫无用处。总有一个大小合适的实例。只需为应用程序创建一个具有适当内存/CPU 的应用程序。(AWS 上的最低价格是 t2.nano，512MB 和 5%的 CPU 每月 5 美元)。

**第二个**，容器最大的收获是当有一个完整的编排系统围绕着它们来自动管理创建/停止/启动/滚动-更新/金丝雀-发布/蓝-绿-部署。实现这一目标的流程编排系统目前尚不存在。(这就是游牧民族/梅索斯人/库伯内特人最终会出现的地方，他们目前的状态还不够好)。

AWS 有自动扩展组来管理实例的编排和生命周期。这是一个与 Docker 生态系统完全无关的工具，但它可以实现更好的结果，没有任何缺点和错误。

为每个服务创建一个自动扩展组，并为每个版本构建一个 AMI(提示:使用 [Packer](https://www.packer.io/) 来构建 AMI)。如果操作是在 AWS 上进行的，那么人们已经熟悉了 AMI 和实例的管理，没有什么需要学习的，也没有什么陷阱。最终的部署是完美的，并且是完全自动化的。**拥有自动扩展组的设置比 Docker 生态系统领先 3 年。**

**目标**:将 docker 服务放入自动扩展组，以便自动处理故障。

## 科里奥斯

**评论后更新** : Docker 和 CoreOS 是分开的公司做的。

为了让 Docker 松一口气，它需要并依赖于许多新的高级系统内部组件。经典发行版不能升级主要发行版之外的系统内部组件，即使它想这样做。

docker 拥有(或者是？)具有适当的[更新周期](https://coreos.com/releases/)的专用操作系统。这可能是让内核和操作系统能够运行 Docker 的唯一方法。

**目标**:试用 CoreOS 生态系统并评估稳定性。

在大的操作方案中，将运行容器的服务器(在 CoreOS 上)与普通服务器(在 Debian 上)分开是可行的。容器不应该知道(或者关心)它们运行的是什么操作系统。

麻烦在于管理新的操作系统系列(设置、供应、升级、用户帐户、日志记录、监控)。不知道我们要怎么做，也不知道要做多少工作。

**目标**:自由部署 CoreOS。

## 库伯内特斯

一个[未来的]重大突破是能够管理从最终运行它们的机器中抽象出来的集装箱船队，具有自动启动/停止/滚动更新和容量调整，

Docker 的问题是它不具备这些功能。这只是一个愚蠢的容器系统。它有容器的缺点，却没有优点。

目前还没有好、经过实战检验的、生产就绪的编排系统。

*   Mesos 不是给码头工人准备的
*   码头工人群不值得信任
*   游牧者只有最基本的特征
*   Kubernetes 是新的和实验性的

Kubernetes 是唯一一个打算解决(围绕容器的)难题的项目。它得到了其他项目所没有的资源的支持(例如，谷歌有大规模运行容器的长期经验，他们有谷歌数量的资源可以支配，他们知道如何编写工作软件)。

目前，Kubernetes 还很年轻&还处于实验阶段，还缺乏文档。进入的障碍是痛苦的，而且远非完美。尽管如此，它(在某种程度上)正在发挥作用，并且已经让一小部分人受益。

从长远来看，Kubernetes 就是未来。这是一个重大突破(或者准确地说，这是容器成为基础设施管理中的一个重大发展所缺少的最后一块砖)。

问题不是是否采用 Kubernetes，问题是何时采用？

**目标**:盯紧 Kubernetes。

**注意** : Kubernetes 需要 docker 来运行。它会受到所有码头问题的影响。(例如，不要在 CoreOS 之外的任何东西上尝试 Kubernetes)。

## 谷歌云:谷歌容器引擎

正如我们之前所说，没有已知的稳定的操作系统+内核+发行版+ docker 版本的组合，因此没有稳定的生态系统来运行 Kubernetes。这是个问题。

有一个潜在的解决方法: [Google 容器引擎](https://cloud.google.com/container-engine/)。它是托管的 Kubernetes(和 Docker)即服务，是谷歌云的一部分。

谷歌必须解决 Docker 的问题，以提供他们所提供的，没有其他选择。顺便说一句，他们可能是唯一能够在 Docker 周围找到一个稳定的生态系统，修复错误，并出售现成的云计算托管服务的人。我们可能会有一次共同的目标。

他们已经提供了服务，这意味着他们已经解决了 Docker 问题。因此，让容器在生产中工作(或者根本不工作)的最简单的方法可能是使用 Google 容器引擎。

**目标**:转向谷歌云，从我们未锁定 AWS 的子公司开始。忽略路线图的其余部分，因为它已经变得不相关了。

谷歌容器引擎(Google Container Engine):谷歌云是未来而 AWS 是过去的又一个原因(此外还有 33%更便宜的实例，平均 3 倍的网络速度和 IOPS)。

* * *

[为什么 docker 尚未成功制作](http://sirupsen.com/production-docker/)，2015 年 7 月，Shopify 首席制作工程师。

Docker 还没准备好黄金时段，2016 年 8 月。

[生产中的 Docker:一个反驳](https://patrobinson.github.io/2016/11/05/docker-in-production/)，2016 年 11 月，对本文的回应。

[如何用 Docker 部署应用程序…和不用 Docker](https://thehftguy.com/2016/11/14/what-is-docker-and-when-to-use-it/) ，应用程序部署介绍，HFT 家伙。

* * *

## 免责声明(请在评论前阅读)

这篇文章缺少一点上下文。我们是一家拥有数百台服务器的小商店。实际上，我们正在运行一个每天流动数百万美元(或每年数十亿美元)的金融系统。

公平地说，我们比一般人有更高的期望，我们也更重视生产问题？)说真的。

总的来说，如果您没有在生产中大规模使用 docker 和/或如果您没有长时间使用它，那么您没有遇到所有这些问题是正常的。

我想指出的是，这些都是一年多来发生的问题和解决方法，在 10 分钟的阅读中总结起来。它确实放大了戏剧性和痛苦的一面。

反正过去发生的都已经过去了。最重要的部分是路线图。这就是你需要知道的运行 Docker(或使用自动缩放组代替)。

### 像这样:

像 装...